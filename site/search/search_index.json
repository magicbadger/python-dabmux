{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python DAB Multiplexer","text":"<p>Welcome to the documentation for python-dabmux, a pure Python implementation of a DAB/DAB+ multiplexer that recreates the functionality of ODR-DabMux.</p>"},{"location":"#what-is-python-dabmux","title":"What is python-dabmux?","text":"<p>python-dabmux is a complete DAB (Digital Audio Broadcasting) multiplexer that combines multiple audio streams into a single DAB ensemble for transmission. It supports both traditional DAB (MPEG Layer II) and DAB+ (HE-AAC v2) audio formats, with full EDI (Ensemble Data Interface) network output capabilities.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Complete DAB/DAB+ Support: Full implementation of ETI frame generation, FIG (Fast Information Group) encoding, and ensemble multiplexing</li> <li>Multiple Input Sources: File-based inputs (MPEG, raw), UDP/TCP network streaming, with automatic frame parsing and validation</li> <li>Flexible Output Options: ETI file formats (raw, framed, streamed), EDI network output with UDP/TCP support</li> <li>PFT with FEC: Protection, Fragmentation and Transport layer with Reed-Solomon forward error correction</li> <li>Network Streaming: UDP multicast and TCP server inputs for live audio streaming</li> <li>Configuration Management: YAML-based configuration with validation and comprehensive examples</li> <li>Robust Architecture: Well-tested (389 tests, 71% coverage), type-annotated, and production-ready</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>\ud83c\udf89 python-dabmux is feature-complete!</p> <p>All core functionality has been implemented through 6 development phases:</p> <ul> <li>\u2705 Phase 0: Foundation (ETI frames, CRC, ensemble configuration)</li> <li>\u2705 Phase 1: Input/Output abstractions</li> <li>\u2705 Phase 2: FIG generation and carousel</li> <li>\u2705 Phase 3: Data input and encoding</li> <li>\u2705 Phase 4: Network inputs and timestamps</li> <li>\u2705 Phase 5: EDI protocol and DAB+ support</li> <li>\u2705 Phase 6: Advanced features and usability</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started with python-dabmux:</p>"},{"location":"#5-minute-setup","title":"\u26a1 5-Minute Setup","text":"<p>From audio to multiplexed stream in 3 commands:</p> <pre><code># 1. Encode audio\nffmpeg -i music.mp3 -c:a mp2 -ar 48000 -b:a 128k audio.mp2\n\n# 2. Create config.yaml (see quick setup guide)\n\n# 3. Run multiplexer\npython -m dabmux.cli -c config.yaml -o output.eti --continuous\n</code></pre> <p>\u26a1 Quick Setup Guide \u2192 Full Tutorial \u2192</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#for-new-users","title":"\ud83d\udcda For New Users","text":"<ul> <li>Getting Started: Installation, first multiplex, and basic concepts</li> <li>Tutorials: Hands-on guides for common scenarios</li> <li>FAQ: Frequently asked questions</li> </ul>"},{"location":"#for-regular-users","title":"\ud83d\udcd6 For Regular Users","text":"<ul> <li>User Guide: Comprehensive configuration and CLI reference</li> <li>Configuration: Complete parameter reference</li> <li>Troubleshooting: Common errors and solutions</li> </ul>"},{"location":"#for-developers","title":"\ud83c\udfd7\ufe0f For Developers","text":"<ul> <li>Architecture: System design with Mermaid diagrams</li> <li>API Reference: Complete API documentation</li> <li>Advanced Topics: Deep dives into FIG types, FEC, and more</li> <li>Development: Contributing, testing, and roadmap</li> </ul>"},{"location":"#for-standards-implementers","title":"\ud83d\udcd0 For Standards Implementers","text":"<ul> <li>Standards: ETSI compliance and references</li> <li>Glossary: DAB terminology and acronyms</li> </ul>"},{"location":"#key-capabilities","title":"Key Capabilities","text":""},{"location":"#input-sources","title":"Input Sources","text":"<ul> <li>File Inputs: MPEG Layer II files, raw audio, packet data</li> <li>Network Inputs: UDP unicast/multicast, TCP server connections</li> <li>Audio Formats: MPEG Layer II (DAB), HE-AAC v2 (DAB+)</li> </ul>"},{"location":"#output-formats","title":"Output Formats","text":"<ul> <li>ETI Files: Raw ETI, streamed ETI (with timestamps), framed ETI</li> <li>EDI Network: UDP/TCP with TAG items, AF packets, optional PFT with FEC</li> <li>Multiple Outputs: Simultaneous file and network output</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>YAML Configuration: Human-readable configuration files</li> <li>Validation: Automatic validation with helpful error messages</li> <li>Examples: Comprehensive examples for common scenarios</li> </ul>"},{"location":"#advanced-features","title":"Advanced Features","text":"<ul> <li>FIG Carousel: Automatic rotation of FIG types with configurable timing</li> <li>Character Encoding: Full EBU Latin to UTF-8 conversion</li> <li>Timestamps: TIST (Time-Stamp) support for synchronization</li> <li>Statistics: Input buffer monitoring, underrun/overrun detection</li> <li>Error Protection: Configurable protection levels (0-4) with shortform/longform</li> </ul>"},{"location":"#why-python-dabmux","title":"Why python-dabmux?","text":"<ul> <li>Pure Python: Easy to install, modify, and integrate</li> <li>Educational: Clear code structure for learning DAB standards</li> <li>Well-Tested: 389 unit tests with 71% code coverage</li> <li>Type-Safe: Full type annotations with mypy validation</li> <li>Standards-Compliant: Follows ETSI EN 300 799 and related specifications</li> <li>Production-Ready: Feature-complete with robust error handling</li> </ul>"},{"location":"#example-usage","title":"Example Usage","text":""},{"location":"#basic-single-service","title":"Basic Single Service","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Test Ensemble'\n    short: 'Test'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 2\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n      short: 'Radio1'\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n</code></pre> <p>Run it:</p> <pre><code>python -m dabmux.cli -c config.yaml -o output.eti\n</code></pre> <p>More Examples \u2192</p>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub: Report issues</li> <li>Documentation: You're reading it!</li> <li>Examples: Check the <code>examples/</code> directory in the repository</li> </ul>"},{"location":"#license","title":"License","text":"<p>python-dabmux is open source software. See the repository for license details.</p> <p>Ready to get started? Head to the Installation Guide or dive into Your First Multiplex!</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Common questions about python-dabmux and DAB multiplexing.</p>"},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-python-dabmux","title":"What is python-dabmux?","text":"<p>python-dabmux is a pure Python implementation of a DAB/DAB+ multiplexer. It combines multiple audio streams into a single DAB ensemble for transmission, similar to ODR-DabMux but written in Python.</p> <p>Key features: - Complete ETI frame generation - File and network inputs (UDP/TCP) - ETI file and EDI network outputs - PFT with Reed-Solomon FEC - YAML configuration files - 389 unit tests, 71% coverage</p>"},{"location":"faq/#why-use-python-dabmux-instead-of-odr-dabmux","title":"Why use python-dabmux instead of ODR-DabMux?","text":"<p>Choose python-dabmux if you want: - Pure Python implementation (easy to modify and integrate) - Clear, readable code for learning DAB standards - Easy installation with pip - Python-based tooling and workflows</p> <p>Choose ODR-DabMux if you need: - Production-proven C++ implementation - Maximum performance - Lower resource usage - Established ecosystem</p> <p>Both are great options! python-dabmux is feature-complete and production-ready, but ODR-DabMux has been used in broadcast environments for years.</p>"},{"location":"faq/#is-python-dabmux-production-ready","title":"Is python-dabmux production-ready?","text":"<p>Yes! python-dabmux is feature-complete with: - All core features implemented (Phases 0-6 complete) - 389 unit tests with 71% code coverage - Full type annotations with mypy validation - Standards-compliant (ETSI EN 300 799)</p> <p>Use cases: - \u2705 Development and testing - \u2705 Small to medium deployments - \u2705 Educational purposes - \u2705 Integration with Python tools - \u26a0\ufe0f Large-scale production (consider ODR-DabMux for maximum performance)</p>"},{"location":"faq/#what-python-version-is-required","title":"What Python version is required?","text":"<p>Python 3.11 or later is required.</p> <p>python-dabmux uses modern Python features like: - Type annotations with <code>|</code> union syntax - Structural pattern matching - Improved type hints</p> <p>Check your version: <pre><code>python --version\n</code></pre></p> <p>Install Python 3.11+: <pre><code># Ubuntu/Debian\nsudo apt install python3.11\n\n# macOS (Homebrew)\nbrew install python@3.11\n</code></pre></p>"},{"location":"faq/#configuration-questions","title":"Configuration Questions","text":""},{"location":"faq/#how-do-i-create-a-configuration-file","title":"How do I create a configuration file?","text":"<p>Create a YAML file with four main sections:</p> <ol> <li>ensemble: Top-level parameters (ID, label, mode)</li> <li>subchannels: Audio/data streams (bitrate, protection, input)</li> <li>services: Radio stations (ID, labels, metadata)</li> <li>components: Links between services and subchannels</li> </ol> <p>Minimal example: <pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'My DAB'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    bitrate: 128\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n\ncomponents:\n  - service_id: '0x5001'\n    subchannel_id: 0\n</code></pre></p> <p>See: Configuration Reference</p>"},{"location":"faq/#whats-the-difference-between-service-and-subchannel","title":"What's the difference between service and subchannel?","text":"<p>Services are what listeners see (radio stations): - Have names and labels - Have programme type (News, Music, etc.) - Multiple services per ensemble</p> <p>Subchannels are the actual data streams: - Carry audio or data - Have bitrates and protection levels - Connect to input sources</p> <p>Components link services to subchannels: - One service can have multiple components - Most commonly: one audio component per service</p> <p>Think of it like this: - Service = \"BBC Radio 1\" (what you tune to) - Subchannel = 128 kbps MPEG audio stream (the data) - Component = Link between them</p>"},{"location":"faq/#why-do-i-need-to-quote-hex-values","title":"Why do I need to quote hex values?","text":"<p>YAML interprets unquoted hex values as regular numbers.</p> <p>Wrong: <pre><code>id: 0xCE15    # YAML sees this as number 52757\n</code></pre></p> <p>Correct: <pre><code>id: '0xCE15'  # YAML sees this as string, parser converts to hex\n</code></pre></p> <p>Rule: Always quote hex values in YAML configuration files.</p>"},{"location":"faq/#can-i-use-the-same-audio-file-for-multiple-services","title":"Can I use the same audio file for multiple services?","text":"<p>Yes! You can point multiple subchannels to the same input file:</p> <pre><code>subchannels:\n  - uid: 'sub1'\n    id: 0\n    input: 'file://audio.mp2'  # Same file\n  - uid: 'sub2'\n    id: 1\n    input: 'file://audio.mp2'  # Same file\n</code></pre> <p>Each subchannel will independently read the file. This is useful for: - Testing with one audio source - Simulcasting the same content - Different protection levels for same content</p>"},{"location":"faq/#how-many-services-can-i-have-in-one-ensemble","title":"How many services can I have in one ensemble?","text":"<p>Theoretical limit: 64 subchannels (6-bit subchannel ID)</p> <p>Practical limit: Depends on capacity units available: - Mode I: 864 CU total - Each service uses CUs based on bitrate and protection level</p> <p>Example (Mode I): - 6-7 services at 128 kbps each (moderate protection) - 10-12 services at 64 kbps each (DAB+) - Fewer services at higher bitrates</p> <p>Calculation: Use a capacity calculator or let python-dabmux warn you if you exceed capacity.</p>"},{"location":"faq/#audio-and-input-questions","title":"Audio and Input Questions","text":""},{"location":"faq/#what-audio-formats-are-supported","title":"What audio formats are supported?","text":"<p>DAB (traditional): - MPEG-1 Audio Layer II (<code>.mp2</code> files) - Bitrates: 32-384 kbps (typical: 128-192 kbps)</p> <p>DAB+ (modern): - HE-AAC v2 (<code>.aac</code> files) - Bitrates: 32-192 kbps (typical: 48-72 kbps)</p> <p>Input methods: - File: <code>file://audio.mp2</code> - UDP: <code>udp://239.1.2.3:5001</code> - TCP: <code>tcp://192.168.1.100:5001</code></p>"},{"location":"faq/#how-do-i-convert-audio-to-mpeg-layer-ii","title":"How do I convert audio to MPEG Layer II?","text":"<p>Use ffmpeg to convert any audio to MPEG Layer II:</p> <pre><code># From WAV\nffmpeg -i input.wav -codec:a mp2 -b:a 128k output.mp2\n\n# From MP3\nffmpeg -i input.mp3 -codec:a mp2 -b:a 128k output.mp2\n\n# From AAC\nffmpeg -i input.m4a -codec:a mp2 -b:a 128k output.mp2\n\n# Specify sample rate (48 kHz recommended)\nffmpeg -i input.wav -codec:a mp2 -b:a 128k -ar 48000 output.mp2\n</code></pre> <p>Parameters: - <code>-codec:a mp2</code>: MPEG-1 Audio Layer II - <code>-b:a 128k</code>: Bitrate (match your configuration) - <code>-ar 48000</code>: Sample rate (24000, 32000, or 48000 Hz)</p>"},{"location":"faq/#should-i-use-dab-or-dab","title":"Should I use DAB or DAB+?","text":"<p>Use DAB (MPEG Layer II) if: - You need compatibility with older receivers - You want higher bitrates (192+ kbps) - You have existing MPEG equipment</p> <p>Use DAB+ (HE-AAC v2) if: - You want better quality at lower bitrates - You need more services per ensemble - Modern receivers (post-2010)</p> <p>Comparison:</p> Feature DAB (MPEG Layer II) DAB+ (HE-AAC v2) Quality at 64 kbps Fair Good Quality at 128 kbps Excellent Excellent Bitrate range 32-384 kbps 32-192 kbps Efficiency Lower Higher Compatibility Universal Modern only <p>Recommendation: Use DAB+ at 48-72 kbps for music, 32-48 kbps for speech/talk.</p>"},{"location":"faq/#can-i-stream-live-audio-into-python-dabmux","title":"Can I stream live audio into python-dabmux?","text":"<p>Yes! Use UDP or TCP network inputs:</p> <pre><code>subchannels:\n  - uid: 'live1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'udp://239.1.2.3:5001'  # Listen for UDP stream\n</code></pre> <p>Stream audio with ffmpeg: <pre><code># Encode and stream to UDP\nffmpeg -re -i live_input.wav \\\n  -codec:a mp2 -b:a 128k -ar 48000 \\\n  -f rtp udp://239.1.2.3:5001\n</code></pre></p> <p>Or use gstreamer, VLC, or any tool that outputs MPEG Layer II to UDP/TCP.</p>"},{"location":"faq/#output-questions","title":"Output Questions","text":""},{"location":"faq/#whats-the-difference-between-eti-and-edi","title":"What's the difference between ETI and EDI?","text":"<p>ETI (Ensemble Transport Interface): - Raw frame format - File-based or stream-based - No built-in network protocol - Used for: recording, testing, file-based transmission</p> <p>EDI (Ensemble Data Interface): - Network protocol for transmitting ETI - Built on UDP or TCP - Optional PFT (fragmentation and FEC) - Used for: network transmission, multi-transmitter setups</p> <p>When to use: - ETI files: Testing, recording, file exchange - EDI network: Live transmission, distributed systems</p>"},{"location":"faq/#what-eti-file-format-should-i-use","title":"What ETI file format should I use?","text":"<p>Three formats available:</p> <ol> <li>Raw ETI (<code>-f raw</code>):</li> <li>Plain frames, no additional structure</li> <li>Smallest file size</li> <li>Compatible with most tools</li> <li> <p>Use for: General purpose, maximum compatibility</p> </li> <li> <p>Streamed ETI (<code>-f streamed</code>):</p> </li> <li>Frames with timing information</li> <li>Used for timed playback</li> <li> <p>Use for: Synchronized replay, timestamped archives</p> </li> <li> <p>Framed ETI (<code>-f framed</code>, default):</p> </li> <li>8-byte aligned frames with delimiters</li> <li>Easy to parse and process</li> <li>Use for: Processing, analysis, development</li> </ol> <p>Recommendation: Use framed (default) unless you need specific compatibility.</p>"},{"location":"faq/#when-should-i-use-pft","title":"When should I use PFT?","text":"<p>Use PFT (Protection, Fragmentation and Transport) when: - Transmitting over unreliable networks - MTU limitations require fragmentation - Packet loss is expected - Running distributed transmitter network (SFN)</p> <p>PFT provides: - Fragmentation (split large packets to fit MTU) - Sequence numbers (detect missing packets) - Reed-Solomon FEC (recover lost packets)</p> <p>Enable with: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fec\n</code></pre></p> <p>Without PFT: Use for reliable networks (wired, local)</p> <p>With PFT: Use for lossy networks (wireless, WAN, Internet)</p>"},{"location":"faq/#can-i-output-to-both-file-and-network-simultaneously","title":"Can I output to both file and network simultaneously?","text":"<p>Not directly. python-dabmux outputs to one destination at a time.</p> <p>Workarounds:</p> <ol> <li> <p>Run two instances: <pre><code># Terminal 1: File output\ndabmux -c config.yaml -o output.eti --continuous\n\n# Terminal 2: Network output (different config)\ndabmux -c config.yaml --edi udp://239.1.2.3:12000 --continuous\n</code></pre></p> </li> <li> <p>Use tee for UDP: <pre><code># Output to file, use external tools to multicast\ndabmux -c config.yaml -o output.eti\n# Then use separate tool to transmit file over network\n</code></pre></p> </li> <li> <p>Post-process: <pre><code># Generate file first\ndabmux -c config.yaml -o output.eti\n\n# Then transmit file\ncat output.eti | socat - UDP4-DATAGRAM:239.1.2.3:12000\n</code></pre></p> </li> </ol>"},{"location":"faq/#performance-questions","title":"Performance Questions","text":""},{"location":"faq/#how-much-cpu-does-python-dabmux-use","title":"How much CPU does python-dabmux use?","text":"<p>Typical usage: - Mode I: 10-20% of one CPU core at 10.4 frames/second - Multiple services: Scales linearly with number of services - PFT with FEC: +10-15% overhead</p> <p>Factors affecting performance: - Number of services - FIG types enabled - PFT and FEC - Input sources (network inputs have lower overhead than files)</p> <p>Optimization: - Use raw ETI format for output (smaller files) - Disable unnecessary FIG types - Use <code>-q</code> quiet mode (less logging overhead)</p>"},{"location":"faq/#can-python-dabmux-run-on-a-raspberry-pi","title":"Can python-dabmux run on a Raspberry Pi?","text":"<p>Yes! python-dabmux runs on Raspberry Pi 3 and later.</p> <p>Requirements: - Raspberry Pi 3 or newer (ARM processor) - Python 3.11+ - 512 MB RAM minimum - Recommended: Raspberry Pi 4 with 2+ GB RAM</p> <p>Performance: - RPi 3: 1-2 services comfortably - RPi 4: 4-6 services</p> <p>Tips: - Use Raspberry Pi OS Lite (no GUI) for lower overhead - Use file outputs or local network only (avoid Wi-Fi for streaming) - Use <code>-q</code> quiet mode to reduce logging</p>"},{"location":"faq/#how-much-bandwidth-does-edi-use","title":"How much bandwidth does EDI use?","text":"<p>Without PFT: - Approximately bitrate \u00d7 1.15 (15% overhead for headers) - Example: 6 services \u00d7 128 kbps = 768 kbps \u2192 ~880 kbps network traffic</p> <p>With PFT (no FEC): - Approximately bitrate \u00d7 1.25 (25% overhead) - Example: 768 kbps \u2192 ~960 kbps</p> <p>With PFT + FEC: - Depends on <code>--pft-fec-m</code> parameter - Add ~10-20% more for FEC redundancy - Example: 768 kbps \u2192 ~1100 kbps (with m=2)</p> <p>Calculate for your setup: <pre><code>Total bitrate = sum of all subchannel bitrates\nNetwork bandwidth = Total bitrate \u00d7 (1.15 to 1.35)\n</code></pre></p>"},{"location":"faq/#transmission-questions","title":"Transmission Questions","text":""},{"location":"faq/#whats-the-next-step-after-generating-eti","title":"What's the next step after generating ETI?","text":"<p>ETI is just the multiplex data. To broadcast, you need:</p> <ol> <li>Modulator: Converts ETI to RF signal</li> <li>Hardware: Professional DAB modulators</li> <li> <p>Software: ODR-DabMod (open source)</p> </li> <li> <p>Transmitter: Amplifies and transmits RF signal</p> </li> <li>RF power amplifier</li> <li>Antenna tuned for DAB frequencies</li> </ol> <p>Typical chain: <pre><code>python-dabmux \u2192 ETI \u2192 ODR-DabMod \u2192 RF \u2192 Transmitter \u2192 Antenna\n</code></pre></p> <p>For testing: - Use SDR (Software-Defined Radio) with ODR-DabMod - Desktop DAB radios can decode test transmissions</p>"},{"location":"faq/#what-dab-frequencies-can-i-use","title":"What DAB frequencies can I use?","text":"<p>Depends on your country and license!</p> <p>DAB Band III (most common): - 174-240 MHz - Channels 5A-13F - Used in Europe, Asia, Australia</p> <p>DAB L-Band: - 1452-1492 MHz - Used in some countries for local/mobile services</p> <p>Important: - Broadcasting requires a license in most countries - Unlicensed transmission is illegal and interferes with licensed services - For testing: Use very low power (&lt;1 mW) in a shielded environment - For production: Obtain proper broadcast license from your regulatory authority</p>"},{"location":"faq/#can-i-receive-python-dabmux-output-with-a-regular-dab-radio","title":"Can I receive python-dabmux output with a regular DAB radio?","text":"<p>Yes, but you need a modulator!</p> <ol> <li> <p>Generate ETI: <pre><code>dabmux -c config.yaml -o output.eti\n</code></pre></p> </li> <li> <p>Modulate with ODR-DabMod: <pre><code>odr-dabmod output.eti -o output.iq\n</code></pre></p> </li> <li> <p>Transmit with SDR:</p> </li> <li>HackRF, LimeSDR, USRP, etc.</li> <li> <p>Use very low power for testing</p> </li> <li> <p>Tune your DAB radio to the configured frequency</p> </li> </ol> <p>Warning: Only transmit in a shielded environment or with proper license.</p>"},{"location":"faq/#troubleshooting-questions","title":"Troubleshooting Questions","text":""},{"location":"faq/#why-am-i-getting-invalid-mpeg-frame-header","title":"Why am I getting \"Invalid MPEG frame header\"?","text":"<p>Common causes:</p> <ol> <li>Wrong file format:</li> <li>File is not MPEG Layer II</li> <li> <p>Use <code>file</code> and <code>ffprobe</code> to check format</p> </li> <li> <p>Corrupted file:</p> </li> <li>Re-encode the audio file</li> <li> <p>Check disk integrity</p> </li> <li> <p>Wrong subchannel type:</p> </li> <li>Type is <code>dabplus</code> but file is MPEG Layer II</li> <li> <p>Change type to <code>audio</code></p> </li> <li> <p>Network stream issues:</p> </li> <li>UDP packets arriving out of order</li> <li>Incomplete frames</li> <li>Try TCP instead of UDP</li> </ol> <p>Solution: <pre><code># Verify file format\nffprobe audio.mp2\n\n# Re-encode if needed\nffmpeg -i audio.mp2 -codec:a mp2 -b:a 128k audio_fixed.mp2\n</code></pre></p>"},{"location":"faq/#why-cant-python-dabmux-find-my-configuration-file","title":"Why can't python-dabmux find my configuration file?","text":"<p>Common causes:</p> <ol> <li> <p>Wrong path: <pre><code># Check current directory\npwd\nls -l config.yaml\n</code></pre></p> </li> <li> <p>Wrong filename: <pre><code># Maybe it's config.yml not config.yaml?\nls -l *.yaml *.yml\n</code></pre></p> </li> <li> <p>File in different directory: <pre><code># Use absolute path\ndabmux -c /full/path/to/config.yaml -o output.eti\n</code></pre></p> </li> </ol> <p>Solution: Use absolute paths for production: <pre><code>dabmux -c /etc/dabmux/config.yaml -o /var/dabmux/output.eti\n</code></pre></p>"},{"location":"faq/#how-do-i-debug-configuration-problems","title":"How do I debug configuration problems?","text":"<p>Enable maximum verbosity: <pre><code>dabmux -c config.yaml -o test.eti -n 1 -vvv\n</code></pre></p> <p>Check YAML syntax: - Use online YAML validators - Check indentation (spaces, not tabs) - Verify quotes around hex values</p> <p>Test with minimal config: <pre><code># Simplest possible config\nensemble:\n  id: '0xCE15'\n  label:\n    text: 'Test'\n\nsubchannels:\n  - uid: 'sub1'\n    id: 0\n    bitrate: 128\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'svc1'\n    id: '0x5001'\n    label:\n      text: 'Test'\n\ncomponents:\n  - service_id: '0x5001'\n    subchannel_id: 0\n</code></pre></p> <p>See: Troubleshooting Guide</p>"},{"location":"faq/#getting-help","title":"Getting Help","text":""},{"location":"faq/#where-can-i-get-more-help","title":"Where can I get more help?","text":"<ol> <li>Documentation:</li> <li>User Guide</li> <li>Tutorials</li> <li> <p>Troubleshooting</p> </li> <li> <p>GitHub:</p> </li> <li>Issues</li> <li> <p>Discussions</p> </li> <li> <p>Community:</p> </li> <li>OpenDigitalRadio community</li> <li>DAB forums and mailing lists</li> </ol>"},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>Contributions welcome!</p> <ol> <li>Report bugs: GitHub Issues</li> <li>Suggest features: GitHub Discussions</li> <li>Submit code: Pull Requests</li> <li>Improve documentation: This documentation is in the <code>docs/</code> directory</li> </ol> <p>See: Contributing Guide</p>"},{"location":"faq/#see-also","title":"See Also","text":"<ul> <li>Getting Started: Installation and first multiplex</li> <li>User Guide: Complete usage documentation</li> <li>Tutorials: Hands-on guides</li> <li>Troubleshooting: Problem solving</li> <li>Glossary: DAB terminology</li> </ul>"},{"location":"glossary/","title":"Glossary","text":"<p>DAB and multiplexing terminology.</p>"},{"location":"glossary/#a","title":"A","text":""},{"location":"glossary/#aac-advanced-audio-coding","title":"AAC (Advanced Audio Coding)","text":"<p>Audio compression codec used in DAB+. HE-AAC v2 (High-Efficiency AAC version 2) is the standard for DAB+, providing better quality at lower bitrates than MPEG Layer II.</p>"},{"location":"glossary/#af-packet-application-fragment-packet","title":"AF Packet (Application Fragment Packet)","text":"<p>Container format in EDI protocol that wraps TAG items with synchronization, sequence numbers, and CRC.</p>"},{"location":"glossary/#b","title":"B","text":""},{"location":"glossary/#bitrate","title":"Bitrate","text":"<p>Data rate of an audio or data stream, measured in kilobits per second (kbps). Common DAB bitrates: 32-192 kbps for MPEG Layer II, 32-96 kbps for DAB+.</p>"},{"location":"glossary/#c","title":"C","text":""},{"location":"glossary/#capacity-unit-cu","title":"Capacity Unit (CU)","text":"<p>The basic unit of multiplex capacity in DAB. Mode I has 864 CU total. Each subchannel occupies a number of CUs based on its bitrate and protection level.</p>"},{"location":"glossary/#component","title":"Component","text":"<p>Link between a service and a subchannel in the ensemble configuration. One service can have multiple components (e.g., audio + data).</p>"},{"location":"glossary/#crc-cyclic-redundancy-check","title":"CRC (Cyclic Redundancy Check)","text":"<p>Error detection code used throughout ETI frames and EDI packets to verify data integrity.</p>"},{"location":"glossary/#d","title":"D","text":""},{"location":"glossary/#dab-digital-audio-broadcasting","title":"DAB (Digital Audio Broadcasting)","text":"<p>Digital radio technology standard. Originally referred to the MPEG Layer II audio variant, now encompasses both DAB and DAB+.</p>"},{"location":"glossary/#dab","title":"DAB+","text":"<p>Enhanced version of DAB using HE-AAC v2 audio coding instead of MPEG Layer II. Provides better audio quality at lower bitrates.</p>"},{"location":"glossary/#dmb-digital-multimedia-broadcasting","title":"DMB (Digital Multimedia Broadcasting)","text":"<p>Data mode for transmitting multimedia content (images, text, video) over DAB.</p>"},{"location":"glossary/#e","title":"E","text":""},{"location":"glossary/#ebu-latin","title":"EBU Latin","text":"<p>Character encoding used for DAB labels and text. Subset of UTF-8 covering common European languages.</p>"},{"location":"glossary/#ecc-extended-country-code","title":"ECC (Extended Country Code)","text":"<p>8-bit code identifying the country (e.g., 0xE1 for Germany, 0xE2 for UK). Used in ensemble configuration.</p>"},{"location":"glossary/#edi-ensemble-data-interface","title":"EDI (Ensemble Data Interface)","text":"<p>Network protocol for transmitting ETI frames over UDP or TCP. Includes TAG items, AF packets, and optional PFT.</p>"},{"location":"glossary/#eep-equal-error-protection","title":"EEP (Equal Error Protection)","text":"<p>Protection scheme where all data in a subchannel has the same protection level. Alternative to UEP.</p>"},{"location":"glossary/#ensemble","title":"Ensemble","text":"<p>Complete DAB multiplex containing multiple services. Identified by ensemble ID and label.</p>"},{"location":"glossary/#eti-ensemble-transport-interface","title":"ETI (Ensemble Transport Interface)","text":"<p>Frame format for DAB multiplex data. Contains headers, FIC data, main service channel data, and checksums. Standard frame size: 6144 bytes (Mode I).</p>"},{"location":"glossary/#f","title":"F","text":""},{"location":"glossary/#fc-frame-characterization","title":"FC (Frame Characterization)","text":"<p>4-byte header in ETI frame containing frame count, number of subchannels, transmission mode, and frame length.</p>"},{"location":"glossary/#fec-forward-error-correction","title":"FEC (Forward Error Correction)","text":"<p>Error correction technique used in PFT to recover lost packets. python-dabmux uses Reed-Solomon codes.</p>"},{"location":"glossary/#fic-fast-information-channel","title":"FIC (Fast Information Channel)","text":"<p>Data channel in ETI frame containing service information (FIGs). Size: 96 bytes for Mode I, 32 bytes for other modes.</p>"},{"location":"glossary/#fig-fast-information-group","title":"FIG (Fast Information Group)","text":"<p>Information block in FIC carrying service details, labels, and configuration. Different FIG types (0-7) carry different information.</p>"},{"location":"glossary/#fig-00","title":"FIG 0/0","text":"<p>MCI (Multiplex Configuration Information) - Ensemble configuration.</p>"},{"location":"glossary/#fig-01","title":"FIG 0/1","text":"<p>Subchannel organization - How subchannels are arranged in the multiplex.</p>"},{"location":"glossary/#fig-02","title":"FIG 0/2","text":"<p>Service organization - Which components belong to which services.</p>"},{"location":"glossary/#fig-10","title":"FIG 1/0","text":"<p>Ensemble label - Text label for the ensemble.</p>"},{"location":"glossary/#fig-11","title":"FIG 1/1","text":"<p>Service labels - Text labels for services.</p>"},{"location":"glossary/#frame","title":"Frame","text":"<p>Single time unit of DAB transmission. Mode I: 96ms, Mode II/III: 24ms, Mode IV: 96ms.</p>"},{"location":"glossary/#h","title":"H","text":""},{"location":"glossary/#he-aac-v2-high-efficiency-advanced-audio-coding-version-2","title":"HE-AAC v2 (High-Efficiency Advanced Audio Coding version 2)","text":"<p>Audio codec used in DAB+. Includes Spectral Band Replication (SBR) and Parametric Stereo (PS) for efficient low-bitrate encoding.</p>"},{"location":"glossary/#l","title":"L","text":""},{"location":"glossary/#label","title":"Label","text":"<p>Text identifier for ensemble, service, or subchannel. Two forms: long (max 16 characters) and short (max 8 characters).</p>"},{"location":"glossary/#lto-local-time-offset","title":"LTO (Local Time Offset)","text":"<p>Time offset from UTC for the ensemble. Can be set manually or automatically.</p>"},{"location":"glossary/#m","title":"M","text":""},{"location":"glossary/#main-service-channel-msc-or-mst","title":"Main Service Channel (MSC or MST)","text":"<p>Data area in ETI frame containing audio/data streams from all subchannels.</p>"},{"location":"glossary/#mci-multiplex-configuration-information","title":"MCI (Multiplex Configuration Information)","text":"<p>Information about ensemble configuration, transmitted via FIG 0/0.</p>"},{"location":"glossary/#mode-i-ii-iii-iv","title":"Mode I, II, III, IV","text":"<p>DAB transmission modes with different frame durations, FIC sizes, and capacities: - Mode I: 96ms, 96-byte FIC, 864 CU (most common) - Mode II: 24ms, 32-byte FIC, 432 CU - Mode III: 24ms, 32-byte FIC, 864 CU - Mode IV: 96ms, 32-byte FIC, 432 CU</p>"},{"location":"glossary/#mpeg-layer-ii-mpeg-1-audio-layer-ii","title":"MPEG Layer II (MPEG-1 Audio Layer II)","text":"<p>Audio codec used in traditional DAB. Part of the MPEG-1 standard. File extension: .mp2</p>"},{"location":"glossary/#mst-main-stream-data","title":"MST (Main Stream Data)","text":"<p>See Main Service Channel.</p>"},{"location":"glossary/#mtu-maximum-transmission-unit","title":"MTU (Maximum Transmission Unit)","text":"<p>Maximum packet size for network transmission. Typically 1500 bytes for Ethernet. PFT fragments larger packets to fit MTU.</p>"},{"location":"glossary/#multiplexer-mux","title":"Multiplexer (Mux)","text":"<p>System that combines multiple audio/data streams into a single DAB ensemble (ETI frames).</p>"},{"location":"glossary/#p","title":"P","text":""},{"location":"glossary/#packet-mode","title":"Packet Mode","text":"<p>Data transmission mode in DAB for packet-based data services.</p>"},{"location":"glossary/#pft-protection-fragmentation-and-transport","title":"PFT (Protection, Fragmentation and Transport)","text":"<p>EDI layer providing packet fragmentation, sequence numbers, and optional FEC (Reed-Solomon).</p>"},{"location":"glossary/#programme-type-pty","title":"Programme Type (PTY)","text":"<p>Classification of service content (0-31). Examples: 1=News, 10=Pop Music, 14=Classical.</p>"},{"location":"glossary/#protection-level","title":"Protection Level","text":"<p>Error protection strength for a subchannel (0-4). Higher levels = more robust against errors but higher overhead. Level 2 is typical.</p>"},{"location":"glossary/#r","title":"R","text":""},{"location":"glossary/#reed-solomon","title":"Reed-Solomon","text":"<p>Error correction code used in PFT FEC. Can recover lost packets based on redundancy.</p>"},{"location":"glossary/#s","title":"S","text":""},{"location":"glossary/#service","title":"Service","text":"<p>Radio station or data service in the ensemble. Has a unique service ID, label, programme type, and language. Listeners tune to services.</p>"},{"location":"glossary/#service-id-sid","title":"Service ID (SId)","text":"<p>16-bit identifier for a service (e.g., 0x5001). Must be unique within ensemble.</p>"},{"location":"glossary/#sfn-single-frequency-network","title":"SFN (Single Frequency Network)","text":"<p>Multiple transmitters broadcasting the same signal on the same frequency. Requires precise timing (TIST).</p>"},{"location":"glossary/#subchannel","title":"Subchannel","text":"<p>Data stream in the multiplex carrying audio or data. Characterized by bitrate, protection level, and start address in CUs.</p>"},{"location":"glossary/#subchannel-id-subchid","title":"Subchannel ID (SubChId)","text":"<p>6-bit identifier (0-63) for a subchannel within the ensemble.</p>"},{"location":"glossary/#sync","title":"SYNC","text":"<p>4-byte header at start of ETI frame containing error indicator and frame sync word (0x49C5F8).</p>"},{"location":"glossary/#t","title":"T","text":""},{"location":"glossary/#tag-item","title":"TAG Item","text":"<p>Data element in EDI protocol. Types include *ptr (protocol), deti (ETI data), estN (timestamp).</p>"},{"location":"glossary/#tist-timestamp","title":"TIST (Timestamp)","text":"<p>Optional 4-byte timestamp in ETI frame. Used for precise timing in SFN networks. Based on 16.384 MHz clock.</p>"},{"location":"glossary/#transmission-mode","title":"Transmission Mode","text":"<p>See Mode I, II, III, IV.</p>"},{"location":"glossary/#u","title":"U","text":""},{"location":"glossary/#udp-user-datagram-protocol","title":"UDP (User Datagram Protocol)","text":"<p>Network protocol used for EDI streaming. Connectionless, suitable for multicast.</p>"},{"location":"glossary/#uep-unequal-error-protection","title":"UEP (Unequal Error Protection)","text":"<p>Protection scheme where different parts of subchannel data have different protection levels. More efficient than EEP for MPEG Layer II.</p>"},{"location":"glossary/#abbreviations","title":"Abbreviations","text":"Abbreviation Full Term AAC Advanced Audio Coding AF Application Fragment CRC Cyclic Redundancy Check CU Capacity Unit DAB Digital Audio Broadcasting DMB Digital Multimedia Broadcasting EBU European Broadcasting Union ECC Extended Country Code EDI Ensemble Data Interface EEP Equal Error Protection ETI Ensemble Transport Interface FC Frame Characterization FEC Forward Error Correction FIC Fast Information Channel FIG Fast Information Group HE-AAC High-Efficiency Advanced Audio Coding LTO Local Time Offset MCI Multiplex Configuration Information MSC Main Service Channel MST Main Stream Data MPEG Moving Picture Experts Group MTU Maximum Transmission Unit PFT Protection, Fragmentation and Transport PTY Programme Type SFN Single Frequency Network SId Service Identifier SubChId Subchannel Identifier TCP Transmission Control Protocol TIST Timestamp UDP User Datagram Protocol UEP Unequal Error Protection"},{"location":"glossary/#numeric-values","title":"Numeric Values","text":""},{"location":"glossary/#programme-types-pty","title":"Programme Types (PTY)","text":"Value Type Description 0 None No programme type 1 News News 2 Current Affairs Current affairs 3 Information General information 4 Sport Sports 5 Education Educational 6 Drama Drama 7 Culture Arts and culture 8 Science Science 9 Varied Speech Talk/varied speech 10 Pop Music Pop music 11 Rock Music Rock music 12 Easy Listening Easy listening music 13 Light Classical Light classical 14 Serious Classical Serious classical 15 Other Music Other music 16 Weather Weather 17 Finance Finance/business 18 Children's Children's programmes 19 Social Affairs Social affairs 20 Religion Religion 21 Phone In Phone-in 22 Travel Travel 23 Leisure Leisure 24 Jazz Music Jazz 25 Country Music Country 26 National Music National music 27 Oldies Music Oldies 28 Folk Music Folk 29 Documentary Documentary 30-31 - Reserved"},{"location":"glossary/#language-codes-selection","title":"Language Codes (Selection)","text":"Value Language 0 Unknown 1 Albanian 2 Breton 3 Catalan 4 Croatian 5 Welsh 6 Czech 7 Danish 8 German 9 English 10 Spanish 11 Esperanto 12 Estonian 13 Basque 14 Faroese 15 French 16 Frisian 17 Irish 18 Gaelic 19 Galician 20 Icelandic 21 Italian 22 Lappish 23 Latin 24 Latvian 25 Luxembourgian 26 Lithuanian 27 Hungarian 28 Maltese 29 Dutch 30 Norwegian 31 Occitan 32 Polish 33 Portuguese 34 Romanian 35 Romansh 36 Serbian 37 Slovak 38 Slovene 39 Finnish 40 Swedish 41 Turkish 42 Flemish 43 Walloon <p>[See full list in ETSI EN 300 401]</p>"},{"location":"glossary/#extended-country-codes-ecc","title":"Extended Country Codes (ECC)","text":"Code Country/Region 0xE0 Germany 0xE1 Algeria, Andorra, Belgium, etc. 0xE2 United Kingdom 0xE3 Czech Republic, Estonia, Greece, etc. 0xE4 Denmark, Gibraltar, etc. 0xF0 France 0xF1 Egypt, Syria, etc. <p>[See full list in ETSI EN 300 401]</p>"},{"location":"glossary/#protection-levels","title":"Protection Levels","text":"Level Description Use Case 0 Weakest Very strong signal only 1 Weak Good signal required 2 Moderate Standard (recommended) 3 Strong Weak signal areas 4 Strongest Maximum robustness"},{"location":"glossary/#common-bitrates","title":"Common Bitrates","text":""},{"location":"glossary/#dab-mpeg-layer-ii","title":"DAB (MPEG Layer II)","text":"Bitrate Quality Use Case 32 kbps Low Mono speech (minimal) 64 kbps Fair Mono speech 96 kbps Good Stereo speech, low music 128 kbps Very Good Standard music quality 160 kbps Excellent High-quality music 192 kbps Premium Premium music quality"},{"location":"glossary/#dab-he-aac-v2","title":"DAB+ (HE-AAC v2)","text":"Bitrate Quality Equivalent DAB 32 kbps Good ~64 kbps speech 48 kbps Very Good ~96 kbps speech 64 kbps Excellent ~128 kbps music 72 kbps Excellent ~128-160 kbps music 96 kbps Premium ~192 kbps music"},{"location":"glossary/#frame-sizes-and-timing","title":"Frame Sizes and Timing","text":""},{"location":"glossary/#mode-i-most-common","title":"Mode I (Most Common)","text":"<ul> <li>Frame duration: 96 ms</li> <li>Frame rate: 10.416\u0304 frames/second</li> <li>FIC size: 96 bytes</li> <li>Total capacity: 864 CU</li> <li>ETI frame size: 6144 bytes (6148 with TIST)</li> </ul>"},{"location":"glossary/#mode-ii","title":"Mode II","text":"<ul> <li>Frame duration: 24 ms</li> <li>Frame rate: 41.6\u0304 frames/second</li> <li>FIC size: 32 bytes</li> <li>Total capacity: 432 CU</li> </ul>"},{"location":"glossary/#mode-iii","title":"Mode III","text":"<ul> <li>Frame duration: 24 ms</li> <li>Frame rate: 41.6\u0304 frames/second</li> <li>FIC size: 32 bytes</li> <li>Total capacity: 864 CU</li> </ul>"},{"location":"glossary/#mode-iv","title":"Mode IV","text":"<ul> <li>Frame duration: 96 ms</li> <li>Frame rate: 10.416\u0304 frames/second</li> <li>FIC size: 32 bytes</li> <li>Total capacity: 432 CU</li> </ul>"},{"location":"glossary/#see-also","title":"See Also","text":"<ul> <li>ETSI EN 300 401 - DAB standard</li> <li>ETSI EN 300 799 - ETI specification</li> <li>FAQ - Frequently asked questions</li> <li>Standards - Standards compliance</li> </ul>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>In-depth technical documentation for advanced users and developers.</p>"},{"location":"advanced/#overview","title":"Overview","text":"<p>This section covers advanced DAB multiplexing concepts, low-level implementation details, and extension mechanisms for python-dabmux.</p>"},{"location":"advanced/#topics","title":"Topics","text":""},{"location":"advanced/#fig-types","title":"FIG Types","text":"<p>Complete reference for all Fast Information Group (FIG) types used in DAB. Covers FIG 0 (MCI), FIG 1 (Labels), FIG 2 (Dynamic labels), FIG 5 (FIDC), and more.</p> <p>You should read this if: - You want to understand DAB service information - You're implementing custom FIG generation - You need to debug FIC data</p>"},{"location":"advanced/#character-encoding","title":"Character Encoding","text":"<p>EBU Latin character set and UTF-8 conversion for DAB labels and text.</p> <p>You should read this if: - You're using non-ASCII characters in labels - You need to understand label encoding - You're implementing international services</p>"},{"location":"advanced/#timestamps-synchronization","title":"Timestamps &amp; Synchronization","text":"<p>TIST (Timestamp) implementation for Single Frequency Networks (SFN) and synchronized transmission.</p> <p>You should read this if: - You're building an SFN network - You need precise frame timing - You're synchronizing multiple transmitters</p>"},{"location":"advanced/#reed-solomon-fec","title":"Reed-Solomon FEC","text":"<p>Forward Error Correction using Reed-Solomon codes in PFT protocol.</p> <p>You should read this if: - You're using PFT with FEC - You want to understand packet recovery - You're optimizing network transmission</p>"},{"location":"advanced/#transmission-modes","title":"Transmission Modes","text":"<p>Detailed comparison of DAB transmission modes (I, II, III, IV) with frame structures, timing, and capacity calculations.</p> <p>You should read this if: - You're choosing a transmission mode - You need to understand mode differences - You're calculating ensemble capacity</p>"},{"location":"advanced/#extending-python-dabmux","title":"Extending python-dabmux","text":"<p>Creating custom inputs, outputs, and FIG generators. Plugin architecture and extension points.</p> <p>You should read this if: - You're building custom input sources - You want to add new output formats - You're implementing custom FIG types</p>"},{"location":"advanced/#prerequisites","title":"Prerequisites","text":"<p>These topics assume you're familiar with: - Basic DAB concepts (Getting Started) - ETI frame structure (Architecture) - Configuration and operation (User Guide)</p>"},{"location":"advanced/#when-to-read-advanced-topics","title":"When to Read Advanced Topics","text":"<p>Read these topics if you: - Need deep technical understanding - Are extending python-dabmux - Are debugging low-level issues - Are implementing specialized features</p> <p>Skip these topics if you: - Just want to run the multiplexer (see Quick Setup) - Need configuration help (see User Guide) - Are learning DAB basics (see Basic Concepts)</p>"},{"location":"advanced/#related-resources","title":"Related Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Architecture - System design and diagrams</li> <li>Standards - ETSI specifications and compliance</li> <li>Development - Contributing to python-dabmux</li> </ul>"},{"location":"advanced/#external-references","title":"External References","text":"<ul> <li>ETSI EN 300 401 - DAB standard</li> <li>ETSI EN 300 799 - ETI specification</li> <li>ETSI TS 102 563 - DAB+ specification</li> <li>ODR-DabMux Documentation - Reference implementation</li> </ul>"},{"location":"advanced/character-encoding/","title":"Character Encoding","text":"<p>EBU Latin character set and UTF-8 conversion for DAB labels.</p>"},{"location":"advanced/character-encoding/#overview","title":"Overview","text":"<p>DAB uses the EBU Latin character set for all text labels (ensemble names, service names, etc.). This is a subset of UTF-8 designed for European languages.</p>"},{"location":"advanced/character-encoding/#ebu-latin-character-set","title":"EBU Latin Character Set","text":""},{"location":"advanced/character-encoding/#supported-characters","title":"Supported Characters","text":"<p>Basic Latin (compatible with ASCII): - A-Z, a-z (uppercase and lowercase letters) - 0-9 (digits) - Space and common punctuation: <code>. , ; : ! ? ' \" - ( ) /</code> - Math symbols: <code>+ = # @ &amp; *</code></p> <p>Extended Latin (accented characters): - German: <code>\u00e4 \u00f6 \u00fc \u00df \u00c4 \u00d6 \u00dc</code> - French: <code>\u00e9 \u00e8 \u00ea \u00eb \u00e0 \u00e2 \u00e7 \u00f9 \u00fb \u00ef \u00f4 \u00c9 \u00c8 \u00ca \u00c0 \u00c7</code> - Spanish: <code>\u00e1 \u00e9 \u00ed \u00f3 \u00fa \u00f1 \u00c1 \u00c9 \u00cd \u00d3 \u00da \u00d1</code> - Italian: <code>\u00e0 \u00e8 \u00ec \u00f2 \u00f9 \u00c0 \u00c8 \u00cc \u00d2 \u00d9</code> - Portuguese: <code>\u00e3 \u00f5 \u00e7 \u00c3 \u00d5 \u00c7</code> - Nordic: <code>\u00e5 \u00e6 \u00f8 \u00c5 \u00c6 \u00d8</code> - And more...</p>"},{"location":"advanced/character-encoding/#character-limits","title":"Character Limits","text":"Type Long Label Short Label Length 16 characters 8 characters Encoding EBU Latin EBU Latin Bytes 16 bytes 8 bytes <p>Note: Most EBU Latin characters are single-byte (same as ASCII). Special characters may use multi-byte encoding.</p>"},{"location":"advanced/character-encoding/#python-api","title":"Python API","text":""},{"location":"advanced/character-encoding/#module-dabmuxutilscharset","title":"Module: <code>dabmux.utils.charset</code>","text":"<pre><code>from dabmux.utils.charset import utf8_to_ebu, ebu_to_utf8\n\n# Convert UTF-8 string to EBU Latin bytes\nebu_bytes = utf8_to_ebu(\"R\u00e1dio M\u00fasica\")\n\n# Convert EBU Latin bytes back to UTF-8 string\nutf8_string = ebu_to_utf8(ebu_bytes)\n</code></pre>"},{"location":"advanced/character-encoding/#functions","title":"Functions","text":""},{"location":"advanced/character-encoding/#utf8_to_ebutext-str-bytes","title":"<code>utf8_to_ebu(text: str) -&gt; bytes</code>","text":"<p>Convert UTF-8 string to EBU Latin bytes.</p> <p>Parameters: - <code>text: str</code> - UTF-8 string (max 16 characters for labels)</p> <p>Returns: EBU Latin encoded bytes</p> <p>Raises: - <code>ValueError</code> - If string contains unsupported characters - <code>ValueError</code> - If string is too long</p> <p>Example: <pre><code>from dabmux.utils.charset import utf8_to_ebu\n\n# Basic ASCII (no conversion needed)\nlabel = utf8_to_ebu(\"Radio One\")\nassert len(label) == 9  # 9 bytes\n\n# German umlauts\nlabel = utf8_to_ebu(\"S\u00fcddeutsch FM\")\nassert len(label) == 14  # \u00fc is encoded\n\n# French accents\nlabel = utf8_to_ebu(\"Musique Caf\u00e9\")\nassert len(label) == 12\n</code></pre></p>"},{"location":"advanced/character-encoding/#ebu_to_utf8data-bytes-str","title":"<code>ebu_to_utf8(data: bytes) -&gt; str</code>","text":"<p>Convert EBU Latin bytes to UTF-8 string.</p> <p>Parameters: - <code>data: bytes</code> - EBU Latin encoded bytes</p> <p>Returns: UTF-8 string</p> <p>Example: <pre><code>from dabmux.utils.charset import ebu_to_utf8\n\nebu_bytes = b'Radio One'\ntext = ebu_to_utf8(ebu_bytes)\nassert text == \"Radio One\"\n</code></pre></p>"},{"location":"advanced/character-encoding/#label-configuration","title":"Label Configuration","text":""},{"location":"advanced/character-encoding/#yaml-configuration","title":"YAML Configuration","text":"<p>Labels are specified as UTF-8 strings in configuration files. python-dabmux automatically converts them to EBU Latin.</p> <pre><code>ensemble:\n  label:\n    text: 'My DAB Ensemble'  # UTF-8, auto-converted to EBU\n    short: 'MyDAB'\n\nservices:\n  - uid: 'service1'\n    label:\n      text: 'R\u00e1dio M\u00fasica'     # Portuguese characters\n      short: 'M\u00fasica'\n\n  - uid: 'service2'\n    label:\n      text: 'S\u00fcddeutsch FM'    # German umlauts\n      short: 'S\u00fcdFM'\n</code></pre>"},{"location":"advanced/character-encoding/#python-api_1","title":"Python API","text":"<pre><code>from dabmux.core.mux_elements import DabLabel, DabService\n\n# Create label with non-ASCII characters\nlabel = DabLabel(\n    text='Fran\u00e7ais Radio',  # UTF-8 string\n    short='FrRadio'\n)\n\n# Create service\nservice = DabService(\n    uid='french',\n    id=0x5001,\n    label_text='Fran\u00e7ais Radio',\n    label_short='FrRadio'\n)\n</code></pre>"},{"location":"advanced/character-encoding/#supported-languages","title":"Supported Languages","text":""},{"location":"advanced/character-encoding/#germanic-languages","title":"Germanic Languages","text":"<p>German: <pre><code>label:\n  text: 'S\u00fcddeutsche'  # \u00fc supported\n  short: 'S\u00fcd'\n</code></pre></p> <p>Dutch: <pre><code>label:\n  text: 'Nederlandse'  # No special chars needed\n</code></pre></p> <p>Swedish/Norwegian: <pre><code>label:\n  text: 'G\u00f6teborg'  # \u00f6 supported\n  short: 'G\u00f6teborg'\n</code></pre></p> <p>Danish: <pre><code>label:\n  text: 'K\u00f8benhavn'  # \u00f8 supported\n</code></pre></p>"},{"location":"advanced/character-encoding/#romance-languages","title":"Romance Languages","text":"<p>French: <pre><code>label:\n  text: 'Fran\u00e7ais Musique'  # \u00e7, \u00e9 supported\n  short: 'FrMus'\n</code></pre></p> <p>Spanish: <pre><code>label:\n  text: 'Espa\u00f1ol Radio'  # \u00f1, \u00e1 supported\n  short: 'EspRadio'\n</code></pre></p> <p>Italian: <pre><code>label:\n  text: 'Italiano'  # \u00e0, \u00e8, \u00ec, \u00f2, \u00f9 supported\n</code></pre></p> <p>Portuguese: <pre><code>label:\n  text: 'Portugu\u00eas'  # \u00e3, \u00f5, \u00e7 supported\n</code></pre></p>"},{"location":"advanced/character-encoding/#other-european-languages","title":"Other European Languages","text":"<p>Polish: <pre><code>label:\n  text: 'Polskie Radio'  # \u0142, \u0105, \u0119, \u00f3, \u015b, \u017c, \u017a supported\n</code></pre></p> <p>Czech: <pre><code>label:\n  text: '\u010cesk\u00e9 R\u00e1dio'  # \u010d, \u0161, \u017e, \u0159, \u00fd, \u00e1, \u00e9 supported\n</code></pre></p>"},{"location":"advanced/character-encoding/#unsupported-characters","title":"Unsupported Characters","text":""},{"location":"advanced/character-encoding/#non-european-scripts","title":"Non-European Scripts","text":"<p>\u274c Not supported: - Cyrillic (Russian, Bulgarian, Ukrainian) - Greek - Arabic - Hebrew - Asian scripts (Chinese, Japanese, Korean) - Emoji</p> <p>Workaround: Use ASCII transliteration: <pre><code># Instead of \"\u0420\u0443\u0441\u0441\u043a\u043e\u0435 \u0440\u0430\u0434\u0438\u043e\" (Cyrillic)\nlabel:\n  text: 'Russkoye Radio'  # ASCII transliteration\n</code></pre></p>"},{"location":"advanced/character-encoding/#special-symbols","title":"Special Symbols","text":"<p>\u274c Limited support: - Most mathematical symbols - Currency symbols (except basic ones) - Box-drawing characters - Control characters</p>"},{"location":"advanced/character-encoding/#character-length-considerations","title":"Character Length Considerations","text":""},{"location":"advanced/character-encoding/#counting-characters","title":"Counting Characters","text":"<pre><code>def count_label_length(text: str) -&gt; int:\n    \"\"\"Count EBU Latin length of label.\"\"\"\n    from dabmux.utils.charset import utf8_to_ebu\n    return len(utf8_to_ebu(text))\n\n# Examples\nassert count_label_length(\"Radio\") == 5\nassert count_label_length(\"R\u00e1dio\") == 5  # \u00e1 is 1 byte in EBU\nassert count_label_length(\"S\u00fcd\") == 3    # \u00fc is 1 byte in EBU\n</code></pre>"},{"location":"advanced/character-encoding/#truncation","title":"Truncation","text":"<p>If label is too long, truncate before conversion:</p> <pre><code>def truncate_label(text: str, max_len: int = 16) -&gt; str:\n    \"\"\"Truncate label to max length.\"\"\"\n    from dabmux.utils.charset import utf8_to_ebu\n\n    # Truncate character by character until it fits\n    while len(utf8_to_ebu(text)) &gt; max_len:\n        text = text[:-1]\n\n    return text\n\n# Example\nlong_label = \"This is a very long radio station name\"\nshort = truncate_label(long_label, max_len=16)\n# Result: \"This is a very\"\n</code></pre>"},{"location":"advanced/character-encoding/#dynamic-text-dls","title":"Dynamic Text (DLS)","text":"<p>Note: Dynamic Label Segment (DLS) for scrolling text on DAB+ uses a different character encoding (UTF-8 directly). This is separate from static labels.</p>"},{"location":"advanced/character-encoding/#validation","title":"Validation","text":""},{"location":"advanced/character-encoding/#check-label-validity","title":"Check Label Validity","text":"<pre><code>from dabmux.utils.charset import is_valid_ebu_label\n\ndef validate_label(text: str, max_len: int = 16) -&gt; bool:\n    \"\"\"Check if label is valid for DAB.\"\"\"\n    if len(text) &gt; max_len:\n        return False\n\n    try:\n        from dabmux.utils.charset import utf8_to_ebu\n        ebu_bytes = utf8_to_ebu(text)\n        return len(ebu_bytes) &lt;= max_len\n    except ValueError:\n        return False\n\n# Examples\nassert validate_label(\"Radio One\") == True\nassert validate_label(\"R\u00e1dio M\u00fasica\") == True\nassert validate_label(\"This is way too long for a label\") == False\nassert validate_label(\"\u0420\u0443\u0441\u0441\u043a\u043e\u0435 \u0440\u0430\u0434\u0438\u043e\") == False  # Cyrillic not supported\n</code></pre>"},{"location":"advanced/character-encoding/#configuration-validation","title":"Configuration Validation","text":"<p>python-dabmux automatically validates labels during configuration loading:</p> <pre><code>from dabmux.config import load_config, ConfigurationError\n\ntry:\n    ensemble = load_config('config.yaml')\nexcept ConfigurationError as e:\n    print(f\"Invalid label: {e}\")\n    # Example error: \"Label '\u0420\u0443\u0441\u0441\u043a\u043e\u0435 \u0440\u0430\u0434\u0438\u043e' contains unsupported characters\"\n</code></pre>"},{"location":"advanced/character-encoding/#best-practices","title":"Best Practices","text":"<ol> <li>Use ASCII when possible for maximum compatibility</li> <li>Test labels with actual DAB receivers</li> <li>Avoid ambiguous characters (e.g., <code>0</code> vs <code>O</code>, <code>1</code> vs <code>l</code>)</li> <li>Keep short labels meaningful (8 characters is very short)</li> <li>Use standard abbreviations for short labels (e.g., \"FM\", \"News\", \"Rock\")</li> </ol>"},{"location":"advanced/character-encoding/#good-label-examples","title":"Good Label Examples","text":"<pre><code># Clear, readable, fits in 16 chars\nservices:\n  - label:\n      text: 'BBC Radio 1'\n      short: 'Radio 1'\n\n  - label:\n      text: 'Classic FM'\n      short: 'Classic'\n\n  - label:\n      text: 'News 24/7'\n      short: 'News 24'\n</code></pre>"},{"location":"advanced/character-encoding/#poor-label-examples","title":"Poor Label Examples","text":"<pre><code># Too long (will be truncated)\nservices:\n  - label:\n      text: 'This Is The Best Radio Station Ever'  # &gt; 16 chars\n\n  # Ambiguous characters\n  - label:\n      text: 'l0O1Il'  # Hard to read\n\n  # Unsupported characters\n  - label:\n      text: '\ud83c\udfb5 Music \ud83c\udfb5'  # Emoji not supported\n</code></pre>"},{"location":"advanced/character-encoding/#character-reference-table","title":"Character Reference Table","text":"<p>Common accented characters in EBU Latin:</p> Char Name Used In <code>\u00e0</code> a grave French, Italian, Portuguese <code>\u00e1</code> a acute Spanish, Portuguese, Czech <code>\u00e2</code> a circumflex French, Portuguese <code>\u00e4</code> a umlaut German, Swedish <code>\u00e3</code> a tilde Portuguese <code>\u00e7</code> c cedilla French, Portuguese <code>\u00e9</code> e acute French, Spanish, Portuguese <code>\u00e8</code> e grave French, Italian <code>\u00ea</code> e circumflex French, Portuguese <code>\u00eb</code> e umlaut French <code>\u00ed</code> i acute Spanish, Portuguese <code>\u00f1</code> n tilde Spanish <code>\u00f6</code> o umlaut German, Swedish <code>\u00f8</code> o slash Norwegian, Danish <code>\u00fc</code> u umlaut German <code>\u00e5</code> a ring Swedish, Norwegian, Danish <code>\u00e6</code> ae ligature Danish, Norwegian"},{"location":"advanced/character-encoding/#see-also","title":"See Also","text":"<ul> <li>Configuration: Labels - Label configuration guide</li> <li>Standards: ETSI EN 300 401 - Character set specification</li> <li>API: DabLabel - Label class API</li> </ul>"},{"location":"advanced/extending/","title":"Extending python-dabmux","text":"<p>Guide to extending python-dabmux with custom inputs, outputs, and FIG generators.</p>"},{"location":"advanced/extending/#overview","title":"Overview","text":"<p>python-dabmux is designed to be extensible. You can add: - Custom input sources - Custom output destinations - Custom FIG generators - Custom audio parsers</p>"},{"location":"advanced/extending/#custom-input-sources","title":"Custom Input Sources","text":"<p>Create custom inputs by subclassing <code>InputBase</code>.</p>"},{"location":"advanced/extending/#basic-template","title":"Basic Template","text":"<pre><code>from dabmux.input.base import InputBase\nfrom typing import Optional\n\nclass CustomInput(InputBase):\n    \"\"\"Custom input source implementation.\"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"Initialize with configuration.\"\"\"\n        self.config = config\n        self.buffer = bytearray()\n        self.connected = False\n\n    def open(self) -&gt; None:\n        \"\"\"Open/initialize the input source.\"\"\"\n        # Setup connection, open files, etc.\n        self.connected = True\n        print(\"Custom input opened\")\n\n    def close(self) -&gt; None:\n        \"\"\"Close/cleanup the input source.\"\"\"\n        # Cleanup resources\n        self.connected = False\n        print(\"Custom input closed\")\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        \"\"\"\n        Read one audio/data frame.\n\n        Args:\n            frame_size: Number of bytes to read\n\n        Returns:\n            Frame data, or None if no data available\n        \"\"\"\n        if not self.connected:\n            return None\n\n        # Ensure buffer has enough data\n        while len(self.buffer) &lt; frame_size:\n            chunk = self._receive_data()\n            if not chunk:\n                return None\n            self.buffer.extend(chunk)\n\n        # Extract frame from buffer\n        frame = bytes(self.buffer[:frame_size])\n        self.buffer = self.buffer[frame_size:]\n        return frame\n\n    def seek(self, position: int) -&gt; None:\n        \"\"\"\n        Seek to position (optional, can raise NotImplementedError).\n        \"\"\"\n        raise NotImplementedError(\"Seeking not supported\")\n\n    def _receive_data(self) -&gt; Optional[bytes]:\n        \"\"\"Receive data chunk (implement your protocol here).\"\"\"\n        # Implement your data reception logic\n        pass\n</code></pre>"},{"location":"advanced/extending/#example-http-streaming-input","title":"Example: HTTP Streaming Input","text":"<pre><code>import requests\nfrom dabmux.input.base import InputBase\nfrom typing import Optional\n\nclass HttpStreamInput(InputBase):\n    \"\"\"Stream audio from HTTP URL.\"\"\"\n\n    def __init__(self, url: str, chunk_size: int = 8192):\n        self.url = url\n        self.chunk_size = chunk_size\n        self.response = None\n        self.iterator = None\n\n    def open(self) -&gt; None:\n        \"\"\"Start HTTP streaming.\"\"\"\n        self.response = requests.get(self.url, stream=True)\n        self.response.raise_for_status()\n        self.iterator = self.response.iter_content(chunk_size=self.chunk_size)\n\n    def close(self) -&gt; None:\n        \"\"\"Close HTTP connection.\"\"\"\n        if self.response:\n            self.response.close()\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        \"\"\"Read frame from stream.\"\"\"\n        try:\n            chunk = next(self.iterator)\n            return chunk[:frame_size] if len(chunk) &gt;= frame_size else chunk\n        except StopIteration:\n            return None\n\n    def seek(self, position: int) -&gt; None:\n        \"\"\"Not supported for HTTP streams.\"\"\"\n        raise NotImplementedError(\"Cannot seek in HTTP stream\")\n</code></pre> <p>Usage: <pre><code>from dabmux.mux import DabMultiplexer\n\n# Create custom input\nhttp_input = HttpStreamInput('https://stream.example.com/audio.mp2')\nhttp_input.open()\n\n# Register with multiplexer\nmux.add_input('subchannel1', http_input)\n</code></pre></p>"},{"location":"advanced/extending/#example-pipe-input","title":"Example: Pipe Input","text":"<pre><code>import subprocess\nfrom dabmux.input.base import InputBase\nfrom typing import Optional\n\nclass PipeInput(InputBase):\n    \"\"\"Read audio from pipe (e.g., ffmpeg output).\"\"\"\n\n    def __init__(self, command: list[str]):\n        \"\"\"\n        Initialize pipe input.\n\n        Args:\n            command: Command to execute (e.g., ['ffmpeg', '-i', ...])\n        \"\"\"\n        self.command = command\n        self.process = None\n\n    def open(self) -&gt; None:\n        \"\"\"Start subprocess.\"\"\"\n        self.process = subprocess.Popen(\n            self.command,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL\n        )\n\n    def close(self) -&gt; None:\n        \"\"\"Terminate subprocess.\"\"\"\n        if self.process:\n            self.process.terminate()\n            self.process.wait()\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        \"\"\"Read frame from pipe.\"\"\"\n        if not self.process or not self.process.stdout:\n            return None\n\n        data = self.process.stdout.read(frame_size)\n        return data if len(data) == frame_size else None\n\n    def seek(self, position: int) -&gt; None:\n        \"\"\"Not supported for pipes.\"\"\"\n        raise NotImplementedError(\"Cannot seek in pipe\")\n</code></pre> <p>Usage: <pre><code># Encode live audio with ffmpeg and pipe to multiplexer\npipe_input = PipeInput([\n    'ffmpeg',\n    '-f', 'alsa',           # Input from ALSA (Linux audio)\n    '-i', 'default',\n    '-c:a', 'mp2',          # Encode to MPEG Layer II\n    '-b:a', '128k',\n    '-ar', '48000',\n    '-f', 'mp2',\n    'pipe:1'                # Output to stdout\n])\npipe_input.open()\nmux.add_input('live_audio', pipe_input)\n</code></pre></p>"},{"location":"advanced/extending/#custom-output-destinations","title":"Custom Output Destinations","text":"<p>Create custom outputs by subclassing <code>DabOutput</code>.</p>"},{"location":"advanced/extending/#basic-template_1","title":"Basic Template","text":"<pre><code>from dabmux.output.base import DabOutput\n\nclass CustomOutput(DabOutput):\n    \"\"\"Custom output destination.\"\"\"\n\n    def __init__(self, target: str):\n        \"\"\"Initialize with target destination.\"\"\"\n        self.target = target\n        self.handle = None\n\n    def open(self, *args, **kwargs) -&gt; None:\n        \"\"\"Open output destination.\"\"\"\n        # Initialize output (open connection, file, etc.)\n        print(f\"Opening output to {self.target}\")\n\n    def close(self) -&gt; None:\n        \"\"\"Close output destination.\"\"\"\n        # Cleanup\n        if self.handle:\n            self.handle.close()\n        print(\"Output closed\")\n\n    def write(self, data: bytes) -&gt; None:\n        \"\"\"\n        Write data to output.\n\n        Args:\n            data: Binary data to write (typically ETI frame)\n        \"\"\"\n        # Write data to destination\n        pass\n\n    def get_info(self) -&gt; str:\n        \"\"\"Get output description string.\"\"\"\n        return f\"Custom Output: {self.target}\"\n</code></pre>"},{"location":"advanced/extending/#example-database-output","title":"Example: Database Output","text":"<pre><code>import sqlite3\nfrom datetime import datetime\nfrom dabmux.output.base import DabOutput\n\nclass DatabaseOutput(DabOutput):\n    \"\"\"Store ETI frames in SQLite database.\"\"\"\n\n    def __init__(self, db_path: str):\n        self.db_path = db_path\n        self.conn = None\n\n    def open(self, *args, **kwargs) -&gt; None:\n        \"\"\"Open database connection.\"\"\"\n        self.conn = sqlite3.connect(self.db_path)\n        # Create table\n        self.conn.execute('''\n            CREATE TABLE IF NOT EXISTS eti_frames (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                timestamp TEXT,\n                frame_data BLOB\n            )\n        ''')\n        self.conn.commit()\n\n    def close(self) -&gt; None:\n        \"\"\"Close database.\"\"\"\n        if self.conn:\n            self.conn.close()\n\n    def write(self, data: bytes) -&gt; None:\n        \"\"\"Store frame in database.\"\"\"\n        timestamp = datetime.now().isoformat()\n        self.conn.execute(\n            'INSERT INTO eti_frames (timestamp, frame_data) VALUES (?, ?)',\n            (timestamp, data)\n        )\n        self.conn.commit()\n\n    def get_info(self) -&gt; str:\n        return f\"Database: {self.db_path}\"\n</code></pre>"},{"location":"advanced/extending/#example-multi-destination-output","title":"Example: Multi-Destination Output","text":"<pre><code>from dabmux.output.base import DabOutput\nfrom typing import List\n\nclass MultiOutput(DabOutput):\n    \"\"\"Write to multiple outputs simultaneously.\"\"\"\n\n    def __init__(self, outputs: List[DabOutput]):\n        self.outputs = outputs\n\n    def open(self, *args, **kwargs) -&gt; None:\n        \"\"\"Open all outputs.\"\"\"\n        for output in self.outputs:\n            output.open(*args, **kwargs)\n\n    def close(self) -&gt; None:\n        \"\"\"Close all outputs.\"\"\"\n        for output in self.outputs:\n            output.close()\n\n    def write(self, data: bytes) -&gt; None:\n        \"\"\"Write to all outputs.\"\"\"\n        for output in self.outputs:\n            output.write(data)\n\n    def get_info(self) -&gt; str:\n        infos = [output.get_info() for output in self.outputs]\n        return f\"Multi: {', '.join(infos)}\"\n</code></pre> <p>Usage: <pre><code>from dabmux.output.file import FileOutput\nfrom dabmux.output.edi import EdiOutput\n\n# Create multiple outputs\nfile_out = FileOutput()\nfile_out.open('archive.eti')\n\nedi_out = EdiOutput('239.1.2.3', 12000)\nedi_out.open()\n\n# Combine into multi-output\nmulti = MultiOutput([file_out, edi_out])\n\n# Use with multiplexer\nwhile running:\n    frame = mux.generate_frame()\n    multi.write(frame.pack())\n</code></pre></p>"},{"location":"advanced/extending/#custom-fig-generators","title":"Custom FIG Generators","text":"<p>Extend FIC encoder with custom FIG types.</p>"},{"location":"advanced/extending/#example-custom-fig-type","title":"Example: Custom FIG Type","text":"<pre><code>from dabmux.fig.base import FigGenerator\nfrom typing import List\n\nclass CustomFigGenerator(FigGenerator):\n    \"\"\"Generate custom FIG type.\"\"\"\n\n    def __init__(self, ensemble):\n        self.ensemble = ensemble\n\n    def generate(self) -&gt; List[bytes]:\n        \"\"\"\n        Generate FIG data items.\n\n        Returns:\n            List of FIG data blocks (each max 30 bytes)\n        \"\"\"\n        figs = []\n\n        # Build your FIG data\n        fig_data = bytearray()\n\n        # FIG header (1 byte)\n        fig_type = 0  # FIG type (0-7)\n        extension = 0  # Extension (0-31)\n        fig_header = (fig_type &lt;&lt; 5) | extension\n        fig_data.append(fig_header)\n\n        # Add your data\n        # ... (implement your FIG content)\n\n        # Split into 30-byte blocks if needed\n        max_size = 30\n        for i in range(0, len(fig_data), max_size):\n            figs.append(bytes(fig_data[i:i+max_size]))\n\n        return figs\n\n    def get_repetition_rate(self) -&gt; float:\n        \"\"\"\n        Get repetition rate in seconds.\n\n        Returns:\n            How often this FIG should be transmitted (seconds)\n        \"\"\"\n        return 1.0  # Transmit every 1 second\n</code></pre> <p>Register with FIC encoder: <pre><code>from dabmux.fig.fic import FICEncoder\n\nfic_encoder = FICEncoder(ensemble)\n\n# Add custom FIG generator\ncustom_fig = CustomFigGenerator(ensemble)\nfic_encoder.add_generator(custom_fig)\n</code></pre></p>"},{"location":"advanced/extending/#registering-custom-components","title":"Registering Custom Components","text":""},{"location":"advanced/extending/#uri-scheme-handler","title":"URI Scheme Handler","text":"<p>Register custom input URI schemes:</p> <pre><code>from dabmux.input import register_input_handler\n\ndef create_custom_input(uri: str):\n    \"\"\"Factory function for custom input.\"\"\"\n    # Parse URI and create input instance\n    # uri format: custom://host:port/path\n    return CustomInput(uri)\n\n# Register handler\nregister_input_handler('custom', create_custom_input)\n</code></pre> <p>Usage in configuration: <pre><code>subchannels:\n  - uid: 'sub1'\n    input: 'custom://server:9000/stream'  # Uses custom handler\n</code></pre></p>"},{"location":"advanced/extending/#plugin-architecture","title":"Plugin Architecture","text":""},{"location":"advanced/extending/#creating-a-plugin","title":"Creating a Plugin","text":"<pre><code># my_plugin.py\nfrom dabmux.plugins import DabMuxPlugin\n\nclass MyPlugin(DabMuxPlugin):\n    \"\"\"Custom plugin for python-dabmux.\"\"\"\n\n    name = \"my-plugin\"\n    version = \"1.0.0\"\n\n    def on_frame_generated(self, frame):\n        \"\"\"Called after each frame is generated.\"\"\"\n        print(f\"Frame {frame.fc.fct} generated\")\n\n    def on_multiplexer_start(self, mux):\n        \"\"\"Called when multiplexer starts.\"\"\"\n        print(\"Multiplexer started\")\n\n    def on_multiplexer_stop(self, mux):\n        \"\"\"Called when multiplexer stops.\"\"\"\n        print(\"Multiplexer stopped\")\n</code></pre> <p>Load plugin: <pre><code>from dabmux.plugins import load_plugin\n\nplugin = load_plugin('my_plugin.MyPlugin')\nmux.register_plugin(plugin)\n</code></pre></p>"},{"location":"advanced/extending/#testing-custom-components","title":"Testing Custom Components","text":""},{"location":"advanced/extending/#unit-tests-for-custom-input","title":"Unit Tests for Custom Input","text":"<pre><code>import pytest\nfrom my_custom_input import CustomInput\n\ndef test_custom_input_open():\n    \"\"\"Test opening custom input.\"\"\"\n    input_source = CustomInput({'url': 'test://example'})\n    input_source.open()\n    assert input_source.connected\n\ndef test_custom_input_read_frame():\n    \"\"\"Test reading frame.\"\"\"\n    input_source = CustomInput({'url': 'test://example'})\n    input_source.open()\n\n    frame = input_source.read_frame(960)\n    assert frame is not None\n    assert len(frame) == 960\n\n    input_source.close()\n\ndef test_custom_input_close():\n    \"\"\"Test closing custom input.\"\"\"\n    input_source = CustomInput({'url': 'test://example'})\n    input_source.open()\n    input_source.close()\n    assert not input_source.connected\n</code></pre>"},{"location":"advanced/extending/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/extending/#input-performance","title":"Input Performance","text":"<ul> <li>Buffering: Implement internal buffering to smooth data flow</li> <li>Threading: Consider threading for slow input sources</li> <li>Error handling: Handle transient errors gracefully</li> </ul> <pre><code>import threading\nimport queue\n\nclass BufferedInput(InputBase):\n    \"\"\"Input with background buffering thread.\"\"\"\n\n    def __init__(self, source):\n        self.source = source\n        self.buffer = queue.Queue(maxsize=100)\n        self.thread = None\n        self.running = False\n\n    def open(self) -&gt; None:\n        self.source.open()\n        self.running = True\n        self.thread = threading.Thread(target=self._fill_buffer)\n        self.thread.start()\n\n    def _fill_buffer(self):\n        \"\"\"Background thread to fill buffer.\"\"\"\n        while self.running:\n            chunk = self.source.read_frame(960)\n            if chunk:\n                self.buffer.put(chunk)\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        try:\n            return self.buffer.get(timeout=1.0)\n        except queue.Empty:\n            return None\n\n    def close(self) -&gt; None:\n        self.running = False\n        if self.thread:\n            self.thread.join()\n        self.source.close()\n</code></pre>"},{"location":"advanced/extending/#output-performance","title":"Output Performance","text":"<ul> <li>Batch writes: Write multiple frames at once when possible</li> <li>Async I/O: Use async for network outputs</li> <li>Buffering: Buffer writes for better performance</li> </ul>"},{"location":"advanced/extending/#best-practices","title":"Best Practices","text":"<ol> <li>Follow base class interfaces: Implement all required methods</li> <li>Handle errors gracefully: Don't crash the multiplexer</li> <li>Document your code: Include docstrings and examples</li> <li>Add tests: Unit test your components</li> <li>Consider threading: Use threads for slow operations</li> <li>Log appropriately: Use structlog for consistent logging</li> </ol> <pre><code>import structlog\n\nlogger = structlog.get_logger(__name__)\n\nclass MyCustomInput(InputBase):\n    def open(self) -&gt; None:\n        logger.info(\"Opening custom input\", source=self.source)\n        # ...\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        logger.debug(\"Reading frame\", size=frame_size)\n        # ...\n</code></pre>"},{"location":"advanced/extending/#see-also","title":"See Also","text":"<ul> <li>API Reference - Base classes and interfaces</li> <li>Input API - Input source details</li> <li>Output API - Output destination details</li> <li>Development Guide - Contributing guidelines</li> </ul>"},{"location":"advanced/fig-types/","title":"FIG Types Reference","text":"<p>Complete reference for Fast Information Group (FIG) types in DAB.</p>"},{"location":"advanced/fig-types/#overview","title":"Overview","text":"<p>FIGs (Fast Information Groups) carry service information in the FIC (Fast Information Channel). They describe the ensemble, services, and how to decode them.</p> <p>FIG structure: - Transmitted in FIC (96 bytes Mode I, 32 bytes others) - Multiple FIGs per FIC frame - Carousel rotation for repeated transmission - Each FIG type has specific repetition rate</p>"},{"location":"advanced/fig-types/#fig-classification","title":"FIG Classification","text":"<p>FIGs are organized by type (0-7) and extension (0-31):</p> Type Purpose Examples 0 MCI - Multiplex Configuration Info 0/0, 0/1, 0/2 1 Labels 1/0, 1/1 2 Dynamic labels 2/0, 2/1 5 FIDC 5/0, 5/1 6 Conditional Access 6/0 <p>Notation: FIG X/Y means Type X, Extension Y</p>"},{"location":"advanced/fig-types/#fig-type-0-mci","title":"FIG Type 0 (MCI)","text":"<p>Multiplex Configuration Information - Essential ensemble structure.</p>"},{"location":"advanced/fig-types/#fig-00-ensemble-information","title":"FIG 0/0 - Ensemble Information","text":"<p>Purpose: Basic ensemble configuration</p> <p>Content: - Ensemble ID (16 bits) - Change flags - Alarm flag - CIF count</p> <p>Repetition: Every frame (96ms for Mode I)</p> <p>Structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header \u2502 Ensemble ID\u2502 Flags    \u2502 CIF Count \u2502\n\u2502 1 byte \u2502 2 bytes    \u2502 2 bytes  \u2502 1 byte    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Example data: <pre><code>ensemble_id = 0xCE15\nchange_flag = 0\nalarm_flag = 0\ncif_count = 0  # Wraps 0-249\n\nfig_0_0 = bytes([\n    0x00,  # Type 0, Extension 0\n    (ensemble_id &gt;&gt; 8) &amp; 0xFF,\n    ensemble_id &amp; 0xFF,\n    (change_flag &lt;&lt; 6) | (alarm_flag &lt;&lt; 5),\n    cif_count\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-01-subchannel-organization","title":"FIG 0/1 - Subchannel Organization","text":"<p>Purpose: Define subchannels in the multiplex</p> <p>Content for each subchannel: - Subchannel ID (6 bits) - Start address (10 bits) - Table index / protection (6 bits) - Short/long form flag</p> <p>Repetition: Every 1 second</p> <p>Structure (short form): <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header \u2502 SubChId+Addr \u2502 Table/Form    \u2502 (repeat)   \u2502\n\u2502 1 byte \u2502 2 bytes      \u2502 1 byte        \u2502 ...        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Example (128 kbps, protection 2): <pre><code>subchannel_id = 0      # 6 bits\nstart_address = 0      # 10 bits (in CU)\ntable_index = 8        # For 128 kbps, prot 2\nshort_form = 1         # UEP (short form)\n\n# Pack into bytes\nbyte1 = (subchannel_id &lt;&lt; 2) | (start_address &gt;&gt; 8)\nbyte2 = start_address &amp; 0xFF\nbyte3 = (table_index &lt;&lt; 2) | (short_form &lt;&lt; 0)\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-02-service-organization","title":"FIG 0/2 - Service Organization","text":"<p>Purpose: Link services to components and subchannels</p> <p>Content: - Service ID (16 or 32 bits) - Number of components - Component details:   - Service component ID   - Transport mechanism   - Subchannel ID or FIDCId</p> <p>Repetition: Every 1 second</p> <p>Structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header \u2502 Service ID \u2502 #Comps \u2502 Component Info  \u2502\n\u2502 1 byte \u2502 2-4 bytes  \u2502 1 byte \u2502 2 bytes each    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Example (audio service): <pre><code>service_id = 0x5001     # 16-bit\nnum_components = 1\ncomponent_type = 0      # Audio (stream mode)\nsubchannel_id = 0\n\nfig_0_2 = bytes([\n    0x02,  # Type 0, Extension 2\n    (service_id &gt;&gt; 8) &amp; 0xFF,\n    service_id &amp; 0xFF,\n    num_components,\n    (component_type &lt;&lt; 6) | subchannel_id\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-03-service-component-in-packet-mode","title":"FIG 0/3 - Service Component in Packet Mode","text":"<p>Purpose: Describe packet mode data services</p> <p>Repetition: Every 1 second</p> <p>Usage: Rare in audio-only ensembles</p>"},{"location":"advanced/fig-types/#fig-05-service-component-language","title":"FIG 0/5 - Service Component Language","text":"<p>Purpose: Specify language for each component</p> <p>Content: - Service component ID - Language code (8 bits)</p> <p>Repetition: Every 2 seconds</p> <p>Example (English): <pre><code>language_code = 9  # English\n\nfig_0_5 = bytes([\n    0x05,  # Type 0, Extension 5\n    # ... component ID and language\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-08-service-component-global-definition","title":"FIG 0/8 - Service Component Global Definition","text":"<p>Purpose: Additional service component info</p> <p>Content: - Service ID - Component characteristics - Service component ID (SCIdS)</p> <p>Repetition: Every 2 seconds</p>"},{"location":"advanced/fig-types/#fig-09-country-lto-and-international-table","title":"FIG 0/9 - Country, LTO and International table","text":"<p>Purpose: Country ID and local time offset</p> <p>Content: - Service ID - Extended country code (ECC) - Local time offset (LTO)</p> <p>Repetition: Every 10 seconds</p> <p>Example: <pre><code>ecc = 0xE1      # Germany\nlto = 0         # UTC\nlto_auto = 1    # Automatic LTO\n\nfig_0_9 = bytes([\n    0x09,  # Type 0, Extension 9\n    # ... service ID, ECC, LTO\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-010-date-and-time","title":"FIG 0/10 - Date and Time","text":"<p>Purpose: Current date and time</p> <p>Content: - Modified Julian Date (MJD) - Hours, minutes, seconds - Milliseconds - Local time offset</p> <p>Repetition: Every 1 second</p> <p>Not typically implemented - receivers use RDS/GPS time.</p>"},{"location":"advanced/fig-types/#fig-013-user-application-information","title":"FIG 0/13 - User Application Information","text":"<p>Purpose: User applications (SLS, MOT, etc.)</p> <p>Repetition: Every 10 seconds</p> <p>Usage: For data services (MOT slideshow, etc.)</p>"},{"location":"advanced/fig-types/#fig-017-programme-type","title":"FIG 0/17 - Programme Type","text":"<p>Purpose: Programme type (PTY) for each service</p> <p>Content: - Service ID - PTY code (5 bits)</p> <p>Repetition: Every 10 seconds</p> <p>Example (Pop Music): <pre><code>service_id = 0x5001\npty = 10  # Pop Music\n\nfig_0_17 = bytes([\n    0x11,  # Type 0, Extension 17\n    (service_id &gt;&gt; 8) &amp; 0xFF,\n    service_id &amp; 0xFF,\n    (pty &lt;&lt; 3)\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-type-1-labels","title":"FIG Type 1 (Labels)","text":"<p>Service and ensemble labels.</p>"},{"location":"advanced/fig-types/#fig-10-ensemble-label","title":"FIG 1/0 - Ensemble Label","text":"<p>Purpose: Ensemble name (16 characters)</p> <p>Content: - Ensemble ID - Label (16 bytes, EBU Latin) - Short label flag (16 bits)</p> <p>Repetition: Every 2 seconds</p> <p>Example: <pre><code>ensemble_id = 0xCE15\nlabel = b'My DAB Ensemble '  # 16 bytes, padded\nshort_label_flag = 0x1F00  # \"My DAB\" (first 6 chars)\n\nfig_1_0 = bytes([\n    0x20,  # Type 1, Extension 0\n    (ensemble_id &gt;&gt; 8) &amp; 0xFF,\n    ensemble_id &amp; 0xFF,\n]) + label + bytes([\n    (short_label_flag &gt;&gt; 8) &amp; 0xFF,\n    short_label_flag &amp; 0xFF\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-11-service-label","title":"FIG 1/1 - Service Label","text":"<p>Purpose: Service name (16 characters)</p> <p>Content: - Service ID - Label (16 bytes) - Short label flag</p> <p>Repetition: Every 2 seconds</p> <p>Example: <pre><code>service_id = 0x5001\nlabel = b'Radio One       '  # 16 bytes\nshort_label_flag = 0xFF00  # \"Radio One\" (first 9 chars)\n\nfig_1_1 = bytes([\n    0x21,  # Type 1, Extension 1\n    (service_id &gt;&gt; 8) &amp; 0xFF,\n    service_id &amp; 0xFF,\n]) + label + bytes([\n    (short_label_flag &gt;&gt; 8) &amp; 0xFF,\n    short_label_flag &amp; 0xFF\n])\n</code></pre></p>"},{"location":"advanced/fig-types/#fig-14-service-component-label","title":"FIG 1/4 - Service Component Label","text":"<p>Purpose: Component name</p> <p>Repetition: Every 10 seconds</p> <p>Usage: Rarely used</p>"},{"location":"advanced/fig-types/#fig-15-data-service-label","title":"FIG 1/5 - Data Service Label","text":"<p>Purpose: Data service name</p> <p>Repetition: Every 10 seconds</p> <p>Usage: For data services only</p>"},{"location":"advanced/fig-types/#fig-type-2-dynamic-labels","title":"FIG Type 2 (Dynamic Labels)","text":"<p>Dynamic Label Segment (DLS) for scrolling text.</p>"},{"location":"advanced/fig-types/#fig-20-ensemble-dynamic-label","title":"FIG 2/0 - Ensemble Dynamic Label","text":"<p>Purpose: Scrolling ensemble text</p> <p>Usage: Not commonly used</p>"},{"location":"advanced/fig-types/#fig-21-service-component-dynamic-label","title":"FIG 2/1 - Service Component Dynamic Label","text":"<p>Purpose: Scrolling text (now playing, etc.)</p> <p>Content: - Service component ID - Text segments - Charset indicator</p> <p>Repetition: As needed (variable)</p> <p>Usage: DAB+ stations for \"now playing\" info</p>"},{"location":"advanced/fig-types/#fig-type-5-fidc","title":"FIG Type 5 (FIDC)","text":"<p>Fast Information Data Channel.</p>"},{"location":"advanced/fig-types/#fig-50-paging","title":"FIG 5/0 - Paging","text":"<p>Purpose: Paging information</p> <p>Usage: Rarely used</p>"},{"location":"advanced/fig-types/#fig-51-traffic-message-channel-tmc","title":"FIG 5/1 - Traffic Message Channel (TMC)","text":"<p>Purpose: Traffic information</p> <p>Usage: Specialized data services</p>"},{"location":"advanced/fig-types/#fig-type-6-conditional-access","title":"FIG Type 6 (Conditional Access)","text":""},{"location":"advanced/fig-types/#fig-60-ca-system","title":"FIG 6/0 - CA System","text":"<p>Purpose: Conditional access information</p> <p>Usage: Encrypted services only</p>"},{"location":"advanced/fig-types/#fig-carousel","title":"FIG Carousel","text":"<p>FIGs are transmitted in rotation based on repetition rates:</p> <pre><code>graph LR\n    A[Every Frame96ms] --&gt; B[FIG 0/0]\n    C[Every 1s] --&gt; D[FIG 0/1FIG 0/2]\n    E[Every 2s] --&gt; F[FIG 1/0FIG 1/1]\n    G[Every 10s] --&gt; H[FIG 0/9FIG 0/17]\n</code></pre>"},{"location":"advanced/fig-types/#priority-order","title":"Priority Order","text":"<ol> <li>FIG 0/0 - Every frame (critical)</li> <li>FIG 0/1, 0/2 - Every 1 second (essential)</li> <li>FIG 1/0, 1/1 - Every 2 seconds (important)</li> <li>FIG 0/5, 0/8 - Every 2 seconds (optional)</li> <li>FIG 0/9, 0/17 - Every 10 seconds (metadata)</li> </ol>"},{"location":"advanced/fig-types/#fic-space-usage","title":"FIC Space Usage","text":"<p>Mode I (96 bytes FIC per frame): <pre><code>Available space: ~90 bytes (after header)\nTypical usage:\n  FIG 0/0: 6 bytes\n  FIG 0/1: 4 bytes \u00d7 subchannels\n  FIG 0/2: 6 bytes \u00d7 services\n  FIG 1/0: 19 bytes (ensemble label)\n  FIG 1/1: 19 bytes \u00d7 services (rotated)\n</code></pre></p> <p>Mode II/III/IV (32 bytes FIC per frame): <pre><code>Available space: ~30 bytes\nMust be selective about which FIGs to include\n</code></pre></p>"},{"location":"advanced/fig-types/#implementation-in-python-dabmux","title":"Implementation in python-dabmux","text":""},{"location":"advanced/fig-types/#enabled-by-default","title":"Enabled by Default","text":"<ul> <li>\u2705 FIG 0/0 - Ensemble info</li> <li>\u2705 FIG 0/1 - Subchannel organization</li> <li>\u2705 FIG 0/2 - Service organization</li> <li>\u2705 FIG 1/0 - Ensemble label</li> <li>\u2705 FIG 1/1 - Service labels</li> <li>\u2705 FIG 0/17 - Programme type</li> </ul>"},{"location":"advanced/fig-types/#optionalnot-implemented","title":"Optional/Not Implemented","text":"<ul> <li>\u26a0\ufe0f FIG 0/5 - Language (can be added)</li> <li>\u26a0\ufe0f FIG 0/9 - Country/LTO (can be added)</li> <li>\u274c FIG 2/x - Dynamic labels (not yet)</li> <li>\u274c FIG 5/x - FIDC (rarely needed)</li> <li>\u274c FIG 6/x - CA (specialized)</li> </ul>"},{"location":"advanced/fig-types/#custom-fig-generation","title":"Custom FIG Generation","text":"<p>See Extending python-dabmux for creating custom FIG generators.</p>"},{"location":"advanced/fig-types/#debugging-figs","title":"Debugging FIGs","text":""},{"location":"advanced/fig-types/#parse-fic-data","title":"Parse FIC Data","text":"<pre><code>from dabmux.fig.fic import FICEncoder\n\n# Generate FIC\nfic_encoder = FICEncoder(ensemble)\nfic_data = fic_encoder.encode_fic(frame_number=0)\n\n# Parse FIGs\noffset = 0\nwhile offset &lt; len(fic_data):\n    if fic_data[offset] == 0xFF:  # Padding\n        break\n\n    fig_type = (fic_data[offset] &gt;&gt; 5) &amp; 0x07\n    fig_ext = fic_data[offset] &amp; 0x1F\n\n    print(f\"FIG {fig_type}/{fig_ext}\")\n\n    # Skip to next FIG (implementation dependent)\n    offset += fig_length\n</code></pre>"},{"location":"advanced/fig-types/#validation","title":"Validation","text":"<p>Check FIG correctness with: 1. ODR-DabMux - Compare output 2. DAB receiver - Does it decode correctly? 3. FIG parser - Validate structure</p>"},{"location":"advanced/fig-types/#see-also","title":"See Also","text":"<ul> <li>FIG Carousel - Carousel implementation</li> <li>Basic Concepts - FIG overview</li> <li>ETSI EN 300 401 - Complete FIG specification</li> <li>API: FIG Module - FIG generation API</li> </ul>"},{"location":"advanced/reed-solomon/","title":"Reed-Solomon Forward Error Correction","text":"<p>Reed-Solomon FEC implementation for PFT packet recovery in EDI protocol.</p>"},{"location":"advanced/reed-solomon/#overview","title":"Overview","text":"<p>Reed-Solomon (RS) codes are error-correcting codes used in PFT (Protection, Fragmentation and Transport) to recover lost UDP packets in EDI transmission.</p> <p>Key benefits: - Recover lost packets without retransmission - Protect against network packet loss - Essential for unreliable networks (wireless, Internet)</p>"},{"location":"advanced/reed-solomon/#reed-solomon-basics","title":"Reed-Solomon Basics","text":""},{"location":"advanced/reed-solomon/#what-is-reed-solomon","title":"What is Reed-Solomon?","text":"<p>A mathematical error correction code that adds redundancy to data:</p> <pre><code>Original data:  k packets\nRedundancy:     m packets (FEC)\nTotal sent:     n = k + m packets\n\nCan recover up to m lost packets\n</code></pre>"},{"location":"advanced/reed-solomon/#galois-field-math","title":"Galois Field Math","text":"<p>Reed-Solomon operates in GF(2^8) - Galois Field with 256 elements: - Each element is a byte (0-255) - Special arithmetic rules (finite field) - Uses polynomial mathematics</p> <p>Note: Implementation details are in <code>dabmux/fec/reed_solomon.py</code></p>"},{"location":"advanced/reed-solomon/#pft-reed-solomon-configuration","title":"PFT Reed-Solomon Configuration","text":""},{"location":"advanced/reed-solomon/#parameters","title":"Parameters","text":"<p>python-dabmux uses RS(255, 207) with zero-padding:</p> Parameter Value Description n 255 Total symbols (max for GF(2^8)) k 207 Data symbols m 48 FEC symbols (n - k) Max errors 24 Can correct up to m/2 errors <p>For PFT: - Not all 255 positions used (packets may be fewer) - FEC parameter <code>m</code> sets number of recoverable fragments - Typical: m=2 to m=5</p>"},{"location":"advanced/reed-solomon/#pft-configuration","title":"PFT Configuration","text":""},{"location":"advanced/reed-solomon/#module-dabmuxedipft","title":"Module: <code>dabmux.edi.pft</code>","text":"<pre><code>from dabmux.edi.pft import PFTConfig\n\n# No FEC (fragmentation only)\npft_config = PFTConfig(\n    fec=False,\n    fec_m=0,\n    max_fragment_size=1400\n)\n\n# With FEC (can recover 2 lost fragments)\npft_config = PFTConfig(\n    fec=True,\n    fec_m=2,\n    max_fragment_size=1400\n)\n\n# Strong FEC (can recover 5 lost fragments)\npft_config = PFTConfig(\n    fec=True,\n    fec_m=5,\n    max_fragment_size=1400\n)\n</code></pre>"},{"location":"advanced/reed-solomon/#cli-usage","title":"CLI Usage","text":"<pre><code># EDI with PFT + FEC (m=2)\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 2\n\n# Strong FEC (m=5)\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 5\n</code></pre>"},{"location":"advanced/reed-solomon/#how-it-works","title":"How It Works","text":""},{"location":"advanced/reed-solomon/#encoding-process","title":"Encoding Process","text":"<ol> <li>Fragment data into k packets</li> <li>Add m FEC packets using RS encoding</li> <li>Send all k + m packets over network</li> </ol> <pre><code>Original ETI data (6144 bytes)\n          \u2193\n    Fragmentation\n          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Frag 0 \u2502 Frag 1 \u2502 ... \u2502 Frag k-1 \u2502  (k data fragments)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2193\n   Reed-Solomon Encoding\n          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Frag 0 \u2502 ... \u2502 Frag k-1 \u2502 FEC 0 \u2502 ... \u2502 FEC m-1 \u2502  (k+m total)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2193\n   Transmit all k+m packets\n</code></pre>"},{"location":"advanced/reed-solomon/#decoding-process","title":"Decoding Process","text":"<ol> <li>Receive packets (some may be lost)</li> <li>Check if k packets received</li> <li>If yes: Reassemble data</li> <li>If no but \u2265k total: Use RS decoding to recover</li> </ol> <pre><code>Transmitted: 10 data + 2 FEC = 12 packets\nReceived:    8 data + 2 FEC = 10 packets (2 lost)\n              \u2193\n      Reed-Solomon Decoding\n              \u2193\n      Recover 2 lost packets\n              \u2193\n      Full data restored!\n</code></pre> <p>Condition: Can recover if (received packets) \u2265 k</p>"},{"location":"advanced/reed-solomon/#example-scenarios","title":"Example Scenarios","text":""},{"location":"advanced/reed-solomon/#scenario-1-no-packet-loss","title":"Scenario 1: No Packet Loss","text":"<pre><code>Sent:     10 data + 2 FEC = 12 packets\nReceived: 10 data + 2 FEC = 12 packets\nResult:   \u2705 Use data packets directly (no FEC needed)\n</code></pre>"},{"location":"advanced/reed-solomon/#scenario-2-1-packet-lost-recoverable","title":"Scenario 2: 1 Packet Lost (Recoverable)","text":"<pre><code>Sent:     10 data + 2 FEC = 12 packets\nReceived: 9 data + 2 FEC = 11 packets (1 data lost)\nResult:   \u2705 RS decodes, recovers 1 lost packet\n</code></pre>"},{"location":"advanced/reed-solomon/#scenario-3-2-packets-lost-recoverable","title":"Scenario 3: 2 Packets Lost (Recoverable)","text":"<pre><code>Sent:     10 data + 2 FEC = 12 packets\nReceived: 8 data + 2 FEC = 10 packets (2 data lost)\nResult:   \u2705 RS decodes, recovers 2 lost packets\n</code></pre>"},{"location":"advanced/reed-solomon/#scenario-4-3-packets-lost-not-recoverable","title":"Scenario 4: 3 Packets Lost (Not Recoverable)","text":"<pre><code>Sent:     10 data + 2 FEC = 12 packets\nReceived: 7 data + 2 FEC = 9 packets (3 lost)\nResult:   \u274c Cannot recover (m=2, but 3 lost)\n</code></pre> <p>Rule: Can recover up to m lost packets.</p>"},{"location":"advanced/reed-solomon/#choosing-fec-parameter-m","title":"Choosing FEC Parameter (m)","text":""},{"location":"advanced/reed-solomon/#trade-offs","title":"Trade-offs","text":"m Recovery Overhead Bandwidth Use Case 0 None 0% 1.0\u00d7 Reliable network 2 2 packets ~20% 1.2\u00d7 Occasional loss 3 3 packets ~30% 1.3\u00d7 Moderate loss 5 5 packets ~50% 1.5\u00d7 Lossy network"},{"location":"advanced/reed-solomon/#recommendations","title":"Recommendations","text":"<p>m=0 (No FEC): - Wired networks - Local/LAN - Very reliable connections</p> <p>m=2 (Light FEC): - Good quality networks - Occasional packet loss (&lt;2%) - Standard recommendation</p> <p>m=3 (Moderate FEC): - Moderate packet loss (2-5%) - Wireless links - Balanced protection</p> <p>m=5 (Strong FEC): - High packet loss (5-10%) - Unreliable networks - Internet transmission</p> <p>m&gt;5: - Extreme conditions (&gt;10% loss) - Diminishing returns - High bandwidth cost</p>"},{"location":"advanced/reed-solomon/#bandwidth-calculation","title":"Bandwidth Calculation","text":""},{"location":"advanced/reed-solomon/#formula","title":"Formula","text":"<pre><code>Overhead = m / k\nBandwidth_multiplier = (k + m) / k = 1 + (m / k)\n</code></pre>"},{"location":"advanced/reed-solomon/#examples","title":"Examples","text":"<p>Typical scenario (m=2, k=10): <pre><code>Overhead: 2/10 = 20%\nBandwidth: 1.2\u00d7 base bandwidth\n</code></pre></p> <p>Strong FEC (m=5, k=10): <pre><code>Overhead: 5/10 = 50%\nBandwidth: 1.5\u00d7 base bandwidth\n</code></pre></p> <p>ETI transmission (Mode I): <pre><code>Base ETI: ~590 kbps (without PFT)\nWith PFT (m=2): ~590 \u00d7 1.2 = 708 kbps\nWith PFT (m=5): ~590 \u00d7 1.5 = 885 kbps\n</code></pre></p>"},{"location":"advanced/reed-solomon/#python-api","title":"Python API","text":""},{"location":"advanced/reed-solomon/#module-dabmuxfecreed_solomon","title":"Module: <code>dabmux.fec.reed_solomon</code>","text":"<pre><code>from dabmux.fec.reed_solomon import ReedSolomonEncoder, ReedSolomonDecoder\n\n# Create encoder\nencoder = ReedSolomonEncoder(fec_symbols=2)\n\n# Original data (k packets)\ndata_packets = [b'packet1', b'packet2', ..., b'packetk']\n\n# Encode (generates m FEC packets)\nfec_packets = encoder.encode(data_packets)\n\n# Total packets to transmit\nall_packets = data_packets + fec_packets\n\n# --- Network transmission ---\n\n# Receiver side (some packets may be lost)\nreceived_packets = [...]  # Some packets missing\n\n# Create decoder\ndecoder = ReedSolomonDecoder(fec_symbols=2)\n\n# Decode (recovers lost packets)\ntry:\n    recovered_data = decoder.decode(received_packets)\n    print(\"Data recovered successfully!\")\nexcept ValueError as e:\n    print(f\"Cannot recover: {e}\")\n</code></pre>"},{"location":"advanced/reed-solomon/#encoder-class","title":"Encoder Class","text":""},{"location":"advanced/reed-solomon/#reedsolomonencoderfec_symbols-int","title":"<code>ReedSolomonEncoder(fec_symbols: int)</code>","text":"<p>Create Reed-Solomon encoder.</p> <p>Parameters: - <code>fec_symbols: int</code> - Number of FEC symbols (m)</p> <p>Methods:</p>"},{"location":"advanced/reed-solomon/#encodedata-listbytes-listbytes","title":"<code>encode(data: list[bytes]) -&gt; list[bytes]</code>","text":"<p>Generate FEC packets.</p> <p>Parameters: - <code>data: list[bytes]</code> - Data packets (k packets)</p> <p>Returns: FEC packets (m packets)</p>"},{"location":"advanced/reed-solomon/#decoder-class","title":"Decoder Class","text":""},{"location":"advanced/reed-solomon/#reedsolomondecoderfec_symbols-int","title":"<code>ReedSolomonDecoder(fec_symbols: int)</code>","text":"<p>Create Reed-Solomon decoder.</p> <p>Parameters: - <code>fec_symbols: int</code> - Number of FEC symbols (m)</p> <p>Methods:</p>"},{"location":"advanced/reed-solomon/#decodepackets-listbytes-positions-listint-listbytes","title":"<code>decode(packets: list[bytes], positions: list[int]) -&gt; list[bytes]</code>","text":"<p>Recover lost packets.</p> <p>Parameters: - <code>packets: list[bytes]</code> - Received packets (data + FEC) - <code>positions: list[int]</code> - Position indices of received packets</p> <p>Returns: Complete data (all k packets)</p> <p>Raises: - <code>ValueError</code> - If recovery impossible (too many lost)</p>"},{"location":"advanced/reed-solomon/#performance","title":"Performance","text":""},{"location":"advanced/reed-solomon/#encoding-performance","title":"Encoding Performance","text":"<ul> <li>Time complexity: O(k \u00d7 m)</li> <li>Typical encoding time: &lt;1ms for ETI frame</li> <li>CPU usage: Minimal (&lt;5% overhead)</li> </ul>"},{"location":"advanced/reed-solomon/#decoding-performance","title":"Decoding Performance","text":"<ul> <li>Time complexity: O(k \u00d7 m)</li> <li>Typical decoding time: &lt;2ms for ETI frame</li> <li>Only needed when packets lost</li> </ul>"},{"location":"advanced/reed-solomon/#memory-usage","title":"Memory Usage","text":"<ul> <li>Encoder: ~k \u00d7 packet_size</li> <li>Decoder: ~(k+m) \u00d7 packet_size</li> <li>Typical: &lt;100 KB per ETI frame</li> </ul>"},{"location":"advanced/reed-solomon/#real-world-example","title":"Real-World Example","text":""},{"location":"advanced/reed-solomon/#network-statistics","title":"Network Statistics","text":"<p>Network with 2% packet loss:</p> <pre><code>Frames sent:     10,000\nPackets per frame: 10 + 2 FEC = 12\nTotal packets:   120,000\nPackets lost:    2,400 (2%)\n\nWithout FEC (m=0):\n  Frames with loss: ~1,814 (18%)\n  Frames unrecoverable: ~1,814 (18%)\n  Success rate: 82%\n\nWith FEC (m=2):\n  Frames with \u22642 lost: ~1,752 (17.5%)\n  Frames with &gt;2 lost: ~62 (0.6%)\n  Success rate: 99.4%\n</code></pre> <p>FEC effectiveness: 82% \u2192 99.4% success rate!</p>"},{"location":"advanced/reed-solomon/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/reed-solomon/#fec-not-working","title":"FEC Not Working","text":"<p>Problem: Packets still lost despite FEC</p> <p>Check: 1. Packet loss &gt; m? Increase m value 2. Fragment size too large? Reduce <code>max_fragment_size</code> 3. Network unreliable? Use TCP instead of UDP 4. Corrupt packets? RS can't fix corruption, only loss</p>"},{"location":"advanced/reed-solomon/#high-bandwidth-usage","title":"High Bandwidth Usage","text":"<p>Problem: Too much network traffic</p> <p>Solution: 1. Reduce m value (less FEC) 2. Increase fragment size (fewer packets) 3. Reduce bitrate (lower quality) 4. Use DAB+ instead of DAB (more efficient codec)</p>"},{"location":"advanced/reed-solomon/#decoder-errors","title":"Decoder Errors","text":"<p>Problem: <code>ValueError: Cannot recover</code></p> <p>Cause: Too many packets lost (&gt;m)</p> <p>Solution: 1. Increase m value 2. Improve network quality 3. Use TCP for reliability</p>"},{"location":"advanced/reed-solomon/#mathematical-details","title":"Mathematical Details","text":""},{"location":"advanced/reed-solomon/#generator-polynomial","title":"Generator Polynomial","text":"<p>Reed-Solomon uses primitive polynomial: <pre><code>g(x) = (x - \u03b1^0)(x - \u03b1^1)...(x - \u03b1^(m-1))\n</code></pre></p> <p>Where \u03b1 is a primitive element of GF(2^8).</p>"},{"location":"advanced/reed-solomon/#encoding-equation","title":"Encoding Equation","text":"<pre><code>c(x) = m(x) \u00b7 x^m + r(x)\n</code></pre> <p>Where: - m(x) = message polynomial - r(x) = remainder from division by g(x) - c(x) = codeword polynomial</p> <p>Implementation: See <code>dabmux/fec/reed_solomon.py</code></p>"},{"location":"advanced/reed-solomon/#see-also","title":"See Also","text":"<ul> <li>PFT Fragmentation - PFT overview</li> <li>EDI Protocol - EDI with PFT/FEC</li> <li>Output API - EDI output configuration</li> <li>Network Streaming Tutorial - Practical examples</li> </ul>"},{"location":"advanced/reed-solomon/#references","title":"References","text":"<ul> <li>Reed-Solomon codes - Wikipedia</li> <li>ETSI TS 102 693 - EDI specification with RS-FEC</li> <li>Galois Field arithmetic - Finite field mathematics</li> </ul>"},{"location":"advanced/timestamps-sync/","title":"Timestamps &amp; Synchronization","text":"<p>TIST (Timestamp) implementation for Single Frequency Networks and synchronized transmission.</p>"},{"location":"advanced/timestamps-sync/#overview","title":"Overview","text":"<p>TIST (Time-Stamp) is an optional 4-byte field in ETI frames that enables precise timing for: - Single Frequency Networks (SFN) - Multiple transmitters on same frequency - Synchronized transmission - Coordinated multi-site broadcasting - Time-aligned recording - Frame-accurate archives</p>"},{"location":"advanced/timestamps-sync/#tist-structure","title":"TIST Structure","text":""},{"location":"advanced/timestamps-sync/#binary-format","title":"Binary Format","text":"<pre><code>32-bit timestamp (little-endian)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502  TIST (4 bytes)              \u2502\n\u2502  Time in 16.384 MHz ticks    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/timestamps-sync/#clock-rate","title":"Clock Rate","text":"<p>TIST uses 16.384 MHz clock (16,384,000 ticks per second): - 1 tick = 61.035 nanoseconds - 1 millisecond = 16,384 ticks - 1 second = 16,384,000 ticks</p>"},{"location":"advanced/timestamps-sync/#value-range","title":"Value Range","text":"<ul> <li>32-bit unsigned integer: 0 to 4,294,967,295</li> <li>Time range: ~262 seconds (~4.4 minutes)</li> <li>Wraps around: After ~262 seconds, value resets to 0</li> </ul>"},{"location":"advanced/timestamps-sync/#enabling-tist","title":"Enabling TIST","text":""},{"location":"advanced/timestamps-sync/#configuration","title":"Configuration","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  transmission_mode: 'I'\n  label:\n    text: 'SFN Network'\n\n  # Enable TIST\n  enable_tist: true\n  tist_offset: 0.0  # Offset in milliseconds (optional)\n</code></pre>"},{"location":"advanced/timestamps-sync/#cli","title":"CLI","text":"<pre><code># Enable TIST in output\npython -m dabmux.cli -c config.yaml -o output.eti --tist\n\n# With offset (e.g., 100ms delay)\npython -m dabmux.cli -c config.yaml -o output.eti --tist --tist-offset 100.0\n</code></pre>"},{"location":"advanced/timestamps-sync/#python-api","title":"Python API","text":"<pre><code>from dabmux.config import load_config\nfrom dabmux.mux import DabMultiplexer\n\n# Load configuration with TIST enabled\nensemble = load_config('config.yaml')\nensemble.enable_tist = True\nensemble.tist_offset = 0.0  # milliseconds\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Generate frame (TIST automatically added)\nframe = mux.generate_frame()\nassert frame.tist is not None\n\n# Frame size includes TIST\nassert len(frame.pack()) == 6148  # 6144 + 4 for TIST\n</code></pre>"},{"location":"advanced/timestamps-sync/#tist-calculation","title":"TIST Calculation","text":""},{"location":"advanced/timestamps-sync/#from-system-time","title":"From System Time","text":"<pre><code>from dabmux.core.eti import EtiTIST\nfrom datetime import datetime\n\n# Get current time\nnow = datetime.now()\n\n# Convert to TIST\ntist = EtiTIST.from_datetime(now)\n\n# Get TIST value (16.384 MHz ticks)\nticks = tist.tist\nprint(f\"TIST: {ticks} ticks\")\n\n# Convert back to seconds\nseconds = ticks / 16_384_000.0\nprint(f\"Time: {seconds:.6f} seconds\")\n</code></pre>"},{"location":"advanced/timestamps-sync/#manual-calculation","title":"Manual Calculation","text":"<pre><code>import time\n\n# Get Unix timestamp\nunix_time = time.time()\n\n# Calculate ticks since midnight UTC\nseconds_since_midnight = unix_time % 86400  # Seconds in a day\nticks = int(seconds_since_midnight * 16_384_000) &amp; 0xFFFFFFFF\n\n# Create TIST\nfrom dabmux.core.eti import EtiTIST\ntist = EtiTIST(tist=ticks)\n</code></pre>"},{"location":"advanced/timestamps-sync/#tist-offset","title":"TIST Offset","text":""},{"location":"advanced/timestamps-sync/#purpose","title":"Purpose","text":"<p>TIST offset compensates for: - Processing delays - Network latency - Modulator delays - Transmitter delays</p>"},{"location":"advanced/timestamps-sync/#application","title":"Application","text":"<pre><code>ensemble:\n  enable_tist: true\n  tist_offset: 200.0  # Add 200ms to all timestamps\n</code></pre> <p>Effect: <pre><code>Base TIST:     1000000 ticks (at generation)\nOffset:        + 200ms = +3,276,800 ticks\nFinal TIST:    4,276,800 ticks\n</code></pre></p>"},{"location":"advanced/timestamps-sync/#use-cases","title":"Use Cases","text":"<p>Compensate for modulator delay: <pre><code># Modulator adds 150ms processing delay\ntist_offset: 150.0\n</code></pre></p> <p>Align multiple multiplexers: <pre><code># Site A (reference)\ntist_offset: 0.0\n\n# Site B (50ms behind)\ntist_offset: 50.0\n\n# Site C (100ms ahead)\ntist_offset: -100.0\n</code></pre></p>"},{"location":"advanced/timestamps-sync/#single-frequency-networks-sfn","title":"Single Frequency Networks (SFN)","text":""},{"location":"advanced/timestamps-sync/#concept","title":"Concept","text":"<p>Multiple transmitters broadcast the same signal on the same frequency. Receivers see constructive interference if transmitters are synchronized.</p> <pre><code>Transmitter A \u2500\u2500\u2500\u2510\n                 \u251c\u2500\u2500&gt; Same frequency (e.g., 225.648 MHz)\nTransmitter B \u2500\u2500\u2500\u2524    Same content\n                 \u2502    Synchronized timing via TIST\nTransmitter C \u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/timestamps-sync/#requirements","title":"Requirements","text":"<ol> <li>Same ETI stream - All transmitters use identical frames</li> <li>Synchronized TIST - All frames have matching timestamps</li> <li>GPS-locked clocks - Transmitters locked to GPS time</li> <li>Propagation delay compensation - Account for distance between transmitters</li> </ol>"},{"location":"advanced/timestamps-sync/#timing-tolerance","title":"Timing Tolerance","text":"<ul> <li>Maximum offset: \u00b125 \u03bcs (Mode I)</li> <li>GPS accuracy: ~100 ns</li> <li>Typical SFN accuracy: \u00b11 \u03bcs</li> </ul>"},{"location":"advanced/timestamps-sync/#configuration-example","title":"Configuration Example","text":"<pre><code># Master multiplexer\nensemble:\n  enable_tist: true\n  tist_offset: 0.0\n\n# Distribute ETI to all transmitters via EDI\n</code></pre>"},{"location":"advanced/timestamps-sync/#frame-timing","title":"Frame Timing","text":""},{"location":"advanced/timestamps-sync/#mode-i-timing","title":"Mode I Timing","text":"<pre><code>Frame duration: 96 ms\nTIST increment: ~1,572,864 ticks per frame\n\nFrame N:   TIST = 0\nFrame N+1: TIST = 1,572,864\nFrame N+2: TIST = 3,145,728\n...\n</code></pre>"},{"location":"advanced/timestamps-sync/#mode-ii-timing","title":"Mode II Timing","text":"<pre><code>Frame duration: 24 ms\nTIST increment: ~393,216 ticks per frame\n\nFrame N:   TIST = 0\nFrame N+1: TIST = 393,216\nFrame N+2: TIST = 786,432\n...\n</code></pre>"},{"location":"advanced/timestamps-sync/#calculating-frame-time","title":"Calculating Frame Time","text":"<pre><code>def ticks_per_frame(mode: int) -&gt; int:\n    \"\"\"Calculate TIST increment per frame.\"\"\"\n    frame_duration_ms = {\n        1: 96,   # Mode I\n        2: 24,   # Mode II\n        3: 24,   # Mode III\n        4: 96    # Mode IV\n    }[mode]\n\n    # Convert milliseconds to ticks\n    return int(frame_duration_ms * 16_384)\n\n# Example: Mode I\nticks = ticks_per_frame(1)\nprint(f\"Mode I: {ticks} ticks per frame\")  # 1,572,864\n</code></pre>"},{"location":"advanced/timestamps-sync/#reading-tist-from-eti","title":"Reading TIST from ETI","text":""},{"location":"advanced/timestamps-sync/#parse-eti-frame","title":"Parse ETI Frame","text":"<pre><code>from dabmux.core.eti import EtiFrame, EtiTIST\n\n# Read ETI frame from file\nwith open('input.eti', 'rb') as f:\n    frame_data = f.read(6148)  # 6144 + 4 for TIST\n\n# Check if TIST is present (frame must be 6148 bytes)\nhas_tist = len(frame_data) == 6148\n\nif has_tist:\n    # Extract TIST (last 4 bytes)\n    tist_bytes = frame_data[-4:]\n    tist = EtiTIST.unpack(tist_bytes)\n\n    print(f\"TIST: {tist.tist} ticks\")\n\n    # Convert to seconds\n    seconds = tist.tist / 16_384_000.0\n    print(f\"Time: {seconds:.6f} seconds\")\n</code></pre>"},{"location":"advanced/timestamps-sync/#tist-in-edi","title":"TIST in EDI","text":"<p>When transmitting ETI over EDI (Ensemble Data Interface), TIST is included in the <code>estN</code> TAG item:</p> <pre><code>EDI Packet:\n  *ptr TAG (protocol)\n  deti TAG (ETI data)\n  estN TAG (timestamp) \u2190 TIST value here\n</code></pre> <p>Note: EDI automatically handles TIST when present in ETI frames.</p>"},{"location":"advanced/timestamps-sync/#synchronization-example","title":"Synchronization Example","text":""},{"location":"advanced/timestamps-sync/#multi-site-setup","title":"Multi-Site Setup","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.output.edi import EdiOutput\nfrom dabmux.edi.pft import PFTConfig\nimport time\n\n# Configuration with TIST\nensemble.enable_tist = True\nensemble.tist_offset = 0.0\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Create EDI outputs for multiple transmitters\nsites = [\n    ('239.1.2.3', 12000),  # Site A\n    ('239.1.2.4', 12000),  # Site B\n    ('239.1.2.5', 12000),  # Site C\n]\n\noutputs = []\nfor addr, port in sites:\n    output = EdiOutput(addr, port, enable_pft=True,\n                      pft_config=PFTConfig(fec=True, fec_m=2))\n    output.open()\n    outputs.append(output)\n\n# Generate and distribute frames\ntry:\n    while True:\n        frame = mux.generate_frame()\n\n        # Send to all sites simultaneously\n        for output in outputs:\n            output.write_frame(frame)\n\n        # Wait for next frame time (96ms for Mode I)\n        time.sleep(0.096)\n\nfinally:\n    for output in outputs:\n        output.close()\n</code></pre>"},{"location":"advanced/timestamps-sync/#tist-validation","title":"TIST Validation","text":""},{"location":"advanced/timestamps-sync/#check-tist-consistency","title":"Check TIST Consistency","text":"<pre><code>def validate_tist_sequence(frames):\n    \"\"\"Validate TIST increments correctly.\"\"\"\n    expected_increment = 1_572_864  # Mode I\n\n    for i in range(1, len(frames)):\n        prev_tist = frames[i-1].tist.tist\n        curr_tist = frames[i].tist.tist\n\n        # Handle wrap-around\n        if curr_tist &lt; prev_tist:\n            curr_tist += 2**32\n\n        increment = curr_tist - prev_tist\n\n        if abs(increment - expected_increment) &gt; 100:\n            print(f\"Frame {i}: TIST jump detected\")\n            print(f\"  Expected: {expected_increment}\")\n            print(f\"  Actual:   {increment}\")\n</code></pre>"},{"location":"advanced/timestamps-sync/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/timestamps-sync/#tist-generation-overhead","title":"TIST Generation Overhead","text":"<ul> <li>Minimal overhead: &lt;0.1ms per frame</li> <li>System time call: Once per frame</li> <li>Clock accuracy: Depends on system clock quality</li> </ul>"},{"location":"advanced/timestamps-sync/#gps-synchronization","title":"GPS Synchronization","text":"<p>For production SFN: 1. Use GPS-disciplined clock on multiplexer host 2. NTP not sufficient - Use GPS or PTP for sub-microsecond accuracy 3. Monitor clock drift - Log TIST consistency</p>"},{"location":"advanced/timestamps-sync/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/timestamps-sync/#tist-not-present","title":"TIST Not Present","text":"<p>Problem: ETI frames are 6144 bytes (no TIST)</p> <p>Solution: <pre><code>ensemble:\n  enable_tist: true  # Add this\n</code></pre></p>"},{"location":"advanced/timestamps-sync/#tist-values-not-incrementing","title":"TIST Values Not Incrementing","text":"<p>Problem: TIST same across frames</p> <p>Cause: System time not advancing or TIST calculation issue</p> <p>Check: <pre><code>import time\nstart = time.time()\ntime.sleep(0.1)\nend = time.time()\nassert end &gt; start, \"System time not advancing\"\n</code></pre></p>"},{"location":"advanced/timestamps-sync/#sfn-synchronization-issues","title":"SFN Synchronization Issues","text":"<p>Problem: Multiple transmitters not synchronized</p> <p>Checklist: - \u2611 All transmitters using same ETI stream? - \u2611 All transmitters GPS-locked? - \u2611 TIST offsets configured correctly? - \u2611 Network latency stable? - \u2611 Propagation delays compensated?</p>"},{"location":"advanced/timestamps-sync/#see-also","title":"See Also","text":"<ul> <li>Architecture: ETI Frames - TIST field details</li> <li>EDI Protocol - TIST in network transmission</li> <li>Output API - EDI output configuration</li> <li>ETSI EN 300 799 - Official TIST specification</li> </ul>"},{"location":"advanced/transmission-modes/","title":"Transmission Modes","text":"<p>Complete guide to DAB transmission modes (I, II, III, IV) with technical details and capacity calculations.</p>"},{"location":"advanced/transmission-modes/#overview","title":"Overview","text":"<p>DAB defines four transmission modes optimized for different coverage scenarios and frequency bands. The mode affects frame timing, FIC size, and total capacity.</p>"},{"location":"advanced/transmission-modes/#mode-comparison-table","title":"Mode Comparison Table","text":"Parameter Mode I Mode II Mode III Mode IV Frame Duration 96 ms 24 ms 24 ms 96 ms Symbols per Frame 76 76 153 76 FIC Size 96 bytes 32 bytes 32 bytes 32 bytes Total Capacity (CU) 864 432 864 432 Typical Use VHF Band III VHF Band III (mobile) &lt; 3 GHz L-Band (1.5 GHz) Max Range Large area Medium area Medium area Local/mobile Guard Interval 246 \u03bcs 62 \u03bcs 31 \u03bcs 123 \u03bcs"},{"location":"advanced/transmission-modes/#mode-i-most-common","title":"Mode I (Most Common)","text":""},{"location":"advanced/transmission-modes/#characteristics","title":"Characteristics","text":"<ul> <li>Frame duration: 96 ms (10.416\u0304 frames/second)</li> <li>FIC size: 96 bytes (3 FIBs \u00d7 32 bytes)</li> <li>MST capacity: 864 CU</li> <li>ETI frame size: 6144 bytes (6148 with TIST)</li> </ul>"},{"location":"advanced/transmission-modes/#use-cases","title":"Use Cases","text":"<ul> <li>Primary use: VHF Band III (174-240 MHz)</li> <li>Coverage: Large area, national networks</li> <li>Environment: Fixed reception, portable radios</li> <li>Typical: Most DAB transmissions worldwide</li> </ul>"},{"location":"advanced/transmission-modes/#frame-structure","title":"Frame Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC    \u2502 FC       \u2502 STC \u00d7 N    \u2502 EOH     \u2502 FIC (96 B) \u2502\n\u2502 4 bytes \u2502 4 bytes  \u2502 4\u00d7N bytes  \u2502 4 bytes \u2502            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 MST        \u2502 EOF  \u2502 TIST     \u2502\n         \u2502 ~5760 B    \u2502 4 B  \u2502 4 B (opt)\u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/transmission-modes/#capacity-calculation","title":"Capacity Calculation","text":"<p>Total capacity: 864 CU</p> <p>Example ensemble (Mode I): <pre><code>Service 1: 128 kbps, protection 2 \u2192 ~84 CU\nService 2: 128 kbps, protection 2 \u2192 ~84 CU\nService 3: 96 kbps, protection 2  \u2192 ~63 CU\nService 4: 96 kbps, protection 2  \u2192 ~63 CU\nService 5: 64 kbps, protection 2  \u2192 ~42 CU\nService 6: 64 kbps, protection 2  \u2192 ~42 CU\n                             Total: ~378 CU (44% of 864)\n</code></pre></p> <p>Can fit 6-8 services at standard quality.</p>"},{"location":"advanced/transmission-modes/#configuration","title":"Configuration","text":"<pre><code>ensemble:\n  transmission_mode: 'I'  # or 1\n</code></pre>"},{"location":"advanced/transmission-modes/#mode-ii","title":"Mode II","text":""},{"location":"advanced/transmission-modes/#characteristics_1","title":"Characteristics","text":"<ul> <li>Frame duration: 24 ms (41.6\u0304 frames/second)</li> <li>FIC size: 32 bytes (1 FIB)</li> <li>MST capacity: 432 CU (half of Mode I)</li> <li>ETI frame size: ~3100 bytes</li> </ul>"},{"location":"advanced/transmission-modes/#use-cases_1","title":"Use Cases","text":"<ul> <li>Primary use: VHF Band III (mobile reception)</li> <li>Coverage: Medium area, regional networks</li> <li>Environment: Fast-moving vehicles</li> <li>Benefits: Better Doppler shift handling</li> </ul>"},{"location":"advanced/transmission-modes/#frame-structure_1","title":"Frame Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC    \u2502 FC       \u2502 STC \u00d7 N    \u2502 EOH     \u2502 FIC (32 B) \u2502\n\u2502 4 bytes \u2502 4 bytes  \u2502 4\u00d7N bytes  \u2502 4 bytes \u2502            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502 MST        \u2502 EOF  \u2502\n         \u2502 ~3000 B    \u2502 4 B  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/transmission-modes/#capacity","title":"Capacity","text":"<p>Total capacity: 432 CU (50% of Mode I)</p> <p>Example ensemble: <pre><code>Service 1: 96 kbps, protection 2  \u2192 ~63 CU\nService 2: 96 kbps, protection 2  \u2192 ~63 CU\nService 3: 64 kbps, protection 2  \u2192 ~42 CU\nService 4: 64 kbps, protection 2  \u2192 ~42 CU\n                             Total: ~210 CU (49% of 432)\n</code></pre></p> <p>Can fit 3-5 services at standard quality.</p>"},{"location":"advanced/transmission-modes/#configuration_1","title":"Configuration","text":"<pre><code>ensemble:\n  transmission_mode: 'II'  # or 2\n</code></pre>"},{"location":"advanced/transmission-modes/#mode-iii","title":"Mode III","text":""},{"location":"advanced/transmission-modes/#characteristics_2","title":"Characteristics","text":"<ul> <li>Frame duration: 24 ms (41.6\u0304 frames/second)</li> <li>FIC size: 32 bytes</li> <li>MST capacity: 864 CU (same as Mode I)</li> <li>Symbols: 153 (double Mode II)</li> </ul>"},{"location":"advanced/transmission-modes/#use-cases_2","title":"Use Cases","text":"<ul> <li>Primary use: Frequencies below 3 GHz</li> <li>Coverage: Medium to large area</li> <li>Benefits: More capacity than Mode II, faster updates than Mode I</li> </ul>"},{"location":"advanced/transmission-modes/#frame-structure_2","title":"Frame Structure","text":"<p>Similar to Mode II but with double the MST capacity.</p>"},{"location":"advanced/transmission-modes/#capacity_1","title":"Capacity","text":"<p>Total capacity: 864 CU (same as Mode I)</p> <p>Can fit 6-8 services at standard quality, with faster frame rate than Mode I.</p>"},{"location":"advanced/transmission-modes/#configuration_2","title":"Configuration","text":"<pre><code>ensemble:\n  transmission_mode: 'III'  # or 3\n</code></pre>"},{"location":"advanced/transmission-modes/#mode-iv","title":"Mode IV","text":""},{"location":"advanced/transmission-modes/#characteristics_3","title":"Characteristics","text":"<ul> <li>Frame duration: 96 ms (10.416\u0304 frames/second)</li> <li>FIC size: 32 bytes</li> <li>MST capacity: 432 CU (same as Mode II)</li> </ul>"},{"location":"advanced/transmission-modes/#use-cases_3","title":"Use Cases","text":"<ul> <li>Primary use: L-Band (1.5 GHz)</li> <li>Coverage: Local, mobile services</li> <li>Environment: Urban areas, complementary services</li> </ul>"},{"location":"advanced/transmission-modes/#capacity_2","title":"Capacity","text":"<p>Total capacity: 432 CU (same as Mode II)</p> <p>Can fit 3-5 services at standard quality.</p>"},{"location":"advanced/transmission-modes/#configuration_3","title":"Configuration","text":"<pre><code>ensemble:\n  transmission_mode: 'IV'  # or 4\n</code></pre>"},{"location":"advanced/transmission-modes/#choosing-a-transmission-mode","title":"Choosing a Transmission Mode","text":""},{"location":"advanced/transmission-modes/#decision-tree","title":"Decision Tree","text":"<pre><code>graph TD\n    A[Choose Transmission Mode] --&gt; B{Frequency Band?}\n    B --&gt;|VHF Band III174-240 MHz| C{Mobile or Fixed?}\n    B --&gt;|L-Band1.5 GHz| D[Mode IV]\n    B --&gt;|Below 3 GHz| E[Mode III]\n\n    C --&gt;|Fixed/Portable| F{Coverage Area?}\n    C --&gt;|Mobile| G[Mode II]\n\n    F --&gt;|Large/National| H[Mode I]\n    F --&gt;|Regional| G\n</code></pre>"},{"location":"advanced/transmission-modes/#recommendations","title":"Recommendations","text":"<p>Use Mode I if: - \u2705 VHF Band III (174-240 MHz) - \u2705 Large coverage area (national network) - \u2705 Fixed or portable reception - \u2705 Maximum capacity needed (6-8 services) - \u2705 Most common choice</p> <p>Use Mode II if: - \u2705 VHF Band III - \u2705 Mobile reception (vehicles) - \u2705 Better Doppler tolerance needed - \u2705 Fewer services (3-5)</p> <p>Use Mode III if: - \u2705 Frequencies below 3 GHz - \u2705 Large capacity with faster frame rate - \u2705 Specialized deployment</p> <p>Use Mode IV if: - \u2705 L-Band (1.5 GHz) - \u2705 Local or mobile services - \u2705 Urban areas</p>"},{"location":"advanced/transmission-modes/#frame-timing-details","title":"Frame Timing Details","text":""},{"location":"advanced/transmission-modes/#mode-i-timing","title":"Mode I Timing","text":"<pre><code>Frame duration: 96 ms\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 NULL \u2502 OFDM Symbol \u00d7 76 \u2502\n\u2502 1.297\u2502     ~1.246 ms each \u2502\n\u2502  ms  \u2502                    \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n         Total: 96 ms (10.416\u0304 fps)\n\nGuard interval: 246 \u03bcs\nSymbol duration: 1.246 ms\n</code></pre>"},{"location":"advanced/transmission-modes/#mode-ii-timing","title":"Mode II Timing","text":"<pre><code>Frame duration: 24 ms\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 NULL \u2502 OFDM Symbol \u00d7 76 \u2502\n\u2502 324  \u2502    ~311.5 \u03bcs each\u2502\n\u2502  \u03bcs  \u2502                  \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     Total: 24 ms (41.6\u0304 fps)\n\nGuard interval: 62 \u03bcs\nSymbol duration: 311.5 \u03bcs\n</code></pre>"},{"location":"advanced/transmission-modes/#capacity-unit-cu-calculations","title":"Capacity Unit (CU) Calculations","text":"<p>One Capacity Unit (CU) = 8 kbps equivalent.</p>"},{"location":"advanced/transmission-modes/#bitrate-to-cu-conversion","title":"Bitrate to CU Conversion","text":"Bitrate Protection CUs (approx) 32 kbps Level 2 18 64 kbps Level 2 42 96 kbps Level 2 63 128 kbps Level 2 84 160 kbps Level 2 105 192 kbps Level 2 126 <p>Note: Higher protection levels require more CUs for the same bitrate.</p>"},{"location":"advanced/transmission-modes/#protection-level-impact","title":"Protection Level Impact","text":"Bitrate Protection 1 Protection 2 Protection 3 Protection 4 128 kbps 76 CU 84 CU 96 CU 116 CU <p>Higher protection = more error correction = more CUs needed.</p>"},{"location":"advanced/transmission-modes/#eti-frame-size-by-mode","title":"ETI Frame Size by Mode","text":"Mode Frame Size (bytes) With TIST I 6144 6148 II ~3072 ~3076 III ~6144 ~6148 IV ~3072 ~3076 <p>Note: Exact MST size depends on number and configuration of subchannels.</p>"},{"location":"advanced/transmission-modes/#fic-capacity-by-mode","title":"FIC Capacity by Mode","text":"Mode FIBs per Frame Total FIC Size FIG Capacity I 3 96 bytes 3 \u00d7 30 bytes = 90 bytes II 1 32 bytes 30 bytes III 1 32 bytes 30 bytes IV 1 32 bytes 30 bytes <p>Mode I can carry 3\u00d7 more FIG data per frame.</p>"},{"location":"advanced/transmission-modes/#programming-examples","title":"Programming Examples","text":""},{"location":"advanced/transmission-modes/#mode-i-configuration","title":"Mode I Configuration","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  transmission_mode: 'I'\n  label:\n    text: 'National DAB'\n\n# Can fit 6-8 services at 128 kbps\nsubchannels:\n  - id: 0\n    bitrate: 128\n    start_address: 0\n  - id: 1\n    bitrate: 128\n    start_address: 84\n  # ... up to 8 services\n</code></pre>"},{"location":"advanced/transmission-modes/#mode-ii-configuration","title":"Mode II Configuration","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  transmission_mode: 'II'\n  label:\n    text: 'Mobile DAB'\n\n# Can fit 3-5 services\nsubchannels:\n  - id: 0\n    bitrate: 96\n    start_address: 0\n  - id: 1\n    bitrate: 96\n    start_address: 63\n  # ... up to 5 services\n</code></pre>"},{"location":"advanced/transmission-modes/#runtime-mode-detection","title":"Runtime Mode Detection","text":"<pre><code>from dabmux.core.eti import TransmissionMode\n\n# Get mode from ensemble\nmode = ensemble.transmission_mode\n\n# Check mode\nif mode == TransmissionMode.TM_I:\n    print(\"Mode I: 96ms frames, 864 CU capacity\")\nelif mode == TransmissionMode.TM_II:\n    print(\"Mode II: 24ms frames, 432 CU capacity\")\n\n# Get frame properties\nframe_duration_ms = {\n    TransmissionMode.TM_I: 96,\n    TransmissionMode.TM_II: 24,\n    TransmissionMode.TM_III: 24,\n    TransmissionMode.TM_IV: 96\n}[mode]\n\nfic_size = {\n    TransmissionMode.TM_I: 96,\n    TransmissionMode.TM_II: 32,\n    TransmissionMode.TM_III: 32,\n    TransmissionMode.TM_IV: 32\n}[mode]\n</code></pre>"},{"location":"advanced/transmission-modes/#see-also","title":"See Also","text":"<ul> <li>Architecture: ETI Frames - Frame structure details</li> <li>Configuration: Subchannels - Capacity planning</li> <li>Core API - TransmissionMode enum</li> <li>ETSI EN 300 401 - Official specification</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for python-dabmux.</p>"},{"location":"api-reference/#overview","title":"Overview","text":"<p>python-dabmux is organized into several modules, each handling a specific aspect of DAB multiplexing:</p> <ul> <li>core: Core data structures (ETI frames, ensemble configuration)</li> <li>mux: Main multiplexer class (<code>DabMultiplexer</code>)</li> <li>config: Configuration parser and validation</li> <li>input: Input sources (file, UDP, TCP)</li> <li>output: Output destinations (ETI file, EDI network)</li> <li>fig: FIG (Fast Information Group) generation</li> <li>edi: EDI (Ensemble Data Interface) protocol</li> <li>audio: Audio frame parsing (MPEG Layer II, DAB+)</li> <li>fec: Forward error correction (Reed-Solomon)</li> <li>utils: Utility functions (CRC, charset, timestamps)</li> </ul>"},{"location":"api-reference/#quick-start","title":"Quick Start","text":""},{"location":"api-reference/#basic-usage","title":"Basic Usage","text":"<pre><code>from dabmux.config import load_config\nfrom dabmux.mux import DabMultiplexer\nfrom dabmux.output.file import FileOutput\n\n# Load configuration\nensemble = load_config('config.yaml')\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Generate ETI frame\nframe = mux.generate_frame()\n\n# Write to file\noutput = FileOutput()\noutput.open('output.eti')\noutput.write(frame.pack())\noutput.close()\n</code></pre>"},{"location":"api-reference/#creating-an-ensemble-programmatically","title":"Creating an Ensemble Programmatically","text":"<pre><code>from dabmux.core.mux_elements import DabEnsemble, DabService, DabSubchannel, DabComponent\nfrom dabmux.core.eti import TransmissionMode\n\n# Create ensemble\nensemble = DabEnsemble(\n    id=0xCE15,\n    ecc=0xE1,\n    transmission_mode=TransmissionMode.MODE_I,\n    label_text='My DAB',\n    label_short='DAB'\n)\n\n# Create subchannel\nsubchannel = DabSubchannel(\n    uid='audio1',\n    id=0,\n    bitrate=128,\n    start_address=0,\n    protection_level=2,\n    input_uri='file://audio.mp2'\n)\nensemble.add_subchannel(subchannel)\n\n# Create service\nservice = DabService(\n    uid='service1',\n    id=0x5001,\n    label_text='Radio One',\n    label_short='R1',\n    pty=10,  # Pop Music\n    language=9  # English\n)\nensemble.add_service(service)\n\n# Create component to link service and subchannel\ncomponent = DabComponent(\n    uid='comp1',\n    service_id=0x5001,\n    subchannel_id=0\n)\nensemble.add_component(component)\n</code></pre>"},{"location":"api-reference/#module-organization","title":"Module Organization","text":"<pre><code>dabmux/\n\u251c\u2500\u2500 audio/          # Audio frame parsing\n\u2502   \u251c\u2500\u2500 mpeg.py    # MPEG Layer II frame parser\n\u2502   \u2514\u2500\u2500 dabplus.py # DAB+ (HE-AAC) frame parser\n\u251c\u2500\u2500 config/         # Configuration\n\u2502   \u251c\u2500\u2500 parser.py  # YAML configuration parser\n\u2502   \u2514\u2500\u2500 schema.py  # Configuration validation\n\u251c\u2500\u2500 core/           # Core data structures\n\u2502   \u251c\u2500\u2500 eti.py     # ETI frame structures\n\u2502   \u2514\u2500\u2500 mux_elements.py  # Ensemble, service, subchannel\n\u251c\u2500\u2500 edi/            # EDI protocol\n\u2502   \u251c\u2500\u2500 encoder.py # EDI encoder\n\u2502   \u251c\u2500\u2500 tags.py    # EDI TAG items\n\u2502   \u2514\u2500\u2500 pft.py     # PFT (fragmentation + FEC)\n\u251c\u2500\u2500 fec/            # Forward error correction\n\u2502   \u2514\u2500\u2500 reed_solomon.py  # Reed-Solomon encoder\n\u251c\u2500\u2500 fig/            # FIG generation\n\u2502   \u251c\u2500\u2500 carousel.py  # FIG carousel\n\u2502   \u251c\u2500\u2500 fic.py      # FIC encoder\n\u2502   \u251c\u2500\u2500 fig0.py     # FIG Type 0 (MCI)\n\u2502   \u251c\u2500\u2500 fig1.py     # FIG Type 1 (Labels)\n\u2502   \u2514\u2500\u2500 fig5.py     # FIG Type 5 (FIDC)\n\u251c\u2500\u2500 input/          # Input sources\n\u2502   \u251c\u2500\u2500 base.py    # Abstract input base class\n\u2502   \u251c\u2500\u2500 file.py    # File input\n\u2502   \u2514\u2500\u2500 network.py # UDP/TCP network input\n\u251c\u2500\u2500 network/        # Network utilities\n\u2502   \u251c\u2500\u2500 udp.py     # UDP socket wrapper\n\u2502   \u2514\u2500\u2500 tcp.py     # TCP socket wrapper\n\u251c\u2500\u2500 output/         # Output destinations\n\u2502   \u251c\u2500\u2500 base.py    # Abstract output base class\n\u2502   \u251c\u2500\u2500 file.py    # ETI file output\n\u2502   \u2514\u2500\u2500 edi.py     # EDI network output\n\u251c\u2500\u2500 utils/          # Utilities\n\u2502   \u251c\u2500\u2500 crc.py     # CRC calculations\n\u2502   \u251c\u2500\u2500 charset.py # EBU Latin character set\n\u2502   \u251c\u2500\u2500 timestamp.py  # TIST timestamps\n\u2502   \u2514\u2500\u2500 stats.py   # Statistics tracking\n\u2514\u2500\u2500 mux.py          # Main multiplexer\n</code></pre>"},{"location":"api-reference/#type-annotations","title":"Type Annotations","text":"<p>python-dabmux uses comprehensive type annotations throughout the codebase. All public APIs have type hints that are validated with mypy.</p> <pre><code>from typing import Optional\nfrom dabmux.core.eti import EtiFrame\n\ndef generate_frame(\n    frame_number: int,\n    enable_tist: bool = False,\n    tist_offset: float = 0.0\n) -&gt; EtiFrame:\n    \"\"\"Generate an ETI frame.\"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>python-dabmux defines custom exceptions for different error types:</p> <pre><code>from dabmux.config import ConfigurationError\nfrom dabmux.core.eti import EtiError\nfrom dabmux.input.base import InputError\n\ntry:\n    ensemble = load_config('config.yaml')\nexcept ConfigurationError as e:\n    print(f\"Configuration error: {e}\")\n\ntry:\n    frame = mux.generate_frame()\nexcept EtiError as e:\n    print(f\"ETI generation error: {e}\")\n\ntry:\n    data = input_source.read_frame()\nexcept InputError as e:\n    print(f\"Input error: {e}\")\n</code></pre>"},{"location":"api-reference/#logging","title":"Logging","text":"<p>python-dabmux uses <code>structlog</code> for structured logging:</p> <pre><code>import structlog\n\nlogger = structlog.get_logger(__name__)\n\nlogger.info(\"Frame generated\",\n           frame_number=1234,\n           services=3,\n           size=6144)\n</code></pre>"},{"location":"api-reference/#configure-logging","title":"Configure Logging","text":"<pre><code>import logging\nimport structlog\n\n# Configure structlog\nstructlog.configure(\n    processors=[\n        structlog.processors.add_log_level,\n        structlog.processors.TimeStamper(fmt=\"iso\"),\n        structlog.dev.ConsoleRenderer()\n    ],\n    wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),\n    context_class=dict,\n    logger_factory=structlog.PrintLoggerFactory(),\n)\n</code></pre>"},{"location":"api-reference/#testing","title":"Testing","text":"<p>python-dabmux has comprehensive test coverage (71% overall, 90-100% for core modules).</p>"},{"location":"api-reference/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=dabmux --cov-report=term-missing\n\n# Run specific module tests\npytest tests/unit/test_eti.py\npytest tests/unit/fig/\n</code></pre>"},{"location":"api-reference/#writing-tests","title":"Writing Tests","text":"<pre><code>import pytest\nfrom dabmux.core.eti import EtiFrame, TransmissionMode\n\ndef test_eti_frame_creation():\n    \"\"\"Test ETI frame creation.\"\"\"\n    frame = EtiFrame(\n        mode=TransmissionMode.MODE_I,\n        frame_number=0\n    )\n    assert frame.mode == TransmissionMode.MODE_I\n    assert frame.frame_number == 0\n    assert len(frame.pack()) == 6144\n</code></pre>"},{"location":"api-reference/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api-reference/#memory-usage","title":"Memory Usage","text":"<ul> <li>ETI frames: 6144 bytes per frame (Mode I)</li> <li>FIG carousel: ~10 KB for typical ensemble</li> <li>Input buffers: Configurable per input source</li> <li>Total: Typically &lt; 50 MB for typical ensemble</li> </ul>"},{"location":"api-reference/#cpu-usage","title":"CPU Usage","text":"<ul> <li>Frame generation: 10-20% of one CPU core @ 10.4 fps (Mode I)</li> <li>FIG generation: &lt; 5% overhead</li> <li>PFT with FEC: +10-15% overhead</li> <li>Total: Suitable for Raspberry Pi 3+</li> </ul>"},{"location":"api-reference/#optimization-tips","title":"Optimization Tips","text":"<ol> <li> <p>Use generator pattern for continuous operation: <pre><code>while True:\n    frame = mux.generate_frame()\n    output.write(frame.pack())\n</code></pre></p> </li> <li> <p>Reuse buffers where possible: <pre><code>frame_buffer = bytearray(6144)\nframe.pack_into(frame_buffer)\n</code></pre></p> </li> <li> <p>Minimize FIG types: <pre><code># Only generate essential FIGs\nfic_encoder.enable_fig_types([0, 1])\n</code></pre></p> </li> </ol>"},{"location":"api-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"api-reference/#continuous-multiplexing","title":"Continuous Multiplexing","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.output.file import FileOutput\nimport signal\n\nrunning = True\n\ndef signal_handler(sig, frame):\n    global running\n    running = False\n\nsignal.signal(signal.SIGINT, signal_handler)\n\nmux = DabMultiplexer(ensemble)\noutput = FileOutput()\noutput.open('output.eti')\n\ntry:\n    while running:\n        frame = mux.generate_frame()\n        output.write(frame.pack())\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/#network-streaming","title":"Network Streaming","text":"<pre><code>from dabmux.output.edi import EdiOutput\nfrom dabmux.edi.pft import PFTConfig\n\n# Configure PFT with FEC\npft_config = PFTConfig(\n    fec=True,\n    fec_m=2,\n    max_fragment_size=1400\n)\n\n# Create EDI output\noutput = EdiOutput(\n    dest_addr='239.1.2.3',\n    dest_port=12000,\n    enable_pft=True,\n    pft_config=pft_config\n)\n\noutput.open()\ntry:\n    while running:\n        frame = mux.generate_frame()\n        # EDI encoding happens internally\n        output.write_frame(frame)\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/#custom-input-source","title":"Custom Input Source","text":"<pre><code>from dabmux.input.base import InputSource\nfrom typing import Optional\n\nclass CustomInput(InputSource):\n    \"\"\"Custom input source implementation.\"\"\"\n\n    def open(self) -&gt; None:\n        \"\"\"Open input source.\"\"\"\n        # Initialize your source\n        pass\n\n    def close(self) -&gt; None:\n        \"\"\"Close input source.\"\"\"\n        # Cleanup\n        pass\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        \"\"\"Read one audio frame.\"\"\"\n        # Return frame data or None if no data available\n        return self._get_next_frame()\n\n    def seek(self, position: int) -&gt; None:\n        \"\"\"Seek to position (optional).\"\"\"\n        pass\n</code></pre>"},{"location":"api-reference/#see-also","title":"See Also","text":"<ul> <li>User Guide: High-level usage documentation</li> <li>Tutorials: Step-by-step guides</li> <li>Architecture: System design and diagrams</li> <li>Development: Contributing guidelines</li> </ul>"},{"location":"api-reference/config/","title":"Configuration Module","text":"<p>Configuration file parsing and validation.</p>"},{"location":"api-reference/config/#module-dabmuxconfig","title":"Module: <code>dabmux.config</code>","text":"<p>Provides utilities for loading and parsing YAML configuration files into <code>DabEnsemble</code> objects.</p>"},{"location":"api-reference/config/#functions","title":"Functions","text":""},{"location":"api-reference/config/#load_configpath-str-path-dabensemble","title":"<code>load_config(path: str | Path) -&gt; DabEnsemble</code>","text":"<p>Load ensemble configuration from YAML file.</p> <p>Parameters: - <code>path: str | Path</code> - Path to YAML configuration file</p> <p>Returns: <code>DabEnsemble</code> instance with all services, subchannels, and components configured</p> <p>Raises: - <code>FileNotFoundError</code> - If configuration file doesn't exist - <code>ConfigurationError</code> - If configuration is invalid - <code>yaml.YAMLError</code> - If YAML syntax is invalid</p> <p>Example: <pre><code>from dabmux.config import load_config\n\nensemble = load_config('config.yaml')\nprint(f\"Loaded ensemble: {ensemble.label.text}\")\nprint(f\"Services: {len(ensemble.services)}\")\nprint(f\"Subchannels: {len(ensemble.subchannels)}\")\n</code></pre></p>"},{"location":"api-reference/config/#configuration-file-format","title":"Configuration File Format","text":"<p>YAML configuration with four main sections:</p> <pre><code>ensemble:           # Ensemble configuration\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'My DAB'\n    short: 'DAB'\n  lto_auto: true\n\nsubchannels:        # Audio/data streams\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://audio.mp2'\n\nservices:           # Radio stations\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n      short: 'R1'\n    pty: 10\n    language: 9\n\ncomponents:         # Service \u2194 Subchannel links\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n    type: 0\n</code></pre>"},{"location":"api-reference/config/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/config/#configurationerror","title":"<code>ConfigurationError</code>","text":"<p>Raised when configuration validation fails.</p> <p>Base class: <code>Exception</code></p> <p>Common causes: - Missing required fields - Invalid hex values - Unknown transmission mode - Invalid protection level - Missing service or subchannel references</p> <p>Example: <pre><code>from dabmux.config import load_config, ConfigurationError\n\ntry:\n    ensemble = load_config('config.yaml')\nexcept ConfigurationError as e:\n    print(f\"Configuration error: {e}\")\n    # Fix configuration and retry\n</code></pre></p>"},{"location":"api-reference/config/#configuration-validation","title":"Configuration Validation","text":"<p>The parser validates:</p>"},{"location":"api-reference/config/#ensemble-section","title":"Ensemble Section","text":"<ul> <li>\u2705 <code>id</code> must be hex string (e.g., '0xCE15')</li> <li>\u2705 <code>ecc</code> must be hex string (e.g., '0xE1')</li> <li>\u2705 <code>transmission_mode</code> must be 'I', 'II', 'III', or 'IV'</li> <li>\u2705 <code>label.text</code> max 16 characters</li> <li>\u2705 <code>label.short</code> max 8 characters</li> </ul>"},{"location":"api-reference/config/#subchannels-section","title":"Subchannels Section","text":"<ul> <li>\u2705 <code>uid</code> must be unique string</li> <li>\u2705 <code>id</code> must be 0-63</li> <li>\u2705 <code>type</code> must be 'audio', 'dabplus', 'dmb', or 'packet'</li> <li>\u2705 <code>bitrate</code> must be valid for type (32-384 kbps)</li> <li>\u2705 <code>protection.level</code> must be 0-4</li> <li>\u2705 <code>input</code> must be valid URI (file://, udp://, tcp://)</li> </ul>"},{"location":"api-reference/config/#services-section","title":"Services Section","text":"<ul> <li>\u2705 <code>uid</code> must be unique string</li> <li>\u2705 <code>id</code> must be hex string (e.g., '0x5001')</li> <li>\u2705 <code>label.text</code> max 16 characters</li> <li>\u2705 <code>label.short</code> max 8 characters</li> <li>\u2705 <code>pty</code> must be 0-31</li> <li>\u2705 <code>language</code> must be 0-127</li> </ul>"},{"location":"api-reference/config/#components-section","title":"Components Section","text":"<ul> <li>\u2705 <code>service_id</code> must reference existing service</li> <li>\u2705 <code>subchannel_id</code> must reference existing subchannel</li> <li>\u2705 <code>type</code> must be 0 (audio) or 1 (data)</li> </ul>"},{"location":"api-reference/config/#examples","title":"Examples","text":""},{"location":"api-reference/config/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'Test'\n\nsubchannels:\n  - uid: 'sub1'\n    id: 0\n    bitrate: 128\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'svc1'\n    id: '0x5001'\n    label:\n      text: 'Test'\n\ncomponents:\n  - service_id: '0x5001'\n    subchannel_id: 0\n</code></pre> <p>Load and verify: <pre><code>from dabmux.config import load_config\n\nensemble = load_config('minimal.yaml')\nassert ensemble.id == 0xCE15\nassert len(ensemble.services) == 1\nassert len(ensemble.subchannels) == 1\n</code></pre></p>"},{"location":"api-reference/config/#multi-service-configuration","title":"Multi-Service Configuration","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Multi Service'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file://music.mp2'\n\n  - uid: 'audio2'\n    id: 1\n    type: 'audio'\n    bitrate: 96\n    start_address: 84\n    input: 'file://news.mp2'\n\n  - uid: 'audio3'\n    id: 2\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 168\n    input: 'file://speech.aac'\n\nservices:\n  - uid: 'music'\n    id: '0x5001'\n    label:\n      text: 'Music FM'\n    pty: 10  # Pop Music\n\n  - uid: 'news'\n    id: '0x5002'\n    label:\n      text: 'News 24'\n    pty: 1  # News\n\n  - uid: 'talk'\n    id: '0x5003'\n    label:\n      text: 'Talk Radio'\n    pty: 9  # Varied Speech\n\ncomponents:\n  - service_id: '0x5001'\n    subchannel_id: 0\n  - service_id: '0x5002'\n    subchannel_id: 1\n  - service_id: '0x5003'\n    subchannel_id: 2\n</code></pre> <p>Load and inspect: <pre><code>from dabmux.config import load_config\n\nensemble = load_config('multi_service.yaml')\n\n# List all services\nfor service in ensemble.services:\n    print(f\"{service.label.text} (ID: 0x{service.id:04X})\")\n\n# List all subchannels\nfor subchannel in ensemble.subchannels:\n    print(f\"Subchannel {subchannel.id}: {subchannel.bitrate} kbps\")\n</code></pre></p>"},{"location":"api-reference/config/#network-input-configuration","title":"Network Input Configuration","text":"<pre><code>subchannels:\n  - uid: 'live1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'udp://239.1.2.3:5001'  # UDP multicast\n\n  - uid: 'live2'\n    id: 1\n    type: 'audio'\n    bitrate: 128\n    input: 'tcp://192.168.1.100:5002'  # TCP stream\n</code></pre>"},{"location":"api-reference/config/#dab-configuration","title":"DAB+ Configuration","text":"<pre><code>subchannels:\n  - uid: 'dabplus1'\n    id: 0\n    type: 'dabplus'      # HE-AAC v2\n    bitrate: 72          # Lower bitrate than DAB\n    protection:\n      level: 2\n    input: 'file://audio.aac'  # AAC file, not MP2\n</code></pre>"},{"location":"api-reference/config/#hex-value-handling","title":"Hex Value Handling","text":"<p>All hex values must be quoted strings with <code>0x</code> prefix:</p> <p>Correct: <pre><code>ensemble:\n  id: '0xCE15'    # String with 0x prefix\n  ecc: '0xE1'\n\nservices:\n  - id: '0x5001'  # String with 0x prefix\n</code></pre></p> <p>Incorrect: <pre><code>ensemble:\n  id: 0xCE15      # Unquoted (parsed as integer)\n  ecc: E1         # No 0x prefix\n\nservices:\n  - id: 5001      # Decimal integer\n</code></pre></p>"},{"location":"api-reference/config/#uri-schemes","title":"URI Schemes","text":"<p>Input URIs support three schemes:</p>"},{"location":"api-reference/config/#file-uri","title":"File URI","text":"<pre><code>input: 'file://audio.mp2'              # Relative path\ninput: 'file:///path/to/audio.mp2'     # Absolute path\n</code></pre>"},{"location":"api-reference/config/#udp-uri","title":"UDP URI","text":"<pre><code>input: 'udp://239.1.2.3:5001'          # Multicast\ninput: 'udp://192.168.1.100:5001'      # Unicast\ninput: 'udp://0.0.0.0:5001'            # Listen on all interfaces\n</code></pre>"},{"location":"api-reference/config/#tcp-uri","title":"TCP URI","text":"<pre><code>input: 'tcp://192.168.1.100:5001'      # Connect to server\ninput: 'tcp://0.0.0.0:5001'            # Listen for connections\n</code></pre>"},{"location":"api-reference/config/#default-values","title":"Default Values","text":"<p>If not specified, these defaults are used:</p> <pre><code>ensemble:\n  ecc: '0xE1'                # Germany\n  transmission_mode: 'I'     # Mode I\n  lto_auto: true            # Automatic local time offset\n\nsubchannels:\n  type: 'audio'             # MPEG Layer II\n  start_address: 0          # Auto-calculated\n  protection:\n    level: 2                # Moderate protection\n    shortform: true         # UEP (Unequal Error Protection)\n\nservices:\n  pty: 0                    # No programme type\n  language: 9               # English\n  country_id: 0             # From ensemble ECC\n\ncomponents:\n  type: 0                   # Audio component\n</code></pre>"},{"location":"api-reference/config/#configuration-tips","title":"Configuration Tips","text":""},{"location":"api-reference/config/#1-use-descriptive-uids","title":"1. Use Descriptive UIDs","text":"<pre><code># Good\nsubchannels:\n  - uid: 'music_128kbps'\n  - uid: 'news_96kbps'\n\n# Bad\nsubchannels:\n  - uid: 'sub1'\n  - uid: 'sub2'\n</code></pre>"},{"location":"api-reference/config/#2-calculate-start-addresses","title":"2. Calculate Start Addresses","text":"<p>For Mode I (864 CU total capacity):</p> <pre><code>subchannels:\n  - id: 0\n    bitrate: 128\n    start_address: 0      # First subchannel\n\n  - id: 1\n    bitrate: 96\n    start_address: 84     # After first (128 kbps \u2248 84 CU)\n\n  - id: 2\n    bitrate: 64\n    start_address: 147    # After second (96 kbps \u2248 63 CU)\n</code></pre> <p>Or use <code>start_address: 0</code> for all and let the multiplexer calculate automatically.</p>"},{"location":"api-reference/config/#3-match-service-ids-with-components","title":"3. Match Service IDs with Components","text":"<pre><code>services:\n  - uid: 'radio1'\n    id: '0x5001'        # Remember this ID\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'  # Must match service ID\n    subchannel_id: 0      # Links to subchannel 0\n</code></pre>"},{"location":"api-reference/config/#4-use-comments-liberally","title":"4. Use Comments Liberally","text":"<pre><code>ensemble:\n  id: '0xCE15'          # Custom ensemble ID for testing\n  ecc: '0xE1'           # Germany (0xE1)\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    bitrate: 128        # Standard music quality\n    input: 'file://music.mp2'  # Looping background music\n</code></pre>"},{"location":"api-reference/config/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference - Complete configuration guide</li> <li>Core API - DabEnsemble and related classes</li> <li>Examples - More configuration examples</li> <li>Troubleshooting - Configuration error solutions</li> </ul>"},{"location":"api-reference/core/","title":"Core Module","text":"<p>Core data structures for ETI frames and ensemble configuration.</p>"},{"location":"api-reference/core/#module-dabmuxcoreeti","title":"Module: <code>dabmux.core.eti</code>","text":"<p>ETI (Ensemble Transport Interface) frame structures with binary-accurate layout.</p>"},{"location":"api-reference/core/#classes","title":"Classes","text":""},{"location":"api-reference/core/#etiframe","title":"<code>EtiFrame</code>","text":"<p>Complete ETI frame structure (6144 bytes for Mode I).</p> <pre><code>from dabmux.core.eti import EtiFrame, TransmissionMode\n\nframe = EtiFrame.create_empty(\n    mode=TransmissionMode.MODE_I,\n    with_tist=True\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>sync: EtiSync</code> - SYNC header (4 bytes)</li> <li><code>fc: EtiFC</code> - Frame characterization (4 bytes)</li> <li><code>stc_headers: List[EtiSTC]</code> - Subchannel headers (4 bytes each)</li> <li><code>eoh: EtiEOH</code> - End of header (4 bytes)</li> <li><code>fic_data: bytes</code> - Fast Information Channel data (96/32 bytes depending on mode)</li> <li><code>mst_data: bytes</code> - Main Service Channel data (variable)</li> <li><code>eof: EtiEOF</code> - End of frame (4 bytes)</li> <li><code>tist: Optional[EtiTIST]</code> - Timestamp (4 bytes, optional)</li> </ul> <p>Methods:</p>"},{"location":"api-reference/core/#create_emptymode-int-with_tist-bool-false-etiframe","title":"<code>create_empty(mode: int, with_tist: bool = False) -&gt; EtiFrame</code>","text":"<p>Create an empty ETI frame for the given transmission mode.</p> <p>Parameters: - <code>mode: int</code> - Transmission mode (1=Mode I, 2=Mode II, 3=Mode III, 4=Mode IV) - <code>with_tist: bool</code> - Include TIST field (default: False)</p> <p>Returns: Empty <code>EtiFrame</code> with correct size for mode</p> <p>Example: <pre><code>frame = EtiFrame.create_empty(mode=1, with_tist=True)\nassert len(frame.pack()) == 6148  # 6144 + 4 for TIST\n</code></pre></p>"},{"location":"api-reference/core/#pack-bytes","title":"<code>pack() -&gt; bytes</code>","text":"<p>Serialize frame to binary format.</p> <p>Returns: Complete ETI frame as bytes (6144 or 6148 bytes with TIST)</p> <p>Example: <pre><code>frame_bytes = frame.pack()\nwith open('output.eti', 'wb') as f:\n    f.write(frame_bytes)\n</code></pre></p>"},{"location":"api-reference/core/#pack_intobuffer-bytearray-none","title":"<code>pack_into(buffer: bytearray) -&gt; None</code>","text":"<p>Pack frame directly into a pre-allocated buffer (zero-copy).</p> <p>Parameters: - <code>buffer: bytearray</code> - Target buffer (must be at least 6144 bytes)</p> <p>Example: <pre><code>buffer = bytearray(6144)\nframe.pack_into(buffer)\nsocket.send(buffer)  # Zero-copy send\n</code></pre></p>"},{"location":"api-reference/core/#etisync","title":"<code>EtiSync</code>","text":"<p>ETI SYNC header (4 bytes).</p> <p>Binary Layout: <pre><code>Bits 0-7:   ERR   (Error indicator)\nBits 8-31:  FSYNC (Frame sync word, constant 0x49C5F8)\n</code></pre></p> <p>Attributes:</p> <ul> <li><code>err: int</code> - Error indicator (0xFF = no error)</li> <li><code>fsync: int</code> - Frame sync word (constant <code>0x49C5F8</code>)</li> </ul> <p>Methods:</p> <ul> <li><code>pack() -&gt; bytes</code> - Pack to 4 bytes (little-endian)</li> <li><code>unpack(data: bytes) -&gt; EtiSync</code> - Unpack from 4 bytes (class method)</li> </ul> <p>Example: <pre><code>from dabmux.core.eti import EtiSync\n\nsync = EtiSync(err=0xFF, fsync=0x49C5F8)\npacked = sync.pack()\nassert len(packed) == 4\n</code></pre></p>"},{"location":"api-reference/core/#etifc","title":"<code>EtiFC</code>","text":"<p>Frame Characterization (4 bytes).</p> <p>Binary Layout: <pre><code>Bits 0-7:   FCT     (Frame count, 0-255)\nBits 8-14:  NST     (Number of subchannels, 0-64)\nBit 15:     FICF    (FIC flag, always 1)\nBits 16-18: FL_high (Frame length high 3 bits)\nBits 19-20: MID     (Transmission mode)\nBits 21-23: FP      (Frame phase, 0-7)\nBits 24-31: FL_low  (Frame length low 8 bits)\n</code></pre></p> <p>Attributes:</p> <ul> <li><code>fct: int</code> - Frame count (0-255, wraps around)</li> <li><code>nst: int</code> - Number of subchannels (0-64)</li> <li><code>ficf: int</code> - FIC flag (always 1)</li> <li><code>mid: int</code> - Transmission mode (1=Mode I, 2=Mode II, 3=Mode III, 4=Mode IV)</li> <li><code>fp: int</code> - Frame phase (0-7)</li> <li><code>fl: int</code> - Frame length in 64-bit words (11 bits, 0-2047)</li> </ul> <p>Methods:</p> <ul> <li><code>get_frame_length() -&gt; int</code> - Get 11-bit frame length</li> <li><code>set_frame_length(length: int) -&gt; None</code> - Set 11-bit frame length</li> <li><code>pack() -&gt; bytes</code> - Pack to 4 bytes</li> <li><code>unpack(data: bytes) -&gt; EtiFC</code> - Unpack from 4 bytes (class method)</li> </ul> <p>Example: <pre><code>from dabmux.core.eti import EtiFC\n\nfc = EtiFC(fct=42, nst=3, mid=1, fl=96)\nassert fc.get_frame_length() == 96\n</code></pre></p>"},{"location":"api-reference/core/#etistc","title":"<code>EtiSTC</code>","text":"<p>Sub-Channel header (4 bytes).</p> <p>Binary Layout: <pre><code>Bits 0-1:   startAddress_high (Start address high 2 bits)\nBits 2-7:   SCID              (Subchannel ID, 0-63)\nBits 8-15:  startAddress_low  (Start address low 8 bits)\nBits 16-17: STL_high          (Length high 2 bits)\nBits 18-23: TPL               (Protection level)\nBits 24-31: STL_low           (Length low 8 bits)\n</code></pre></p> <p>Attributes:</p> <ul> <li><code>scid: int</code> - Subchannel ID (0-63)</li> <li><code>start_address: int</code> - Start address in CU (Capacity Units, 10 bits, 0-1023)</li> <li><code>tpl: int</code> - Protection level (6 bits)</li> <li><code>stl: int</code> - Subchannel length in 64-bit words (10 bits, 0-1023)</li> </ul> <p>Methods:</p> <ul> <li><code>get_stl() -&gt; int</code> - Get 10-bit subchannel length</li> <li><code>set_stl(length: int) -&gt; None</code> - Set 10-bit subchannel length</li> <li><code>get_start_address() -&gt; int</code> - Get 10-bit start address</li> <li><code>set_start_address(address: int) -&gt; None</code> - Set 10-bit start address</li> <li><code>pack() -&gt; bytes</code> - Pack to 4 bytes</li> <li><code>unpack(data: bytes) -&gt; EtiSTC</code> - Unpack from 4 bytes (class method)</li> </ul> <p>Example: <pre><code>from dabmux.core.eti import EtiSTC\n\nstc = EtiSTC(scid=0, start_address=0, tpl=0x10, stl=84)\n</code></pre></p>"},{"location":"api-reference/core/#etieoh","title":"<code>EtiEOH</code>","text":"<p>End of Header (4 bytes).</p> <p>Binary Layout: <pre><code>Bits 0-15:  (reserved, set to 0xFFFF)\nBits 16-31: CRC (CRC-16 of SYNC + FC + STC headers)\n</code></pre></p> <p>Attributes:</p> <ul> <li><code>crc: int</code> - CRC-16 checksum (16 bits)</li> </ul> <p>Methods:</p> <ul> <li><code>pack() -&gt; bytes</code> - Pack to 4 bytes</li> <li><code>unpack(data: bytes) -&gt; EtiEOH</code> - Unpack from 4 bytes (class method)</li> </ul>"},{"location":"api-reference/core/#etieof","title":"<code>EtiEOF</code>","text":"<p>End of Frame (4 bytes).</p> <p>Binary Layout: <pre><code>Bits 0-15:  CRC (CRC-16 of FIC + MST data)\nBits 16-31: RFU (Reserved for future use, set to 0xFFFF)\n</code></pre></p> <p>Attributes:</p> <ul> <li><code>crc: int</code> - CRC-16 checksum (16 bits)</li> <li><code>rfu: int</code> - Reserved (16 bits, always <code>0xFFFF</code>)</li> </ul> <p>Methods:</p> <ul> <li><code>pack() -&gt; bytes</code> - Pack to 4 bytes</li> <li><code>unpack(data: bytes) -&gt; EtiEOF</code> - Unpack from 4 bytes (class method)</li> </ul>"},{"location":"api-reference/core/#etitist","title":"<code>EtiTIST</code>","text":"<p>Timestamp (4 bytes, optional).</p> <p>Binary Layout: <pre><code>Bits 0-31:  TIST (Timestamp in 16.384 MHz ticks)\n</code></pre></p> <p>Attributes:</p> <ul> <li><code>tist: int</code> - Timestamp value (32 bits)</li> </ul> <p>Methods:</p> <ul> <li><code>pack() -&gt; bytes</code> - Pack to 4 bytes</li> <li><code>unpack(data: bytes) -&gt; EtiTIST</code> - Unpack from 4 bytes (class method)</li> <li><code>from_datetime(dt: datetime) -&gt; EtiTIST</code> - Create from Python datetime (class method)</li> </ul> <p>Example: <pre><code>from dabmux.core.eti import EtiTIST\nfrom datetime import datetime\n\ntist = EtiTIST.from_datetime(datetime.now())\ntist_bytes = tist.pack()\n</code></pre></p>"},{"location":"api-reference/core/#enums","title":"Enums","text":""},{"location":"api-reference/core/#transmissionmode","title":"<code>TransmissionMode</code>","text":"<p>DAB transmission modes.</p> <pre><code>class TransmissionMode(IntEnum):\n    MODE_I = 1    # Mode I (most common)\n    MODE_II = 2   # Mode II\n    MODE_III = 3  # Mode III\n    MODE_IV = 4   # Mode IV\n</code></pre> <p>Mode characteristics:</p> Mode FIC Size Frame Duration Capacity (CU) I 96 bytes 96 ms 864 II 32 bytes 24 ms 432 III 32 bytes 24 ms 864 IV 32 bytes 96 ms 432"},{"location":"api-reference/core/#module-dabmuxcoremux_elements","title":"Module: <code>dabmux.core.mux_elements</code>","text":"<p>Ensemble configuration elements (services, subchannels, components).</p>"},{"location":"api-reference/core/#classes_1","title":"Classes","text":""},{"location":"api-reference/core/#dabensemble","title":"<code>DabEnsemble</code>","text":"<p>DAB ensemble configuration (top-level container).</p> <pre><code>from dabmux.core.mux_elements import DabEnsemble, TransmissionMode\n\nensemble = DabEnsemble(\n    id=0xCE15,\n    ecc=0xE1,\n    transmission_mode=TransmissionMode.TM_I,\n    label_text='My DAB',\n    label_short='DAB'\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>id: int</code> - Ensemble ID (16 bits, e.g., <code>0xCE15</code>)</li> <li><code>ecc: int</code> - Extended Country Code (8 bits, e.g., <code>0xE1</code> for Germany)</li> <li><code>transmission_mode: TransmissionMode</code> - Transmission mode (I, II, III, or IV)</li> <li><code>label: DabLabel</code> - Ensemble label (text + short)</li> <li><code>services: List[DabService]</code> - List of services in ensemble</li> <li><code>subchannels: List[DabSubchannel]</code> - List of subchannels</li> <li><code>components: List[DabComponent]</code> - List of components (service\u2194subchannel links)</li> <li><code>lto_auto: bool</code> - Automatic local time offset (default: True)</li> </ul> <p>Methods:</p>"},{"location":"api-reference/core/#add_serviceservice-dabservice-none","title":"<code>add_service(service: DabService) -&gt; None</code>","text":"<p>Add a service to the ensemble.</p> <p>Parameters: - <code>service: DabService</code> - Service to add</p> <p>Raises: - <code>ValueError</code> - If service with same ID already exists</p>"},{"location":"api-reference/core/#add_subchannelsubchannel-dabsubchannel-none","title":"<code>add_subchannel(subchannel: DabSubchannel) -&gt; None</code>","text":"<p>Add a subchannel to the ensemble.</p> <p>Parameters: - <code>subchannel: DabSubchannel</code> - Subchannel to add</p> <p>Raises: - <code>ValueError</code> - If subchannel with same ID already exists</p>"},{"location":"api-reference/core/#add_componentcomponent-dabcomponent-none","title":"<code>add_component(component: DabComponent) -&gt; None</code>","text":"<p>Add a component (links service to subchannel).</p> <p>Parameters: - <code>component: DabComponent</code> - Component to add</p>"},{"location":"api-reference/core/#get_serviceuid-str-optionaldabservice","title":"<code>get_service(uid: str) -&gt; Optional[DabService]</code>","text":"<p>Get service by UID.</p> <p>Parameters: - <code>uid: str</code> - Service UID</p> <p>Returns: Service instance or None</p>"},{"location":"api-reference/core/#get_subchanneluid-str-optionaldabsubchannel","title":"<code>get_subchannel(uid: str) -&gt; Optional[DabSubchannel]</code>","text":"<p>Get subchannel by UID.</p> <p>Parameters: - <code>uid: str</code> - Subchannel UID</p> <p>Returns: Subchannel instance or None</p>"},{"location":"api-reference/core/#dabservice","title":"<code>DabService</code>","text":"<p>DAB service (radio station).</p> <pre><code>from dabmux.core.mux_elements import DabService\n\nservice = DabService(\n    uid='service1',\n    id=0x5001,\n    label_text='Radio One',\n    label_short='R1',\n    pty=10,  # Pop Music\n    language=9  # English\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>uid: str</code> - Unique identifier (internal use)</li> <li><code>id: int</code> - Service ID (16 bits, e.g., <code>0x5001</code>)</li> <li><code>label: DabLabel</code> - Service label (text + short)</li> <li><code>pty: int</code> - Programme Type (0-31)</li> <li><code>language: int</code> - Language code (0-127, 9=English)</li> <li><code>country_id: int</code> - Country ID (default: 0)</li> </ul> <p>Programme Types (PTY):</p> Value Type 0 None/Undefined 1 News 10 Pop Music 14 Serious Classical 16 Weather 29 Documentary <p>See full PTY list</p>"},{"location":"api-reference/core/#dabsubchannel","title":"<code>DabSubchannel</code>","text":"<p>DAB subchannel (data stream).</p> <pre><code>from dabmux.core.mux_elements import DabSubchannel, SubchannelType\n\nsubchannel = DabSubchannel(\n    uid='audio1',\n    id=0,\n    type=SubchannelType.DABAudio,\n    bitrate=128,\n    start_address=0,\n    protection_level=2,\n    input_uri='file://audio.mp2'\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>uid: str</code> - Unique identifier</li> <li><code>id: int</code> - Subchannel ID (0-63)</li> <li><code>type: SubchannelType</code> - Content type (audio, dabplus, dmb, packet)</li> <li><code>bitrate: int</code> - Bitrate in kbps (32-384)</li> <li><code>start_address: int</code> - Start address in Capacity Units (0-863 for Mode I)</li> <li><code>protection_level: int</code> - Protection level (0-4, higher = stronger)</li> <li><code>input_uri: str</code> - Input source URI (file://, udp://, tcp://)</li> </ul> <p>Subchannel Types:</p> <pre><code>class SubchannelType(Enum):\n    DABAudio = \"audio\"        # MPEG Layer II\n    DABPlusAudio = \"dabplus\"  # HE-AAC v2\n    DataDmb = \"dmb\"          # Data (DMB)\n    Packet = \"packet\"        # Packet mode data\n</code></pre>"},{"location":"api-reference/core/#dabcomponent","title":"<code>DabComponent</code>","text":"<p>Component (links service to subchannel).</p> <pre><code>from dabmux.core.mux_elements import DabComponent\n\ncomponent = DabComponent(\n    uid='comp1',\n    service_id=0x5001,\n    subchannel_id=0,\n    type=0  # Audio\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>uid: str</code> - Unique identifier</li> <li><code>service_id: int</code> - Service ID (16 bits)</li> <li><code>subchannel_id: int</code> - Subchannel ID (0-63)</li> <li><code>type: int</code> - Component type (0=Audio, 1=Data)</li> </ul>"},{"location":"api-reference/core/#dablabel","title":"<code>DabLabel</code>","text":"<p>DAB label (ensemble/service name).</p> <pre><code>from dabmux.core.mux_elements import DabLabel\n\nlabel = DabLabel(\n    text='My Radio Station',  # Max 16 chars\n    short='MyRadio'            # Max 8 chars\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>text: str</code> - Long label (max 16 characters)</li> <li><code>short: str</code> - Short label (max 8 characters)</li> </ul> <p>Character encoding: EBU Latin charset (subset of UTF-8 for common European characters)</p>"},{"location":"api-reference/core/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/core/#creating-an-ensemble","title":"Creating an Ensemble","text":"<pre><code>from dabmux.core.mux_elements import (\n    DabEnsemble, DabService, DabSubchannel, DabComponent,\n    SubchannelType, TransmissionMode\n)\n\n# Create ensemble\nensemble = DabEnsemble(\n    id=0xCE15,\n    ecc=0xE1,\n    transmission_mode=TransmissionMode.TM_I,\n    label_text='My DAB Network',\n    label_short='DAB'\n)\n\n# Add subchannel (audio stream)\nsubchannel = DabSubchannel(\n    uid='audio1',\n    id=0,\n    type=SubchannelType.DABAudio,\n    bitrate=128,\n    start_address=0,\n    protection_level=2,\n    input_uri='file://audio.mp2'\n)\nensemble.add_subchannel(subchannel)\n\n# Add service (radio station)\nservice = DabService(\n    uid='service1',\n    id=0x5001,\n    label_text='Radio One',\n    label_short='R1',\n    pty=10,\n    language=9\n)\nensemble.add_service(service)\n\n# Link service to subchannel\ncomponent = DabComponent(\n    uid='comp1',\n    service_id=0x5001,\n    subchannel_id=0,\n    type=0\n)\nensemble.add_component(component)\n</code></pre>"},{"location":"api-reference/core/#generating-eti-frames","title":"Generating ETI Frames","text":"<pre><code>from dabmux.core.eti import EtiFrame\n\n# Create empty frame\nframe = EtiFrame.create_empty(mode=1, with_tist=False)\n\n# Set frame count\nframe.fc.fct = 42\nframe.fc.nst = 3  # 3 subchannels\n\n# Add FIC data (96 bytes for Mode I)\nframe.fic_data = b'\\x00' * 96\n\n# Add MST data (main service channel)\nframe.mst_data = b'\\x00' * 5760\n\n# Serialize to binary\nframe_bytes = frame.pack()\nassert len(frame_bytes) == 6144\n</code></pre>"},{"location":"api-reference/core/#parsing-eti-frames","title":"Parsing ETI Frames","text":"<pre><code>from dabmux.core.eti import EtiFrame, EtiSync, EtiFC\n\n# Read frame from file\nwith open('input.eti', 'rb') as f:\n    frame_data = f.read(6144)\n\n# Parse SYNC header\nsync = EtiSync.unpack(frame_data[0:4])\nassert sync.fsync == 0x49C5F8\n\n# Parse FC header\nfc = EtiFC.unpack(frame_data[4:8])\nprint(f\"Frame {fc.fct}, Mode {fc.mid}, {fc.nst} subchannels\")\n</code></pre>"},{"location":"api-reference/core/#see-also","title":"See Also","text":"<ul> <li>Architecture: ETI Frames - Detailed frame structure diagrams</li> <li>Configuration Reference - YAML configuration</li> <li>Mux API - DabMultiplexer class</li> <li>Standards - ETSI EN 300 799 compliance</li> </ul>"},{"location":"api-reference/input/","title":"Input Module","text":"<p>Input sources for audio and data streams.</p>"},{"location":"api-reference/input/#module-dabmuxinput","title":"Module: <code>dabmux.input</code>","text":"<p>Provides input source implementations for reading audio/data from files and network.</p>"},{"location":"api-reference/input/#base-class-inputbase","title":"Base Class: <code>InputBase</code>","text":"<p>Abstract base class for all input sources.</p>"},{"location":"api-reference/input/#module-dabmuxinputbase","title":"Module: <code>dabmux.input.base</code>","text":"<pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional\n\nclass InputBase(ABC):\n    \"\"\"Abstract base class for input sources.\"\"\"\n\n    @abstractmethod\n    def open(self) -&gt; None:\n        \"\"\"Open the input source.\"\"\"\n        pass\n\n    @abstractmethod\n    def close(self) -&gt; None:\n        \"\"\"Close the input source.\"\"\"\n        pass\n\n    @abstractmethod\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        \"\"\"\n        Read one audio/data frame.\n\n        Args:\n            frame_size: Number of bytes to read\n\n        Returns:\n            Frame data, or None if no data available\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def seek(self, position: int) -&gt; None:\n        \"\"\"Seek to position in stream (if supported).\"\"\"\n        pass\n</code></pre>"},{"location":"api-reference/input/#file-input","title":"File Input","text":""},{"location":"api-reference/input/#module-dabmuxinputfile","title":"Module: <code>dabmux.input.file</code>","text":""},{"location":"api-reference/input/#class-fileinput","title":"Class: <code>FileInput</code>","text":"<p>Read audio/data from files with automatic looping.</p> <pre><code>from dabmux.input.file import FileInput\n\n# Create file input\ninput_source = FileInput('audio.mp2', loop=True)\ninput_source.open()\n\n# Read frames\nframe_data = input_source.read_frame(960)  # 960 bytes per frame\n\ninput_source.close()\n</code></pre>"},{"location":"api-reference/input/#constructor","title":"Constructor","text":""},{"location":"api-reference/input/#__init__file_path-str-path-loop-bool-false","title":"<code>__init__(file_path: str | Path, loop: bool = False)</code>","text":"<p>Create a file input source.</p> <p>Parameters: - <code>file_path: str | Path</code> - Path to input file - <code>loop: bool</code> - Loop file when EOF reached (default: False)</p> <p>Example: <pre><code># Single-pass reading\ninput_source = FileInput('audio.mp2', loop=False)\n\n# Continuous looping\ninput_source = FileInput('audio.mp2', loop=True)\n</code></pre></p>"},{"location":"api-reference/input/#methods","title":"Methods","text":""},{"location":"api-reference/input/#open-none","title":"<code>open() -&gt; None</code>","text":"<p>Open the file for reading.</p> <p>Raises: - <code>FileNotFoundError</code> - If file doesn't exist - <code>PermissionError</code> - If file can't be read</p> <p>Example: <pre><code>input_source = FileInput('audio.mp2')\ninput_source.open()\n</code></pre></p>"},{"location":"api-reference/input/#close-none","title":"<code>close() -&gt; None</code>","text":"<p>Close the file.</p> <p>Example: <pre><code>input_source.close()\n</code></pre></p>"},{"location":"api-reference/input/#read_frameframe_size-int-optionalbytes","title":"<code>read_frame(frame_size: int) -&gt; Optional[bytes]</code>","text":"<p>Read audio/data frame from file.</p> <p>Parameters: - <code>frame_size: int</code> - Number of bytes to read</p> <p>Returns: Frame data, or <code>None</code> if EOF and not looping</p> <p>Behavior: - Reads exactly <code>frame_size</code> bytes - If EOF reached and <code>loop=True</code>, seeks to beginning - If EOF reached and <code>loop=False</code>, returns <code>None</code></p> <p>Example: <pre><code># Read frames until EOF\nwhile True:\n    frame_data = input_source.read_frame(960)\n    if frame_data is None:\n        break\n    # Process frame\n</code></pre></p>"},{"location":"api-reference/input/#seekposition-int-none","title":"<code>seek(position: int) -&gt; None</code>","text":"<p>Seek to byte position in file.</p> <p>Parameters: - <code>position: int</code> - Byte offset (0 = start of file)</p> <p>Example: <pre><code># Seek to beginning\ninput_source.seek(0)\n\n# Seek to 1 second (48000 Hz, 128 kbps MPEG Layer II)\ninput_source.seek(16000)  # ~1 second\n</code></pre></p>"},{"location":"api-reference/input/#file-format-support","title":"File Format Support","text":"<p>Supported formats:</p> Format Extension Description MPEG Layer II <code>.mp2</code>, <code>.mp2a</code> DAB audio HE-AAC v2 <code>.aac</code>, <code>.dabp</code> DAB+ audio Raw audio <code>.raw</code> Unframed audio data <p>Note: File must contain properly framed audio data matching the subchannel configuration.</p>"},{"location":"api-reference/input/#network-input","title":"Network Input","text":""},{"location":"api-reference/input/#module-dabmuxinputnetwork","title":"Module: <code>dabmux.input.network</code>","text":""},{"location":"api-reference/input/#class-udpinput","title":"Class: <code>UdpInput</code>","text":"<p>Receive audio/data via UDP.</p> <pre><code>from dabmux.input.network import UdpInput\n\n# Listen on multicast group\ninput_source = UdpInput('239.1.2.3', 5001)\ninput_source.open()\n\n# Read frames\nframe_data = input_source.read_frame(960)\n\ninput_source.close()\n</code></pre>"},{"location":"api-reference/input/#constructor_1","title":"Constructor","text":""},{"location":"api-reference/input/#__init__host-str-port-int-buffer_size-int-8192","title":"<code>__init__(host: str, port: int, buffer_size: int = 8192)</code>","text":"<p>Create a UDP input source.</p> <p>Parameters: - <code>host: str</code> - IP address to listen on (unicast or multicast) - <code>port: int</code> - UDP port number - <code>buffer_size: int</code> - Socket receive buffer size (default: 8192)</p> <p>Example: <pre><code># Multicast\ninput_source = UdpInput('239.1.2.3', 5001)\n\n# Unicast\ninput_source = UdpInput('0.0.0.0', 5001)  # Listen on all interfaces\n\n# Custom buffer size\ninput_source = UdpInput('239.1.2.3', 5001, buffer_size=16384)\n</code></pre></p>"},{"location":"api-reference/input/#methods_1","title":"Methods","text":""},{"location":"api-reference/input/#open-none_1","title":"<code>open() -&gt; None</code>","text":"<p>Open UDP socket and bind to address.</p> <p>Raises: - <code>OSError</code> - If socket can't bind to address - <code>PermissionError</code> - If port requires privileges</p> <p>Example: <pre><code>input_source = UdpInput('239.1.2.3', 5001)\ninput_source.open()\n</code></pre></p>"},{"location":"api-reference/input/#close-none_1","title":"<code>close() -&gt; None</code>","text":"<p>Close UDP socket.</p>"},{"location":"api-reference/input/#read_frameframe_size-int-optionalbytes_1","title":"<code>read_frame(frame_size: int) -&gt; Optional[bytes]</code>","text":"<p>Receive audio/data frame from UDP.</p> <p>Parameters: - <code>frame_size: int</code> - Expected frame size in bytes</p> <p>Returns: Frame data, or <code>None</code> if no data received</p> <p>Behavior: - Blocks until data received or timeout - Returns first <code>frame_size</code> bytes from packet - Discards remaining data if packet &gt; frame_size - Returns <code>None</code> on timeout or error</p> <p>Example: <pre><code># Receive frames\nwhile True:\n    frame_data = input_source.read_frame(960)\n    if frame_data:\n        # Process frame\n        pass\n</code></pre></p>"},{"location":"api-reference/input/#seekposition-int-none_1","title":"<code>seek(position: int) -&gt; None</code>","text":"<p>Not supported for network inputs (raises <code>NotImplementedError</code>).</p>"},{"location":"api-reference/input/#class-tcpinput","title":"Class: <code>TcpInput</code>","text":"<p>Receive audio/data via TCP.</p> <pre><code>from dabmux.input.network import TcpInput\n\n# Connect to TCP server\ninput_source = TcpInput('192.168.1.100', 5002)\ninput_source.open()\n\n# Read frames\nframe_data = input_source.read_frame(960)\n\ninput_source.close()\n</code></pre>"},{"location":"api-reference/input/#constructor_2","title":"Constructor","text":""},{"location":"api-reference/input/#__init__host-str-port-int-timeout-float-50","title":"<code>__init__(host: str, port: int, timeout: float = 5.0)</code>","text":"<p>Create a TCP input source.</p> <p>Parameters: - <code>host: str</code> - IP address to connect to - <code>port: int</code> - TCP port number - <code>timeout: float</code> - Connection timeout in seconds (default: 5.0)</p> <p>Example: <pre><code># Default timeout\ninput_source = TcpInput('192.168.1.100', 5002)\n\n# Custom timeout\ninput_source = TcpInput('192.168.1.100', 5002, timeout=10.0)\n</code></pre></p>"},{"location":"api-reference/input/#methods_2","title":"Methods","text":""},{"location":"api-reference/input/#open-none_2","title":"<code>open() -&gt; None</code>","text":"<p>Connect to TCP server.</p> <p>Raises: - <code>ConnectionError</code> - If connection fails - <code>TimeoutError</code> - If connection times out</p> <p>Example: <pre><code>input_source = TcpInput('192.168.1.100', 5002)\ntry:\n    input_source.open()\nexcept ConnectionError:\n    print(\"Failed to connect to server\")\n</code></pre></p>"},{"location":"api-reference/input/#close-none_2","title":"<code>close() -&gt; None</code>","text":"<p>Close TCP connection.</p>"},{"location":"api-reference/input/#read_frameframe_size-int-optionalbytes_2","title":"<code>read_frame(frame_size: int) -&gt; Optional[bytes]</code>","text":"<p>Receive audio/data frame from TCP.</p> <p>Parameters: - <code>frame_size: int</code> - Number of bytes to read</p> <p>Returns: Frame data, or <code>None</code> if connection closed</p> <p>Behavior: - Blocks until <code>frame_size</code> bytes received - Returns <code>None</code> if connection closed - Handles partial receives automatically</p> <p>Example: <pre><code># Receive frames\nwhile True:\n    frame_data = input_source.read_frame(960)\n    if frame_data is None:\n        print(\"Connection closed\")\n        break\n    # Process frame\n</code></pre></p>"},{"location":"api-reference/input/#seekposition-int-none_2","title":"<code>seek(position: int) -&gt; None</code>","text":"<p>Not supported for network inputs (raises <code>NotImplementedError</code>).</p>"},{"location":"api-reference/input/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/input/#reading-from-file","title":"Reading from File","text":"<pre><code>from dabmux.input.file import FileInput\n\n# Open file input\ninput_source = FileInput('audio.mp2', loop=True)\ninput_source.open()\n\ntry:\n    # Read 100 frames\n    for _ in range(100):\n        frame = input_source.read_frame(960)\n        if frame:\n            print(f\"Read {len(frame)} bytes\")\n        else:\n            print(\"No data\")\n            break\nfinally:\n    input_source.close()\n</code></pre>"},{"location":"api-reference/input/#receiving-from-udp","title":"Receiving from UDP","text":"<pre><code>from dabmux.input.network import UdpInput\nimport socket\n\n# Create UDP input\ninput_source = UdpInput('239.1.2.3', 5001)\ninput_source.open()\n\ntry:\n    # Receive continuously\n    while True:\n        frame = input_source.read_frame(960)\n        if frame:\n            print(f\"Received {len(frame)} bytes\")\nexcept KeyboardInterrupt:\n    print(\"Stopped\")\nfinally:\n    input_source.close()\n</code></pre>"},{"location":"api-reference/input/#receiving-from-tcp","title":"Receiving from TCP","text":"<pre><code>from dabmux.input.network import TcpInput\n\n# Connect to TCP server\ninput_source = TcpInput('192.168.1.100', 5002, timeout=10.0)\n\ntry:\n    input_source.open()\n    print(\"Connected\")\n\n    # Receive frames\n    while True:\n        frame = input_source.read_frame(960)\n        if frame is None:\n            print(\"Connection closed\")\n            break\n        print(f\"Received {len(frame)} bytes\")\n\nexcept ConnectionError as e:\n    print(f\"Connection error: {e}\")\nfinally:\n    input_source.close()\n</code></pre>"},{"location":"api-reference/input/#using-with-multiplexer","title":"Using with Multiplexer","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.input.file import FileInput\nfrom dabmux.config import load_config\n\n# Load configuration\nensemble = load_config('config.yaml')\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Create and register inputs for each subchannel\nfor subchannel in ensemble.subchannels:\n    # Extract file path from input URI\n    uri = subchannel.input_uri\n    if uri.startswith('file://'):\n        file_path = uri[7:]  # Remove 'file://' prefix\n        input_source = FileInput(file_path, loop=True)\n        input_source.open()\n        mux.add_input(subchannel.uid, input_source)\n\n# Generate frames\ntry:\n    while True:\n        frame = mux.generate_frame()\n        # Output frame\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    # Close all inputs\n    for input_source in mux.inputs.values():\n        input_source.close()\n</code></pre>"},{"location":"api-reference/input/#context-manager-pattern","title":"Context Manager Pattern","text":"<pre><code>from contextlib import closing\nfrom dabmux.input.file import FileInput\n\n# Automatic cleanup with context manager\nwith closing(FileInput('audio.mp2')) as input_source:\n    input_source.open()\n    frame = input_source.read_frame(960)\n    # Input automatically closed when exiting context\n</code></pre>"},{"location":"api-reference/input/#custom-input-source","title":"Custom Input Source","text":""},{"location":"api-reference/input/#creating-a-custom-input","title":"Creating a Custom Input","text":"<pre><code>from dabmux.input.base import InputBase\nfrom typing import Optional\n\nclass StreamingInput(InputBase):\n    \"\"\"Custom streaming input source.\"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n        self.buffer = bytearray()\n\n    def open(self) -&gt; None:\n        \"\"\"Initialize streaming connection.\"\"\"\n        # Connect to streaming service\n        pass\n\n    def close(self) -&gt; None:\n        \"\"\"Close streaming connection.\"\"\"\n        # Disconnect\n        pass\n\n    def read_frame(self, frame_size: int) -&gt; Optional[bytes]:\n        \"\"\"Read frame from stream.\"\"\"\n        # Fill buffer if needed\n        while len(self.buffer) &lt; frame_size:\n            chunk = self._receive_chunk()\n            if not chunk:\n                return None\n            self.buffer.extend(chunk)\n\n        # Extract frame\n        frame = bytes(self.buffer[:frame_size])\n        self.buffer = self.buffer[frame_size:]\n        return frame\n\n    def seek(self, position: int) -&gt; None:\n        \"\"\"Not supported.\"\"\"\n        raise NotImplementedError(\"Streaming inputs don't support seeking\")\n\n    def _receive_chunk(self) -&gt; Optional[bytes]:\n        \"\"\"Receive data chunk from stream.\"\"\"\n        # Implement streaming protocol\n        pass\n</code></pre>"},{"location":"api-reference/input/#using-custom-input","title":"Using Custom Input","text":"<pre><code>from dabmux.mux import DabMultiplexer\n\n# Create custom input\ncustom_input = StreamingInput('https://stream.example.com/audio')\ncustom_input.open()\n\n# Register with multiplexer\nmux.add_input('subchannel1', custom_input)\n\n# Use normally\nframe = mux.generate_frame()\n</code></pre>"},{"location":"api-reference/input/#error-handling","title":"Error Handling","text":"<pre><code>from dabmux.input.file import FileInput\nfrom dabmux.input.network import UdpInput\n\n# File input errors\ntry:\n    input_source = FileInput('missing.mp2')\n    input_source.open()\nexcept FileNotFoundError:\n    print(\"File not found\")\nexcept PermissionError:\n    print(\"Permission denied\")\n\n# Network input errors\ntry:\n    input_source = UdpInput('239.1.2.3', 5001)\n    input_source.open()\nexcept OSError as e:\n    print(f\"Network error: {e}\")\n</code></pre>"},{"location":"api-reference/input/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>File I/O: Use <code>loop=True</code> for continuous operation to avoid reopening files</li> <li>UDP: Use larger buffer sizes for high bitrate streams</li> <li>TCP: Connection setup has overhead; maintain persistent connections</li> <li>Buffering: Consider implementing input buffering for network sources</li> </ul>"},{"location":"api-reference/input/#see-also","title":"See Also","text":"<ul> <li>Output Module - Output destinations</li> <li>User Guide: Inputs - Detailed input guide</li> <li>Mux API - Using inputs with multiplexer</li> <li>Configuration - Configuring input URIs</li> </ul>"},{"location":"api-reference/mux/","title":"Multiplexer Module","text":"<p>Main multiplexer class that combines audio/data streams into ETI frames.</p>"},{"location":"api-reference/mux/#module-dabmuxmux","title":"Module: <code>dabmux.mux</code>","text":""},{"location":"api-reference/mux/#class-dabmultiplexer","title":"Class: <code>DabMultiplexer</code>","text":"<p>The core multiplexer that generates ETI frames from ensemble configuration and input sources.</p> <pre><code>from dabmux.config import load_config\nfrom dabmux.mux import DabMultiplexer\n\n# Load ensemble configuration\nensemble = load_config('config.yaml')\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Generate frames\nframe = mux.generate_frame()\n</code></pre>"},{"location":"api-reference/mux/#constructor","title":"Constructor","text":""},{"location":"api-reference/mux/#__init__ensemble-dabensemble","title":"<code>__init__(ensemble: DabEnsemble)</code>","text":"<p>Create a new multiplexer instance.</p> <p>Parameters: - <code>ensemble: DabEnsemble</code> - Ensemble configuration with services, subchannels, and components</p> <p>Example: <pre><code>from dabmux.core.mux_elements import DabEnsemble\nfrom dabmux.mux import DabMultiplexer\n\nensemble = DabEnsemble(\n    id=0xCE15,\n    ecc=0xE1,\n    transmission_mode=1,\n    label_text='My DAB'\n)\nmux = DabMultiplexer(ensemble)\n</code></pre></p>"},{"location":"api-reference/mux/#attributes","title":"Attributes","text":""},{"location":"api-reference/mux/#ensemble-dabensemble","title":"<code>ensemble: DabEnsemble</code>","text":"<p>The ensemble configuration (read-only after initialization).</p> <p>Type: <code>DabEnsemble</code></p> <p>Example: <pre><code>print(f\"Ensemble: {mux.ensemble.label.text}\")\nprint(f\"Services: {len(mux.ensemble.services)}\")\n</code></pre></p>"},{"location":"api-reference/mux/#frame_count-int","title":"<code>frame_count: int</code>","text":"<p>Current frame count (increments with each generated frame).</p> <p>Type: <code>int</code></p> <p>Range: 0-255 (wraps around)</p> <p>Example: <pre><code>frame = mux.generate_frame()\nprint(f\"Generated frame #{mux.frame_count}\")\n</code></pre></p>"},{"location":"api-reference/mux/#fic_encoder-ficencoder","title":"<code>fic_encoder: FICEncoder</code>","text":"<p>Fast Information Channel encoder instance.</p> <p>Type: <code>FICEncoder</code></p> <p>Example: <pre><code>fic_data = mux.fic_encoder.encode_fic(frame_number=0)\n</code></pre></p>"},{"location":"api-reference/mux/#methods","title":"Methods","text":""},{"location":"api-reference/mux/#generate_frame-etiframe","title":"<code>generate_frame() -&gt; EtiFrame</code>","text":"<p>Generate a single ETI frame.</p> <p>Reads data from all configured inputs, generates FIC (Fast Information Channel) data containing service information, and assembles a complete ETI frame.</p> <p>Returns: Complete <code>EtiFrame</code> ready for output</p> <p>Raises: - <code>RuntimeError</code> - If frame generation fails - <code>InputError</code> - If input source fails to provide data</p> <p>Example: <pre><code># Generate one frame\nframe = mux.generate_frame()\nassert len(frame.pack()) == 6144\n\n# Frame count auto-increments\nassert mux.frame_count == 1\n</code></pre></p> <p>Frame Structure:</p> <p>The generated frame contains:</p> <ol> <li>SYNC (4 bytes) - Frame synchronization</li> <li>FC (4 bytes) - Frame characterization</li> <li>STC (4 bytes \u00d7 N) - Subchannel headers</li> <li>EOH (4 bytes) - End of header + CRC</li> <li>FIC (96 bytes Mode I) - Fast Information Channel</li> <li>MST (variable) - Main Service Channel (audio/data)</li> <li>EOF (4 bytes) - End of frame + CRC</li> <li>TIST (4 bytes, optional) - Timestamp</li> </ol> <p>Timing:</p> <ul> <li>Mode I: One frame every 96 ms (10.416\u0304 frames/second)</li> <li>Mode II: One frame every 24 ms (41.6\u0304 frames/second)</li> <li>Mode III: One frame every 24 ms (41.6\u0304 frames/second)</li> <li>Mode IV: One frame every 96 ms (10.416\u0304 frames/second)</li> </ul>"},{"location":"api-reference/mux/#add_inputsubchannel_uid-str-input_source-inputbase-none","title":"<code>add_input(subchannel_uid: str, input_source: InputBase) -&gt; None</code>","text":"<p>Register an input source for a subchannel.</p> <p>Parameters: - <code>subchannel_uid: str</code> - UID of the subchannel (must exist in ensemble) - <code>input_source: InputBase</code> - Input source instance</p> <p>Raises: - <code>ValueError</code> - If subchannel doesn't exist or input already registered</p> <p>Example: <pre><code>from dabmux.input.file import FileInput\n\n# Create input for audio subchannel\ninput_source = FileInput('audio.mp2')\ninput_source.open()\n\n# Register input\nmux.add_input('audio1', input_source)\n</code></pre></p>"},{"location":"api-reference/mux/#add_outputoutput-daboutput-none","title":"<code>add_output(output: DabOutput) -&gt; None</code>","text":"<p>Register an output destination.</p> <p>Parameters: - <code>output: DabOutput</code> - Output destination instance</p> <p>Example: <pre><code>from dabmux.output.file import FileOutput\n\n# Create file output\noutput = FileOutput()\noutput.open('output.eti')\n\n# Register output\nmux.add_output(output)\n</code></pre></p> <p>Note: Outputs are registered but not automatically written to. Use them in your main loop:</p> <pre><code>while running:\n    frame = mux.generate_frame()\n    for output in mux.outputs:\n        output.write(frame.pack())\n</code></pre>"},{"location":"api-reference/mux/#complete-usage-example","title":"Complete Usage Example","text":""},{"location":"api-reference/mux/#basic-single-service-multiplex","title":"Basic Single-Service Multiplex","text":"<pre><code>from dabmux.config import load_config\nfrom dabmux.mux import DabMultiplexer\nfrom dabmux.output.file import FileOutput\n\n# Load configuration\nensemble = load_config('config.yaml')\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Create output\noutput = FileOutput()\noutput.open('output.eti')\n\ntry:\n    # Generate 100 frames\n    for _ in range(100):\n        frame = mux.generate_frame()\n        output.write(frame.pack())\n\n    print(f\"Generated {mux.frame_count} frames\")\n\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/mux/#continuous-operation","title":"Continuous Operation","text":"<pre><code>import signal\nfrom dabmux.mux import DabMultiplexer\nfrom dabmux.output.file import FileOutput\n\nrunning = True\n\ndef signal_handler(sig, frame):\n    global running\n    running = False\n\nsignal.signal(signal.SIGINT, signal_handler)\n\n# Setup\nmux = DabMultiplexer(ensemble)\noutput = FileOutput()\noutput.open('output.eti')\n\ntry:\n    print(\"Generating frames... Press Ctrl+C to stop\")\n\n    while running:\n        frame = mux.generate_frame()\n        output.write(frame.pack())\n\n        # Optional: Add timing to match real-time\n        # time.sleep(0.096)  # 96ms for Mode I\n\n    print(f\"\\nGenerated {mux.frame_count} frames\")\n\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/mux/#multiple-outputs","title":"Multiple Outputs","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.output.file import FileOutput\nfrom dabmux.output.edi import EdiOutput\nfrom dabmux.edi.pft import PFTConfig\n\n# Create multiplexer\nmux = DabMultiplexer(ensemble)\n\n# Create file output\nfile_output = FileOutput()\nfile_output.open('output.eti')\n\n# Create network output with PFT\npft_config = PFTConfig(fec=True, fec_m=2)\nedi_output = EdiOutput(\n    dest_addr='239.1.2.3',\n    dest_port=12000,\n    enable_pft=True,\n    pft_config=pft_config\n)\nedi_output.open()\n\n# Register both outputs\nmux.add_output(file_output)\nmux.add_output(edi_output)\n\ntry:\n    while running:\n        frame = mux.generate_frame()\n\n        # Write to both outputs\n        for output in mux.outputs:\n            if isinstance(output, FileOutput):\n                output.write(frame.pack())\n            elif isinstance(output, EdiOutput):\n                output.write_frame(frame)\n\nfinally:\n    file_output.close()\n    edi_output.close()\n</code></pre>"},{"location":"api-reference/mux/#with-timestamps-tist","title":"With Timestamps (TIST)","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.core.eti import EtiTIST\nfrom datetime import datetime\n\n# Enable TIST in ensemble configuration\nensemble.enable_tist = True\nensemble.tist_offset = 0.0  # Offset in milliseconds\n\nmux = DabMultiplexer(ensemble)\n\n# Generate frame with timestamp\nframe = mux.generate_frame()\n\n# TIST is automatically added if enabled\nif frame.tist:\n    print(f\"Frame timestamp: {frame.tist.tist}\")\n\n# Frame size includes TIST\nassert len(frame.pack()) == 6148  # 6144 + 4 for TIST\n</code></pre>"},{"location":"api-reference/mux/#error-handling","title":"Error Handling","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.input.base import InputError\nfrom dabmux.core.eti import EtiError\n\nmux = DabMultiplexer(ensemble)\n\ntry:\n    frame = mux.generate_frame()\nexcept InputError as e:\n    print(f\"Input error: {e}\")\n    # Handle missing input data\nexcept EtiError as e:\n    print(f\"ETI generation error: {e}\")\n    # Handle frame generation error\nexcept RuntimeError as e:\n    print(f\"Multiplexer error: {e}\")\n    # Handle general multiplexer error\n</code></pre>"},{"location":"api-reference/mux/#internal-operation","title":"Internal Operation","text":""},{"location":"api-reference/mux/#frame-generation-pipeline","title":"Frame Generation Pipeline","text":"<pre><code>graph LR\n    A[generate_frame] --&gt; B[Create Empty Frame]\n    B --&gt; C[Generate FIC Data]\n    C --&gt; D[Read Subchannel Data]\n    D --&gt; E[Assemble MST]\n    E --&gt; F[Calculate CRCs]\n    F --&gt; G[Return Frame]\n</code></pre> <ol> <li>Create empty frame based on transmission mode</li> <li>Update frame count (FCT field)</li> <li>Generate FIC data using FICEncoder</li> <li>Read audio/data from registered inputs</li> <li>Assemble Main Service Channel (MST)</li> <li>Calculate CRCs for header and data</li> <li>Return complete frame</li> </ol>"},{"location":"api-reference/mux/#fic-generation","title":"FIC Generation","text":"<p>The multiplexer uses a <code>FICEncoder</code> to generate Fast Information Channel data. The FIC carousel rotates through different FIG (Fast Information Group) types:</p> <ul> <li>FIG 0/0: Ensemble configuration (every frame)</li> <li>FIG 0/1: Subchannel organization (every 1 second)</li> <li>FIG 0/2: Service organization (every 1 second)</li> <li>FIG 1/0: Service labels (every 2 seconds)</li> <li>FIG 1/1: Subchannel labels (every 2 seconds)</li> </ul> <p>See FIG Carousel for detailed diagram.</p>"},{"location":"api-reference/mux/#input-management","title":"Input Management","text":"<p>Inputs are read in subchannel ID order:</p> <pre><code>for subchannel in sorted(ensemble.subchannels, key=lambda s: s.id):\n    if subchannel.uid in mux.inputs:\n        input_source = mux.inputs[subchannel.uid]\n        data = input_source.read_frame(frame_size)\n        # Add to MST\n</code></pre> <p>If an input has no data available, the subchannel is filled with silence/padding.</p>"},{"location":"api-reference/mux/#performance","title":"Performance","text":""},{"location":"api-reference/mux/#memory-usage","title":"Memory Usage","text":"<ul> <li>Per frame: ~6-7 KB (6144 bytes frame + overhead)</li> <li>FIC encoder: ~10 KB (carousel state)</li> <li>Input buffers: Varies by input type</li> <li>Total steady state: &lt; 50 MB</li> </ul>"},{"location":"api-reference/mux/#cpu-usage","title":"CPU Usage","text":"<p>Typical CPU usage on modern hardware:</p> <ul> <li>Frame generation: &lt; 1ms (Mode I)</li> <li>FIC encoding: &lt; 0.1ms</li> <li>CRC calculation: &lt; 0.05ms</li> <li>Total: 10-20% of one core @ real-time speed</li> </ul>"},{"location":"api-reference/mux/#optimization-tips","title":"Optimization Tips","text":"<ol> <li> <p>Reuse frame buffers: <pre><code>frame_buffer = bytearray(6144)\nwhile running:\n    frame = mux.generate_frame()\n    frame.pack_into(frame_buffer)\n    output.write(frame_buffer)\n</code></pre></p> </li> <li> <p>Minimize FIG types: <pre><code>mux.fic_encoder.set_enabled_figs([0, 1])  # Only essential FIGs\n</code></pre></p> </li> <li> <p>Batch output writes: <pre><code>buffer = bytearray(6144 * 100)  # 100 frames\nfor i in range(100):\n    frame = mux.generate_frame()\n    frame.pack_into(buffer[i*6144:(i+1)*6144])\noutput.write(buffer)  # Single write\n</code></pre></p> </li> </ol>"},{"location":"api-reference/mux/#thread-safety","title":"Thread Safety","text":"<p><code>DabMultiplexer</code> is not thread-safe. Do not call <code>generate_frame()</code> from multiple threads simultaneously.</p> <p>For multi-threaded applications, use one multiplexer per thread or add locking:</p> <pre><code>import threading\n\nlock = threading.Lock()\n\ndef generate_worker():\n    with lock:\n        frame = mux.generate_frame()\n        # Process frame\n</code></pre>"},{"location":"api-reference/mux/#limitations","title":"Limitations","text":"<ul> <li>Single multiplexer per ensemble: Each instance maintains frame count and state</li> <li>Sequential operation: Frames must be generated in order</li> <li>Input synchronization: All inputs must provide data when requested</li> <li>No frame buffering: Frames are generated on-demand, not buffered</li> </ul>"},{"location":"api-reference/mux/#see-also","title":"See Also","text":"<ul> <li>Core API - ETI frame structures and ensemble configuration</li> <li>Input API - Input source implementations</li> <li>Output API - Output destination implementations</li> <li>FIC API - Fast Information Channel encoding</li> <li>Architecture: System Design - High-level architecture</li> <li>Architecture: Data Flow - Input to output pipeline</li> </ul>"},{"location":"api-reference/output/","title":"Output Module","text":"<p>Output destinations for ETI frames and EDI streams.</p>"},{"location":"api-reference/output/#module-dabmuxoutput","title":"Module: <code>dabmux.output</code>","text":"<p>Provides output implementations for writing ETI frames to files and streaming over networks.</p>"},{"location":"api-reference/output/#base-class-daboutput","title":"Base Class: <code>DabOutput</code>","text":"<p>Abstract base class for all outputs.</p>"},{"location":"api-reference/output/#module-dabmuxoutputbase","title":"Module: <code>dabmux.output.base</code>","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass DabOutput(ABC):\n    \"\"\"Abstract base class for outputs.\"\"\"\n\n    @abstractmethod\n    def open(self, *args, **kwargs) -&gt; None:\n        \"\"\"Open the output.\"\"\"\n        pass\n\n    @abstractmethod\n    def close(self) -&gt; None:\n        \"\"\"Close the output.\"\"\"\n        pass\n\n    @abstractmethod\n    def write(self, data: bytes) -&gt; None:\n        \"\"\"Write data to output.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_info(self) -&gt; str:\n        \"\"\"Get output information string.\"\"\"\n        pass\n</code></pre>"},{"location":"api-reference/output/#file-output","title":"File Output","text":""},{"location":"api-reference/output/#module-dabmuxoutputfile","title":"Module: <code>dabmux.output.file</code>","text":""},{"location":"api-reference/output/#class-fileoutput","title":"Class: <code>FileOutput</code>","text":"<p>Write ETI frames to files in various formats.</p> <pre><code>from dabmux.output.file import FileOutput, EtiFileType\n\n# Create file output\noutput = FileOutput()\noutput.open('output.eti', file_type=EtiFileType.FRAMED)\n\n# Write frame\noutput.write(frame_bytes)\n\noutput.close()\n</code></pre>"},{"location":"api-reference/output/#constructor","title":"Constructor","text":""},{"location":"api-reference/output/#__init__","title":"<code>__init__()</code>","text":"<p>Create a file output instance.</p> <p>Example: <pre><code>output = FileOutput()\n</code></pre></p>"},{"location":"api-reference/output/#methods","title":"Methods","text":""},{"location":"api-reference/output/#openfile_path-str-path-file_type-etifiletype-etifiletypeframed-none","title":"<code>open(file_path: str | Path, file_type: EtiFileType = EtiFileType.FRAMED) -&gt; None</code>","text":"<p>Open file for writing.</p> <p>Parameters: - <code>file_path: str | Path</code> - Output file path - <code>file_type: EtiFileType</code> - File format (default: FRAMED)</p> <p>Raises: - <code>PermissionError</code> - If file can't be created - <code>OSError</code> - If file operation fails</p> <p>Example: <pre><code>output = FileOutput()\noutput.open('output.eti', file_type=EtiFileType.RAW)\n</code></pre></p>"},{"location":"api-reference/output/#close-none","title":"<code>close() -&gt; None</code>","text":"<p>Close output file.</p> <p>Example: <pre><code>output.close()\n</code></pre></p>"},{"location":"api-reference/output/#writedata-bytes-none","title":"<code>write(data: bytes) -&gt; None</code>","text":"<p>Write ETI frame to file.</p> <p>Parameters: - <code>data: bytes</code> - ETI frame data (6144 or 6148 bytes)</p> <p>Example: <pre><code>frame_bytes = frame.pack()\noutput.write(frame_bytes)\n</code></pre></p>"},{"location":"api-reference/output/#get_info-str","title":"<code>get_info() -&gt; str</code>","text":"<p>Get output information.</p> <p>Returns: String describing output (e.g., \"File: output.eti\")</p>"},{"location":"api-reference/output/#enum-etifiletype","title":"Enum: <code>EtiFileType</code>","text":"<p>ETI file format types.</p> <pre><code>from enum import Enum\n\nclass EtiFileType(Enum):\n    RAW = 1      # Raw ETI frames\n    STREAMED = 2 # Streamed ETI (with timing)\n    FRAMED = 3   # Framed ETI (8-byte aligned)\n</code></pre> <p>Format descriptions:</p> Type Description Use Case <code>RAW</code> Plain ETI frames, no wrapper Maximum compatibility, smallest files <code>STREAMED</code> Frames with timestamps Timed playback, synchronization <code>FRAMED</code> 8-byte aligned with delimiters Easy parsing, frame boundaries <p>Example: <pre><code>from dabmux.output.file import FileOutput, EtiFileType\n\n# Raw format\noutput = FileOutput()\noutput.open('output.eti', file_type=EtiFileType.RAW)\n\n# Framed format (default)\noutput = FileOutput()\noutput.open('output.eti')  # Uses FRAMED by default\n</code></pre></p>"},{"location":"api-reference/output/#network-output-edi","title":"Network Output (EDI)","text":""},{"location":"api-reference/output/#module-dabmuxoutputedi","title":"Module: <code>dabmux.output.edi</code>","text":""},{"location":"api-reference/output/#class-edioutput","title":"Class: <code>EdiOutput</code>","text":"<p>Stream ETI frames over network using EDI protocol.</p> <pre><code>from dabmux.output.edi import EdiOutput\nfrom dabmux.edi.pft import PFTConfig\n\n# Create EDI output with PFT\npft_config = PFTConfig(fec=True, fec_m=2)\noutput = EdiOutput(\n    dest_addr='239.1.2.3',\n    dest_port=12000,\n    enable_pft=True,\n    pft_config=pft_config\n)\noutput.open()\n\n# Write frame (automatically encoded to EDI)\noutput.write_frame(frame)\n\noutput.close()\n</code></pre>"},{"location":"api-reference/output/#constructor_1","title":"Constructor","text":""},{"location":"api-reference/output/#__init__dest_addr-str-dest_port-int-enable_pft-bool-false-pft_config-optionalpftconfig-none","title":"<code>__init__(dest_addr: str, dest_port: int, enable_pft: bool = False, pft_config: Optional[PFTConfig] = None)</code>","text":"<p>Create an EDI network output.</p> <p>Parameters: - <code>dest_addr: str</code> - Destination IP address (unicast or multicast) - <code>dest_port: int</code> - Destination UDP port - <code>enable_pft: bool</code> - Enable PFT (Protection, Fragmentation and Transport) - <code>pft_config: Optional[PFTConfig]</code> - PFT configuration (required if <code>enable_pft=True</code>)</p> <p>Example: <pre><code># Basic EDI (no PFT)\noutput = EdiOutput('239.1.2.3', 12000)\n\n# EDI with PFT\npft_config = PFTConfig(fec=True, fec_m=2, max_fragment_size=1400)\noutput = EdiOutput('239.1.2.3', 12000, enable_pft=True, pft_config=pft_config)\n</code></pre></p>"},{"location":"api-reference/output/#methods_1","title":"Methods","text":""},{"location":"api-reference/output/#open-none","title":"<code>open() -&gt; None</code>","text":"<p>Open UDP socket for EDI streaming.</p> <p>Raises: - <code>OSError</code> - If socket can't be created</p> <p>Example: <pre><code>output = EdiOutput('239.1.2.3', 12000)\noutput.open()\n</code></pre></p>"},{"location":"api-reference/output/#close-none_1","title":"<code>close() -&gt; None</code>","text":"<p>Close UDP socket.</p>"},{"location":"api-reference/output/#writedata-bytes-none_1","title":"<code>write(data: bytes) -&gt; None</code>","text":"<p>Write raw data to network (not recommended, use <code>write_frame</code>).</p>"},{"location":"api-reference/output/#write_frameframe-etiframe-none","title":"<code>write_frame(frame: EtiFrame) -&gt; None</code>","text":"<p>Encode ETI frame to EDI and transmit.</p> <p>Parameters: - <code>frame: EtiFrame</code> - ETI frame to transmit</p> <p>Behavior: - Encodes frame to EDI TAG items - Wraps in AF packet - Applies PFT if enabled (fragmentation + optional FEC) - Transmits via UDP</p> <p>Example: <pre><code>from dabmux.mux import DabMultiplexer\n\nmux = DabMultiplexer(ensemble)\noutput = EdiOutput('239.1.2.3', 12000, enable_pft=True, pft_config=pft_config)\noutput.open()\n\ntry:\n    while running:\n        frame = mux.generate_frame()\n        output.write_frame(frame)\nfinally:\n    output.close()\n</code></pre></p>"},{"location":"api-reference/output/#get_info-str_1","title":"<code>get_info() -&gt; str</code>","text":"<p>Get output information.</p> <p>Returns: String describing output (e.g., \"EDI: 239.1.2.3:12000 (PFT enabled)\")</p>"},{"location":"api-reference/output/#pft-configuration","title":"PFT Configuration","text":""},{"location":"api-reference/output/#module-dabmuxedipft","title":"Module: <code>dabmux.edi.pft</code>","text":""},{"location":"api-reference/output/#class-pftconfig","title":"Class: <code>PFTConfig</code>","text":"<p>Configuration for PFT (Protection, Fragmentation and Transport).</p> <pre><code>from dabmux.edi.pft import PFTConfig\n\n# PFT with FEC\npft_config = PFTConfig(\n    fec=True,\n    fec_m=2,\n    max_fragment_size=1400\n)\n</code></pre>"},{"location":"api-reference/output/#constructor_2","title":"Constructor","text":""},{"location":"api-reference/output/#__init__fec-bool-false-fec_m-int-0-max_fragment_size-int-1400","title":"<code>__init__(fec: bool = False, fec_m: int = 0, max_fragment_size: int = 1400)</code>","text":"<p>Create PFT configuration.</p> <p>Parameters: - <code>fec: bool</code> - Enable Forward Error Correction (Reed-Solomon) - <code>fec_m: int</code> - Max recoverable fragments (0-20, higher = more recovery) - <code>max_fragment_size: int</code> - Maximum fragment size in bytes (default: 1400)</p> <p>Example: <pre><code># No FEC (fragmentation only)\npft_config = PFTConfig(fec=False, max_fragment_size=1400)\n\n# With FEC (can recover 2 lost fragments)\npft_config = PFTConfig(fec=True, fec_m=2, max_fragment_size=1400)\n\n# Strong FEC (can recover 5 lost fragments)\npft_config = PFTConfig(fec=True, fec_m=5, max_fragment_size=1200)\n</code></pre></p>"},{"location":"api-reference/output/#attributes","title":"Attributes","text":"<ul> <li><code>fec: bool</code> - FEC enabled</li> <li><code>fec_m: int</code> - FEC recovery parameter</li> <li><code>max_fragment_size: int</code> - Fragment size limit</li> </ul>"},{"location":"api-reference/output/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/output/#writing-to-file-raw","title":"Writing to File (Raw)","text":"<pre><code>from dabmux.output.file import FileOutput, EtiFileType\nfrom dabmux.mux import DabMultiplexer\n\n# Setup\nmux = DabMultiplexer(ensemble)\noutput = FileOutput()\noutput.open('output.eti', file_type=EtiFileType.RAW)\n\ntry:\n    # Generate and write 1000 frames\n    for _ in range(1000):\n        frame = mux.generate_frame()\n        output.write(frame.pack())\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/output/#writing-to-file-framed","title":"Writing to File (Framed)","text":"<pre><code>from dabmux.output.file import FileOutput, EtiFileType\n\n# Framed format (default)\noutput = FileOutput()\noutput.open('output.eti')  # Uses FRAMED by default\n\ntry:\n    for _ in range(1000):\n        frame = mux.generate_frame()\n        output.write(frame.pack())\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/output/#streaming-edi-basic","title":"Streaming EDI (Basic)","text":"<pre><code>from dabmux.output.edi import EdiOutput\n\n# Create output\noutput = EdiOutput('239.1.2.3', 12000)\noutput.open()\n\ntry:\n    while running:\n        frame = mux.generate_frame()\n        output.write_frame(frame)\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/output/#streaming-edi-with-pft-fec","title":"Streaming EDI with PFT + FEC","text":"<pre><code>from dabmux.output.edi import EdiOutput\nfrom dabmux.edi.pft import PFTConfig\n\n# Configure PFT with strong FEC\npft_config = PFTConfig(\n    fec=True,\n    fec_m=3,  # Can recover 3 lost fragments\n    max_fragment_size=1400\n)\n\n# Create output\noutput = EdiOutput(\n    dest_addr='239.1.2.3',\n    dest_port=12000,\n    enable_pft=True,\n    pft_config=pft_config\n)\noutput.open()\n\ntry:\n    while running:\n        frame = mux.generate_frame()\n        output.write_frame(frame)\nfinally:\n    output.close()\n</code></pre>"},{"location":"api-reference/output/#multiple-outputs","title":"Multiple Outputs","text":"<pre><code>from dabmux.output.file import FileOutput\nfrom dabmux.output.edi import EdiOutput\n\n# Create file output\nfile_output = FileOutput()\nfile_output.open('archive.eti')\n\n# Create network output\nedi_output = EdiOutput('239.1.2.3', 12000)\nedi_output.open()\n\ntry:\n    # Write to both outputs\n    while running:\n        frame = mux.generate_frame()\n        frame_bytes = frame.pack()\n\n        # Write to file\n        file_output.write(frame_bytes)\n\n        # Write to network\n        edi_output.write_frame(frame)\nfinally:\n    file_output.close()\n    edi_output.close()\n</code></pre>"},{"location":"api-reference/output/#context-manager-pattern","title":"Context Manager Pattern","text":"<pre><code>from contextlib import closing\n\nwith closing(FileOutput()) as output:\n    output.open('output.eti')\n    for _ in range(100):\n        frame = mux.generate_frame()\n        output.write(frame.pack())\n    # Automatically closed\n</code></pre>"},{"location":"api-reference/output/#custom-output","title":"Custom Output","text":""},{"location":"api-reference/output/#creating-a-custom-output","title":"Creating a Custom Output","text":"<pre><code>from dabmux.output.base import DabOutput\n\nclass CustomOutput(DabOutput):\n    \"\"\"Custom output destination.\"\"\"\n\n    def __init__(self, target: str):\n        self.target = target\n\n    def open(self, *args, **kwargs) -&gt; None:\n        \"\"\"Initialize output.\"\"\"\n        # Setup custom output\n        pass\n\n    def close(self) -&gt; None:\n        \"\"\"Cleanup output.\"\"\"\n        # Teardown\n        pass\n\n    def write(self, data: bytes) -&gt; None:\n        \"\"\"Write data to output.\"\"\"\n        # Process and output data\n        pass\n\n    def get_info(self) -&gt; str:\n        \"\"\"Get output description.\"\"\"\n        return f\"Custom: {self.target}\"\n</code></pre>"},{"location":"api-reference/output/#using-custom-output","title":"Using Custom Output","text":"<pre><code># Create and use\ncustom_output = CustomOutput('destination')\ncustom_output.open()\n\ntry:\n    frame = mux.generate_frame()\n    custom_output.write(frame.pack())\nfinally:\n    custom_output.close()\n</code></pre>"},{"location":"api-reference/output/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api-reference/output/#file-output_1","title":"File Output","text":"<ul> <li>Buffering: Use OS buffering (automatic)</li> <li>Format: RAW is fastest and smallest</li> <li>I/O: Sequential writes are fast</li> </ul>"},{"location":"api-reference/output/#network-output","title":"Network Output","text":"<ul> <li>UDP overhead: ~28 bytes per packet (IP + UDP headers)</li> <li>PFT overhead: ~10-20% additional bandwidth</li> <li>FEC overhead: Depends on <code>fec_m</code> parameter</li> <li>Fragmentation: Adjust <code>max_fragment_size</code> to match MTU</li> </ul>"},{"location":"api-reference/output/#bandwidth-calculation","title":"Bandwidth Calculation","text":"<pre><code># Without PFT\nBandwidth = bitrate \u00d7 1.15\n\n# With PFT (no FEC)\nBandwidth = bitrate \u00d7 1.25\n\n# With PFT + FEC (m=2)\nBandwidth = bitrate \u00d7 1.40\n</code></pre> <p>Example: - 6 services \u00d7 128 kbps = 768 kbps - With PFT + FEC (m=2): ~1075 kbps network traffic</p>"},{"location":"api-reference/output/#error-handling","title":"Error Handling","text":"<pre><code>from dabmux.output.file import FileOutput\nfrom dabmux.output.edi import EdiOutput\n\n# File output errors\ntry:\n    output = FileOutput()\n    output.open('/read-only/output.eti')\nexcept PermissionError:\n    print(\"Permission denied\")\nexcept OSError as e:\n    print(f\"I/O error: {e}\")\n\n# Network output errors\ntry:\n    output = EdiOutput('239.1.2.3', 12000)\n    output.open()\nexcept OSError as e:\n    print(f\"Network error: {e}\")\n</code></pre>"},{"location":"api-reference/output/#see-also","title":"See Also","text":"<ul> <li>Input Module - Input sources</li> <li>User Guide: Outputs - Detailed output guide</li> <li>EDI Protocol - EDI protocol details</li> <li>PFT Fragmentation - PFT guide</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>This section explains the internal architecture of python-dabmux with detailed diagrams showing how the system works.</p>"},{"location":"architecture/#key-components","title":"Key Components","text":"<p>python-dabmux is organized into layers:</p> <ol> <li>Configuration Layer: Parses YAML and creates ensemble structure</li> <li>Input Layer: Handles file and network audio sources</li> <li>Core Layer: Multiplexes audio and generates FIGs</li> <li>Output Layer: Writes ETI files or sends EDI over network</li> </ol>"},{"location":"architecture/#architecture-diagrams","title":"Architecture Diagrams","text":""},{"location":"architecture/#system-design","title":"System Design","text":"<p>High-level architecture showing module structure and data flow:</p> <ul> <li>Configuration \u2192 Inputs \u2192 Multiplexer \u2192 FIG Generation \u2192 Outputs</li> <li>Module responsibilities</li> <li>Interface boundaries</li> </ul> <p>Mermaid diagram included</p> <p>View System Design \u2192</p>"},{"location":"architecture/#eti-frame-structure","title":"ETI Frame Structure","text":"<p>Detailed byte layout of ETI frames:</p> <ul> <li>SYNC, FC, STC headers</li> <li>FIC (Fast Information Channel)</li> <li>MST (Main Service Transport)</li> <li>EOF, TIST</li> </ul> <p>Mermaid diagram included</p> <p>View ETI Frames \u2192</p>"},{"location":"architecture/#fig-carousel","title":"FIG Carousel","text":"<p>How FIG types rotate based on repetition rates:</p> <ul> <li>FIG priority system</li> <li>Timing (96ms, 1s, etc.)</li> <li>Buffer management</li> <li>Sequence diagram</li> </ul> <p>Mermaid diagram included</p> <p>View FIG Carousel \u2192</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<p>Complete pipeline from inputs to outputs:</p> <ul> <li>Input buffers \u2192 Multiplexer</li> <li>FIG generation (parallel)</li> <li>Frame assembly</li> <li>Output formatting</li> </ul> <p>Mermaid diagram included</p> <p>View Data Flow \u2192</p>"},{"location":"architecture/#edi-protocol-stack","title":"EDI Protocol Stack","text":"<p>Layer-by-layer EDI protocol:</p> <ul> <li>TAG items (*ptr, deti, estN)</li> <li>AF packets</li> <li>PFT fragmentation</li> <li>UDP/TCP transport</li> </ul> <p>Mermaid diagram included</p> <p>View EDI Protocol \u2192</p>"},{"location":"architecture/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Relationship between configuration elements:</p> <ul> <li>Ensemble \u2192 Services \u2192 Components \u2192 Subchannels \u2192 Inputs</li> <li>ID linkages</li> <li>Tree structure</li> </ul> <p>Mermaid diagram included</p> <p>View Configuration Hierarchy \u2192</p>"},{"location":"architecture/#module-breakdown","title":"Module Breakdown","text":"<p>Detailed description of each Python module:</p> <ul> <li>Purpose and responsibilities</li> <li>Key classes and functions</li> <li>Dependencies</li> <li>Usage patterns</li> </ul> <p>View Module Breakdown \u2192</p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#separation-of-concerns","title":"Separation of Concerns","text":"<p>Each module has a clear responsibility:</p> <ul> <li>core/: Data structures only (no business logic)</li> <li>input/: Input handling only (no multiplexing)</li> <li>output/: Output handling only (no frame generation)</li> <li>mux.py: Orchestrates everything</li> </ul>"},{"location":"architecture/#type-safety","title":"Type Safety","text":"<ul> <li>Full type annotations on all public APIs</li> <li>mypy validation for type correctness</li> <li>Clear interfaces between modules</li> </ul>"},{"location":"architecture/#testability","title":"Testability","text":"<ul> <li>Unit tests for each module (389 tests total)</li> <li>Mocking for external dependencies</li> <li>Test coverage: 71%</li> </ul>"},{"location":"architecture/#extensibility","title":"Extensibility","text":"<ul> <li>Abstract base classes for inputs/outputs</li> <li>Plugin-style architecture for FIG types</li> <li>Easy to add new features</li> </ul>"},{"location":"architecture/#data-structures","title":"Data Structures","text":""},{"location":"architecture/#core-types","title":"Core Types","text":"<pre><code># Ensemble configuration\nDabEnsemble\n  \u251c\u2500 DabService[]\n  \u251c\u2500 DabSubchannel[]\n  \u2514\u2500 DabComponent[]\n\n# ETI frame structures\nEtiFrame\n  \u251c\u2500 Sync\n  \u251c\u2500 FrameCharacterization\n  \u251c\u2500 SubChannelStreamChar[]\n  \u251c\u2500 EndOfHeader\n  \u251c\u2500 FastInformationChannel\n  \u251c\u2500 MainServiceTransport\n  \u251c\u2500 EndOfFrame\n  \u2514\u2500 TimeStamp (optional)\n</code></pre>"},{"location":"architecture/#inputoutput-abstractions","title":"Input/Output Abstractions","text":"<pre><code># Input abstraction\nclass InputBase(ABC):\n    def open() -&gt; None\n    def read() -&gt; bytes\n    def close() -&gt; None\n\n# Output abstraction\nclass DabOutput(ABC):\n    def open() -&gt; None\n    def write(data: bytes) -&gt; None\n    def close() -&gt; None\n</code></pre>"},{"location":"architecture/#processing-flow","title":"Processing Flow","text":""},{"location":"architecture/#initialization","title":"Initialization","text":"<ol> <li>Load YAML configuration</li> <li>Parse into DabEnsemble</li> <li>Create DabMultiplexer</li> <li>Initialize inputs and outputs</li> <li>Validate configuration</li> </ol>"},{"location":"architecture/#frame-generation","title":"Frame Generation","text":"<ol> <li>Read audio data from all inputs</li> <li>Generate FIGs for current frame</li> <li>Encode FIC (Fast Information Channel)</li> <li>Populate MST (Main Service Transport)</li> <li>Calculate CRCs for headers and frame</li> <li>Add TIST (timestamp) if enabled</li> <li>Pack frame to binary</li> </ol>"},{"location":"architecture/#output-writing","title":"Output Writing","text":"<ol> <li>Serialize frame to bytes</li> <li>For file output: Write to file</li> <li>For EDI output: Convert to TAG items \u2192 AF packet \u2192 PFT (optional) \u2192 UDP/TCP</li> </ol>"},{"location":"architecture/#key-algorithms","title":"Key Algorithms","text":""},{"location":"architecture/#fig-carousel-scheduling","title":"FIG Carousel Scheduling","text":"<p>FIGs repeat at different rates: - FIG 0/0: Every 96ms (10 frames) - FIG 0/1, 0/2: Every 1 second (~10 frames) - FIG 1/0, 1/1: Every 1 second - Other FIGs: Every 10 seconds</p> <p>Algorithm: 1. Each FIG has a counter 2. Decrement counter each frame 3. When counter reaches 0, FIG is included 4. Reset counter to repetition interval</p>"},{"location":"architecture/#capacity-unit-allocation","title":"Capacity Unit Allocation","text":"<p>Subchannels use Capacity Units (CUs) based on bitrate and protection:</p> <p>Formula: <pre><code>CUs = f(bitrate, protection_level, form)\n</code></pre></p> <p>Allocation: 1. Sort subchannels by start_address 2. Assign contiguous CU ranges 3. Verify total doesn't exceed mode capacity (864 CUs for Mode I)</p>"},{"location":"architecture/#reed-solomon-fec","title":"Reed-Solomon FEC","text":"<p>For PFT error correction:</p> <p>GF(2^8) arithmetic: - Generator polynomial construction - Systematic encoding - Parity calculation</p> <p>Parameters: - (N, K) = (N, K-2M) where M is error recovery capability - Example: (255, 251) can recover 2 errors</p>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/#cpu-usage","title":"CPU Usage","text":"<ul> <li>Frame generation: O(N) where N = number of services</li> <li>FIG encoding: O(F) where F = number of FIG types</li> <li>CRC calculation: O(L) where L = frame length</li> <li>Overall: ~10-20% of one core for typical ensemble</li> </ul>"},{"location":"architecture/#memory-usage","title":"Memory Usage","text":"<ul> <li>Ensemble config: ~10 KB</li> <li>Frame buffer: ~6 KB per frame</li> <li>Input buffers: Configurable (default: 10 frames per input)</li> <li>Total: ~5-10 MB for typical operation</li> </ul>"},{"location":"architecture/#io-performance","title":"I/O Performance","text":"<ul> <li>File I/O: Limited by disk speed</li> <li>Network I/O: Limited by network bandwidth</li> <li>Bottleneck: Usually input sources, not python-dabmux</li> </ul>"},{"location":"architecture/#thread-safety","title":"Thread Safety","text":"<p>python-dabmux is single-threaded by design:</p> <ul> <li>No locks or mutexes needed</li> <li>Simpler code and debugging</li> <li>Sufficient performance for DAB multiplexing</li> </ul> <p>For multi-core: Run multiple instances with different configurations.</p>"},{"location":"architecture/#error-handling","title":"Error Handling","text":""},{"location":"architecture/#validation-layers","title":"Validation Layers","text":"<ol> <li>Configuration parsing: YAML syntax, required fields</li> <li>Ensemble validation: ID uniqueness, capacity limits</li> <li>Input validation: File existence, format checks</li> <li>Runtime validation: Buffer underruns, CRC errors</li> </ol>"},{"location":"architecture/#graceful-degradation","title":"Graceful Degradation","text":"<ul> <li>Missing input: Zero-filled frames</li> <li>Network error: Retry with exponential backoff</li> <li>Buffer underrun: Warning logged, continue with available data</li> </ul>"},{"location":"architecture/#see-also","title":"See Also","text":"<ul> <li>System Design: High-level architecture</li> <li>Data Flow: Complete processing pipeline</li> <li>Module Breakdown: Detailed module descriptions</li> <li>API Reference: Code documentation</li> </ul>"},{"location":"architecture/configuration-hierarchy/","title":"Configuration Hierarchy","text":"<p>Tree diagram showing the relationship between configuration elements and how they link together.</p>"},{"location":"architecture/configuration-hierarchy/#configuration-hierarchy-diagram","title":"Configuration Hierarchy Diagram","text":"<pre><code>graph TB\n    subgraph \"Ensemble Level\"\n        ENS[EnsembleID: 0xCE15ECC: 0xE1Mode: ILabel: 'DAB Multiplex']\n    end\n\n    subgraph \"Service Level (What Listeners See)\"\n        SVC1[Service 1ID: 0x5001Label: 'Radio One'PTY: NewsLanguage: English]\n        SVC2[Service 2ID: 0x5002Label: 'Radio Two'PTY: Pop MusicLanguage: English]\n        SVC3[Service 3ID: 0x5003Label: 'Radio Three'PTY: ClassicalLanguage: English]\n    end\n\n    subgraph \"Component Level (Links)\"\n        COMP1[Component 1Links 0x5001to subchannel 0]\n        COMP2[Component 2Links 0x5002to subchannel 1]\n        COMP3[Component 3Links 0x5003to subchannel 2]\n    end\n\n    subgraph \"Subchannel Level (Data Streams)\"\n        SUB0[Subchannel 0ID: 0Type: DAB AudioBitrate: 128 kbpsProtection: Level 2Start Address: 0 CU]\n        SUB1[Subchannel 1ID: 1Type: DAB+ AudioBitrate: 80 kbpsProtection: Level 2Start Address: 128 CU]\n        SUB2[Subchannel 2ID: 2Type: DAB+ AudioBitrate: 96 kbpsProtection: Level 3Start Address: 256 CU]\n    end\n\n    subgraph \"Input Level (Audio Sources)\"\n        IN0[File Inputfile://audio1.mp2MPEG Layer II128 kbps]\n        IN1[UDP Inputudp://239.1.2.3:5001HE-AAC80 kbps]\n        IN2[TCP Inputtcp://192.168.1.100:5002HE-AAC96 kbps]\n    end\n\n    ENS --&gt; SVC1\n    ENS --&gt; SVC2\n    ENS --&gt; SVC3\n\n    SVC1 --&gt; COMP1\n    SVC2 --&gt; COMP2\n    SVC3 --&gt; COMP3\n\n    COMP1 --&gt; SUB0\n    COMP2 --&gt; SUB1\n    COMP3 --&gt; SUB2\n\n    SUB0 --&gt; IN0\n    SUB1 --&gt; IN1\n    SUB2 --&gt; IN2\n\n    style ENS fill:#ffcccc,stroke:#333,stroke-width:3px\n    style SVC1 fill:#ccffcc,stroke:#333,stroke-width:2px\n    style SVC2 fill:#ccffcc,stroke:#333,stroke-width:2px\n    style SVC3 fill:#ccffcc,stroke:#333,stroke-width:2px\n    style COMP1 fill:#ccccff,stroke:#333,stroke-width:2px\n    style COMP2 fill:#ccccff,stroke:#333,stroke-width:2px\n    style COMP3 fill:#ccccff,stroke:#333,stroke-width:2px\n    style SUB0 fill:#ffffcc,stroke:#333,stroke-width:2px\n    style SUB1 fill:#ffffcc,stroke:#333,stroke-width:2px\n    style SUB2 fill:#ffffcc,stroke:#333,stroke-width:2px\n    style IN0 fill:#ffccff,stroke:#333,stroke-width:2px\n    style IN1 fill:#ffccff,stroke:#333,stroke-width:2px\n    style IN2 fill:#ffccff,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#alternative-view-yaml-configuration-structure","title":"Alternative View: YAML Configuration Structure","text":"<pre><code>graph LR\n    subgraph \"YAML File: config.yaml\"\n        ROOT[Configuration Root]\n\n        subgraph \"ensemble:\"\n            E_ID[id: '0xCE15']\n            E_ECC[ecc: '0xE1']\n            E_MODE[transmission_mode: 'I']\n            E_LABEL[label:text: 'DAB Multiplex'short: 'DAB']\n        end\n\n        subgraph \"subchannels:\"\n            SC1[- uid: 'audio1'id: 0bitrate: 128input: 'file://...' ]\n            SC2[- uid: 'audio2'id: 1bitrate: 80input: 'udp://...']\n            SC3[- uid: 'audio3'id: 2bitrate: 96input: 'tcp://...']\n        end\n\n        subgraph \"services:\"\n            S1[- uid: 'svc1'id: '0x5001'label: 'Radio One']\n            S2[- uid: 'svc2'id: '0x5002'label: 'Radio Two']\n            S3[- uid: 'svc3'id: '0x5003'label: 'Radio Three']\n        end\n\n        subgraph \"components:\"\n            C1[- uid: 'comp1'service_id: '0x5001'subchannel_id: 0]\n            C2[- uid: 'comp2'service_id: '0x5002'subchannel_id: 1]\n            C3[- uid: 'comp3'service_id: '0x5003'subchannel_id: 2]\n        end\n\n        ROOT --&gt; E_ID\n        ROOT --&gt; E_ECC\n        ROOT --&gt; E_MODE\n        ROOT --&gt; E_LABEL\n\n        ROOT --&gt; SC1\n        ROOT --&gt; SC2\n        ROOT --&gt; SC3\n\n        ROOT --&gt; S1\n        ROOT --&gt; S2\n        ROOT --&gt; S3\n\n        ROOT --&gt; C1\n        ROOT --&gt; C2\n        ROOT --&gt; C3\n\n        C1 -.service_id.-&gt; S1\n        C1 -.subchannel_id.-&gt; SC1\n\n        C2 -.service_id.-&gt; S2\n        C2 -.subchannel_id.-&gt; SC2\n\n        C3 -.service_id.-&gt; S3\n        C3 -.subchannel_id.-&gt; SC3\n    end\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#hierarchy-levels-explained","title":"Hierarchy Levels Explained","text":""},{"location":"architecture/configuration-hierarchy/#level-1-ensemble-top-level","title":"Level 1: Ensemble (Top Level)","text":"<p>Purpose: Container for entire DAB multiplex</p> <p>Key Properties: - Ensemble ID (<code>id</code>): Unique 16-bit identifier (e.g., <code>0xCE15</code>) - Extended Country Code (<code>ecc</code>): Country identifier (e.g., <code>0xE1</code> for Germany) - Transmission Mode (<code>transmission_mode</code>): RF characteristics (I, II, III, or IV) - Label: Ensemble name displayed to listeners - LTO: Local Time Offset</p> <p>One per configuration file</p> <p>YAML Example: <pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'DAB Multiplex'\n    short: 'DAB'\n  lto_auto: true\n</code></pre></p> <p>Role: Defines the overall broadcast parameters that apply to all services.</p>"},{"location":"architecture/configuration-hierarchy/#level-2-services-radio-stations","title":"Level 2: Services (Radio Stations)","text":"<p>Purpose: Define radio stations that listeners can tune to</p> <p>Key Properties: - Service ID (<code>id</code>): Unique identifier for this service (e.g., <code>0x5001</code>) - Label: Station name (max 16 characters) - Short Label: Abbreviated name (max 8 characters) - PTY (Programme Type): Genre/category (News, Music, etc.) - Language: Language code</p> <p>Multiple services per ensemble (typically 3-10)</p> <p>YAML Example: <pre><code>services:\n  - uid: 'radio_one'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n      short: 'Radio1'\n    pty: 1       # News\n    language: 9  # English\n\n  - uid: 'radio_two'\n    id: '0x5002'\n    label:\n      text: 'Radio Two'\n      short: 'Radio2'\n    pty: 10      # Pop Music\n    language: 9\n</code></pre></p> <p>Role: Represents what listeners see in their radio's station list.</p>"},{"location":"architecture/configuration-hierarchy/#level-3-components-links","title":"Level 3: Components (Links)","text":"<p>Purpose: Link services to subchannels</p> <p>Key Properties: - Service ID (<code>service_id</code>): Which service this belongs to - Subchannel ID (<code>subchannel_id</code>): Which subchannel carries the data - Type: Component type (0=Audio, 60=PAD, etc.)</p> <p>One or more components per service</p> <p>YAML Example: <pre><code>components:\n  - uid: 'comp1'\n    service_id: '0x5001'    # Links to Radio One\n    subchannel_id: 0        # Uses subchannel 0\n    type: 0                 # Audio component\n\n  - uid: 'comp2'\n    service_id: '0x5002'    # Links to Radio Two\n    subchannel_id: 1        # Uses subchannel 1\n    type: 0\n</code></pre></p> <p>Role: Creates the mapping between what listeners see (services) and the actual data streams (subchannels).</p> <p>Important: <code>service_id</code> must match a service's <code>id</code>, and <code>subchannel_id</code> must match a subchannel's <code>id</code>.</p>"},{"location":"architecture/configuration-hierarchy/#level-4-subchannels-data-streams","title":"Level 4: Subchannels (Data Streams)","text":"<p>Purpose: Define the actual audio/data streams</p> <p>Key Properties: - Subchannel ID (<code>id</code>): Unique identifier (0-63) - Type: Stream type (audio, dabplus, packet, data) - Bitrate: Data rate in kbps - Start Address: Position in Capacity Units (CU) - Protection: Error protection configuration - Input URI: Source of audio data</p> <p>One per audio stream</p> <p>YAML Example: <pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'           # DAB (MPEG Layer II)\n    bitrate: 128            # 128 kbps\n    start_address: 0        # Starts at CU 0\n    protection:\n      level: 2              # Moderate protection\n      shortform: true\n    input: 'file://audio1.mp2'\n\n  - uid: 'audio2'\n    id: 1\n    type: 'dabplus'         # DAB+ (HE-AAC)\n    bitrate: 80\n    start_address: 128      # Starts at CU 128\n    protection:\n      level: 2\n    input: 'udp://239.1.2.3:5001'\n</code></pre></p> <p>Role: Describes the actual data streams that carry audio, including where they start in the multiplex and how they're protected.</p>"},{"location":"architecture/configuration-hierarchy/#level-5-inputs-audio-sources","title":"Level 5: Inputs (Audio Sources)","text":"<p>Purpose: Define where audio data comes from</p> <p>Types: - File: <code>file://path/to/audio.mp2</code> - UDP: <code>udp://host:port</code> - TCP: <code>tcp://host:port</code></p> <p>One input per subchannel (specified in subchannel's <code>input</code> field)</p> <p>Examples: <pre><code># File input (local or absolute path)\ninput: 'file://audio.mp2'\ninput: 'file:///absolute/path/audio.mp2'\n\n# UDP unicast\ninput: 'udp://192.168.1.100:5001'\n\n# UDP multicast\ninput: 'udp://239.1.2.3:5001'\n\n# TCP\ninput: 'tcp://192.168.1.100:5002'\n</code></pre></p> <p>Role: Provides the actual audio data to feed into the subchannels.</p>"},{"location":"architecture/configuration-hierarchy/#id-relationships","title":"ID Relationships","text":""},{"location":"architecture/configuration-hierarchy/#how-ids-link-together","title":"How IDs Link Together","text":"<pre><code>Service ID (0x5001)\n    \u2193 (referenced by component)\nComponent: service_id = 0x5001, subchannel_id = 0\n    \u2193 (links to subchannel)\nSubchannel ID (0)\n    \u2193 (has input)\nInput URI\n</code></pre> <p>Example: 1. Service <code>0x5001</code> is \"Radio One\" 2. Component links service <code>0x5001</code> to subchannel <code>0</code> 3. Subchannel <code>0</code> is 128 kbps DAB audio 4. Input <code>file://audio.mp2</code> provides data</p> <p>Result: When listener tunes to \"Radio One\" (0x5001), receiver knows to decode subchannel 0, which gets data from audio.mp2.</p>"},{"location":"architecture/configuration-hierarchy/#id-validation","title":"ID Validation","text":"<p>python-dabmux validates:</p> <ol> <li>Unique service IDs: No two services can have same ID</li> <li>Unique subchannel IDs: No two subchannels can have same ID</li> <li>Valid component references:</li> <li><code>service_id</code> must exist in services</li> <li><code>subchannel_id</code> must exist in subchannels</li> <li>Capacity limits: Total subchannels fit in available bandwidth</li> </ol>"},{"location":"architecture/configuration-hierarchy/#complete-example-configuration","title":"Complete Example Configuration","text":"<pre><code># Ensemble configuration\nensemble:\n  id: '0xCE15'              # Ensemble ID\n  ecc: '0xE1'               # Germany\n  transmission_mode: 'I'     # Mode I (standard)\n  label:\n    text: 'My DAB'\n    short: 'DAB'\n  lto_auto: true            # Auto local time offset\n\n# Subchannels (data streams)\nsubchannels:\n  # Classical station: high quality DAB\n  - uid: 'classical_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 192\n    start_address: 0\n    protection:\n      level: 3\n    input: 'file://classical.mp2'\n\n  # News station: speech, lower bitrate DAB+\n  - uid: 'news_audio'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    start_address: 200\n    protection:\n      level: 2\n    input: 'udp://239.1.2.3:5001'\n\n  # Pop station: DAB+\n  - uid: 'pop_audio'\n    id: 2\n    type: 'dabplus'\n    bitrate: 80\n    start_address: 300\n    protection:\n      level: 2\n    input: 'tcp://192.168.1.100:5002'\n\n# Services (radio stations)\nservices:\n  # Classical music station\n  - uid: 'classical_svc'\n    id: '0x5001'\n    label:\n      text: 'Classical FM'\n      short: 'Classic'\n    pty: 6      # Classical Music\n    language: 9  # English\n\n  # News station\n  - uid: 'news_svc'\n    id: '0x5002'\n    label:\n      text: 'News 24/7'\n      short: 'News24'\n    pty: 1      # News\n    language: 9\n\n  # Pop music station\n  - uid: 'pop_svc'\n    id: '0x5003'\n    label:\n      text: 'Pop Hits Radio'\n      short: 'PopHits'\n    pty: 10     # Pop Music\n    language: 9\n\n# Components (links)\ncomponents:\n  # Link Classical FM (0x5001) to subchannel 0\n  - uid: 'classical_comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n    type: 0\n\n  # Link News 24/7 (0x5002) to subchannel 1\n  - uid: 'news_comp'\n    service_id: '0x5002'\n    subchannel_id: 1\n    type: 0\n\n  # Link Pop Hits Radio (0x5003) to subchannel 2\n  - uid: 'pop_comp'\n    service_id: '0x5003'\n    subchannel_id: 2\n    type: 0\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#data-structure-in-memory","title":"Data Structure in Memory","text":""},{"location":"architecture/configuration-hierarchy/#python-object-hierarchy","title":"Python Object Hierarchy","text":"<p>When python-dabmux loads configuration, it creates:</p> <pre><code>DabEnsemble\n  \u251c\u2500 id: 0xCE15\n  \u251c\u2500 ecc: 0xE1\n  \u251c\u2500 label: DabLabel(\"My DAB\")\n  \u251c\u2500 services: List[DabService]\n  \u2502   \u251c\u2500 DabService(id=0x5001, label=\"Classical FM\")\n  \u2502   \u251c\u2500 DabService(id=0x5002, label=\"News 24/7\")\n  \u2502   \u2514\u2500 DabService(id=0x5003, label=\"Pop Hits Radio\")\n  \u251c\u2500 subchannels: List[DabSubchannel]\n  \u2502   \u251c\u2500 DabSubchannel(id=0, bitrate=192, input=\"file://...\")\n  \u2502   \u251c\u2500 DabSubchannel(id=1, bitrate=64, input=\"udp://...\")\n  \u2502   \u2514\u2500 DabSubchannel(id=2, bitrate=80, input=\"tcp://...\")\n  \u2514\u2500 components: List[DabComponent]\n      \u251c\u2500 DabComponent(service_id=0x5001, subchannel_id=0)\n      \u251c\u2500 DabComponent(service_id=0x5002, subchannel_id=1)\n      \u2514\u2500 DabComponent(service_id=0x5003, subchannel_id=2)\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#lookup-operations","title":"Lookup Operations","text":"<p>Find service by ID: <pre><code>def get_service(ensemble: DabEnsemble, service_id: int) -&gt; DabService:\n    for service in ensemble.services:\n        if service.id == service_id:\n            return service\n    raise ValueError(f\"Service {service_id:04X} not found\")\n</code></pre></p> <p>Find subchannel for service: <pre><code>def get_subchannel_for_service(ensemble: DabEnsemble,\n                                 service_id: int) -&gt; DabSubchannel:\n    # Find component linking service to subchannel\n    for component in ensemble.components:\n        if component.service_id == service_id:\n            subchannel_id = component.subchannel_id\n            break\n    else:\n        raise ValueError(f\"No component for service {service_id:04X}\")\n\n    # Find subchannel\n    for subchannel in ensemble.subchannels:\n        if subchannel.id == subchannel_id:\n            return subchannel\n\n    raise ValueError(f\"Subchannel {subchannel_id} not found\")\n</code></pre></p>"},{"location":"architecture/configuration-hierarchy/#configuration-flow","title":"Configuration Flow","text":""},{"location":"architecture/configuration-hierarchy/#1-parse-yaml","title":"1. Parse YAML","text":"<pre><code>with open('config.yaml') as f:\n    config_dict = yaml.safe_load(f)\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#2-create-ensemble","title":"2. Create Ensemble","text":"<pre><code>ensemble = DabEnsemble(\n    id=config_dict['ensemble']['id'],\n    ecc=config_dict['ensemble']['ecc'],\n    # ...\n)\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#3-add-subchannels","title":"3. Add Subchannels","text":"<pre><code>for sub_cfg in config_dict['subchannels']:\n    subchannel = DabSubchannel(\n        id=sub_cfg['id'],\n        bitrate=sub_cfg['bitrate'],\n        input_uri=sub_cfg['input'],\n        # ...\n    )\n    ensemble.subchannels.append(subchannel)\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#4-add-services","title":"4. Add Services","text":"<pre><code>for svc_cfg in config_dict['services']:\n    service = DabService(\n        id=svc_cfg['id'],\n        label=DabLabel(svc_cfg['label']['text']),\n        # ...\n    )\n    ensemble.services.append(service)\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#5-add-components-links","title":"5. Add Components (Links)","text":"<pre><code>for comp_cfg in config_dict['components']:\n    component = DabComponent(\n        service_id=comp_cfg['service_id'],\n        subchannel_id=comp_cfg['subchannel_id'],\n        # ...\n    )\n    ensemble.components.append(component)\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#6-validate","title":"6. Validate","text":"<pre><code># Check all service_ids in components exist\nfor component in ensemble.components:\n    if not any(s.id == component.service_id for s in ensemble.services):\n        raise ValueError(f\"Unknown service_id: {component.service_id:04X}\")\n\n# Check all subchannel_ids in components exist\nfor component in ensemble.components:\n    if not any(s.id == component.subchannel_id for s in ensemble.subchannels):\n        raise ValueError(f\"Unknown subchannel_id: {component.subchannel_id}\")\n</code></pre>"},{"location":"architecture/configuration-hierarchy/#common-mistakes","title":"Common Mistakes","text":""},{"location":"architecture/configuration-hierarchy/#1-mismatched-service-ids","title":"1. Mismatched Service IDs","text":"<p>Wrong: <pre><code>services:\n  - id: '0x5001'  # Service ID\ncomponents:\n  - service_id: '0x5002'  # Different ID!\n</code></pre></p> <p>Error: <code>Unknown service_id: 0x5002</code></p>"},{"location":"architecture/configuration-hierarchy/#2-mismatched-subchannel-ids","title":"2. Mismatched Subchannel IDs","text":"<p>Wrong: <pre><code>subchannels:\n  - id: 0  # Subchannel ID\ncomponents:\n  - subchannel_id: 1  # Different ID!\n</code></pre></p> <p>Error: <code>Unknown subchannel_id: 1</code></p>"},{"location":"architecture/configuration-hierarchy/#3-duplicate-ids","title":"3. Duplicate IDs","text":"<p>Wrong: <pre><code>services:\n  - id: '0x5001'\n  - id: '0x5001'  # Duplicate!\n</code></pre></p> <p>Error: <code>Duplicate service ID: 0x5001</code></p>"},{"location":"architecture/configuration-hierarchy/#4-missing-component","title":"4. Missing Component","text":"<p>Wrong: <pre><code>services:\n  - id: '0x5001'\nsubchannels:\n  - id: 0\n# Missing component to link them!\n</code></pre></p> <p>Result: Service defined but no audio stream assigned.</p>"},{"location":"architecture/configuration-hierarchy/#see-also","title":"See Also","text":"<ul> <li>System Design: Overall architecture</li> <li>Configuration Reference: Complete YAML reference</li> <li>Configuration Examples: Working examples</li> <li>Basic Concepts: DAB terminology</li> </ul>"},{"location":"architecture/data-flow/","title":"Data Flow","text":"<p>Complete pipeline showing how data flows from inputs to outputs in python-dabmux.</p>"},{"location":"architecture/data-flow/#complete-data-flow-diagram","title":"Complete Data Flow Diagram","text":"<pre><code>flowchart TD\n    subgraph \"Input Sources\"\n        FILE1[Audio File 1audio1.mp2]\n        FILE2[Audio File 2audio2.mp2]\n        UDP[UDP Stream239.1.2.3:5001]\n        TCP[TCP Stream192.168.1.100:5002]\n    end\n\n    subgraph \"Input Layer\"\n        FINPUT1[FileInput 1]\n        FINPUT2[FileInput 2]\n        UINPUT[UDPInput]\n        TINPUT[TCPInput]\n    end\n\n    subgraph \"Input Buffers\"\n        BUF1[Buffer 110 frames]\n        BUF2[Buffer 210 frames]\n        BUF3[Buffer 310 frames]\n        BUF4[Buffer 410 frames]\n    end\n\n    subgraph \"Core Processing\"\n        MUX[DabMultiplexer]\n        AUDIO_PARSE[Audio ParserMPEG FrameDetection]\n    end\n\n    subgraph \"FIG Generation (Parallel)\"\n        CAROUSEL[FIG CarouselSchedule FIGs]\n        FIG0_0[FIG 0/0Ensemble Info]\n        FIG0_1[FIG 0/1Subchannel Org]\n        FIG0_2[FIG 0/2Service Org]\n        FIG1_0[FIG 1/0Ensemble Label]\n        FIG1_1[FIG 1/1Service Labels]\n        FIC[FIC Encoder32 FIBs]\n    end\n\n    subgraph \"Frame Assembly\"\n        ETI_BUILD[ETI Frame Builder]\n        SYNC_GEN[Generate SYNC]\n        FC_GEN[Generate FC]\n        STC_GEN[Generate STCs]\n        MST_POP[Populate MST]\n        CRC_CALC[Calculate CRCs]\n        PACK[Pack to Bytes]\n    end\n\n    subgraph \"Output Layer\"\n        FILE_OUT[FileOutput]\n        EDI_ENC[EDI Encoder]\n        PFT_FRAG[PFT Fragmenter]\n        UDP_OUT[UDP Output]\n    end\n\n    subgraph \"Output Destinations\"\n        ETI_FILE[output.eti]\n        NETWORK[239.1.2.3:12000]\n    end\n\n    FILE1 --&gt; FINPUT1\n    FILE2 --&gt; FINPUT2\n    UDP --&gt; UINPUT\n    TCP --&gt; TINPUT\n\n    FINPUT1 --&gt; BUF1\n    FINPUT2 --&gt; BUF2\n    UINPUT --&gt; BUF3\n    TINPUT --&gt; BUF4\n\n    BUF1 --&gt; MUX\n    BUF2 --&gt; MUX\n    BUF3 --&gt; MUX\n    BUF4 --&gt; MUX\n\n    MUX --&gt; AUDIO_PARSE\n    AUDIO_PARSE --&gt; ETI_BUILD\n\n    MUX --&gt; CAROUSEL\n    CAROUSEL --&gt; FIG0_0\n    CAROUSEL --&gt; FIG0_1\n    CAROUSEL --&gt; FIG0_2\n    CAROUSEL --&gt; FIG1_0\n    CAROUSEL --&gt; FIG1_1\n\n    FIG0_0 --&gt; FIC\n    FIG0_1 --&gt; FIC\n    FIG0_2 --&gt; FIC\n    FIG1_0 --&gt; FIC\n    FIG1_1 --&gt; FIC\n\n    FIC --&gt; ETI_BUILD\n\n    ETI_BUILD --&gt; SYNC_GEN\n    ETI_BUILD --&gt; FC_GEN\n    ETI_BUILD --&gt; STC_GEN\n    ETI_BUILD --&gt; MST_POP\n    ETI_BUILD --&gt; CRC_CALC\n    ETI_BUILD --&gt; PACK\n\n    PACK --&gt; FILE_OUT\n    PACK --&gt; EDI_ENC\n\n    FILE_OUT --&gt; ETI_FILE\n\n    EDI_ENC --&gt; PFT_FRAG\n    PFT_FRAG --&gt; UDP_OUT\n    UDP_OUT --&gt; NETWORK\n\n    style MUX fill:#f9f,stroke:#333,stroke-width:3px\n    style FIC fill:#bbf,stroke:#333,stroke-width:2px\n    style ETI_BUILD fill:#bfb,stroke:#333,stroke-width:2px\n    style PACK fill:#fbb,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"architecture/data-flow/#detailed-flow-description","title":"Detailed Flow Description","text":""},{"location":"architecture/data-flow/#stage-1-input-reading","title":"Stage 1: Input Reading","text":"<p>Purpose: Read audio data from various sources into buffers</p> <p>Process: <pre><code>1. For each subchannel:\n   a. Identify input type (file/UDP/TCP)\n   b. Open input source\n   c. Read audio frames\n   d. Store in circular buffer\n   e. Track buffer status (full/empty/underrun)\n</code></pre></p> <p>Input Classes:</p> <ul> <li> <p>FileInput: Sequential file reading   <pre><code>def read(self, size: int) -&gt; bytes:\n    data = self.file.read(size)\n    if len(data) &lt; size:  # EOF\n        if self.loop:\n            self.file.seek(0)  # Loop\n        else:\n            data += b'\\x00' * (size - len(data))  # Pad\n    return data\n</code></pre></p> </li> <li> <p>UDPInput: Non-blocking UDP receive   <pre><code>def read(self, size: int) -&gt; bytes:\n    data = b''\n    while len(data) &lt; size:\n        packet = self.socket.recv(4096)\n        data += packet\n    return data[:size]\n</code></pre></p> </li> <li> <p>TCPInput: Blocking TCP receive   <pre><code>def read(self, size: int) -&gt; bytes:\n    data = b''\n    while len(data) &lt; size:\n        chunk = self.socket.recv(size - len(data))\n        data += chunk\n    return data\n</code></pre></p> </li> </ul> <p>Buffering: - Default: 10 frames per input - Underrun detection: Log warning, fill with zeros - Overrun detection: Drop oldest data</p>"},{"location":"architecture/data-flow/#stage-2-audio-parsing","title":"Stage 2: Audio Parsing","text":"<p>Purpose: Parse MPEG frames and validate format</p> <p>Process: <pre><code>1. Scan for MPEG sync word (0xFFE, 0xFFF)\n2. Parse frame header:\n   - MPEG version (1 or 2)\n   - Layer (II)\n   - Bitrate\n   - Sample rate\n3. Validate frame size\n4. Extract frame data\n5. Update statistics\n</code></pre></p> <p>MPEG Frame Structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header (4 bytes)                     \u2502\n\u2502  \u251c\u2500 Sync (11 bits): 0xFFE           \u2502\n\u2502  \u251c\u2500 Version (2 bits): MPEG-1        \u2502\n\u2502  \u251c\u2500 Layer (2 bits): Layer II        \u2502\n\u2502  \u251c\u2500 Bitrate (4 bits)                \u2502\n\u2502  \u251c\u2500 Sample rate (2 bits)            \u2502\n\u2502  \u2514\u2500 ...                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Audio Data (variable)                \u2502\n\u2502  (depends on bitrate)                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Validation: <pre><code>def parse_mpeg_frame(data: bytes) -&gt; MpegFrame:\n    # Check sync word\n    if (data[0] &amp; 0xFF) != 0xFF or (data[1] &amp; 0xE0) != 0xE0:\n        raise ValueError(\"Invalid MPEG sync\")\n\n    # Parse header bits\n    version = (data[1] &gt;&gt; 3) &amp; 0x03\n    layer = (data[1] &gt;&gt; 1) &amp; 0x03\n    bitrate_idx = (data[2] &gt;&gt; 4) &amp; 0x0F\n\n    # Validate\n    if layer != 0x02:  # Layer II\n        raise ValueError(f\"Expected Layer II, got {layer}\")\n\n    return MpegFrame(...)\n</code></pre></p>"},{"location":"architecture/data-flow/#stage-3-fig-generation","title":"Stage 3: FIG Generation","text":"<p>Purpose: Generate Fast Information Groups describing the ensemble</p> <p>Process: <pre><code>1. Check FIG carousel timers\n2. Select FIGs to include this frame\n3. Generate each FIG:\n   - FIG 0/0: Ensemble ID, ECC\n   - FIG 0/1: Subchannel table\n   - FIG 0/2: Service-component mapping\n   - FIG 1/0: Ensemble label\n   - FIG 1/1: Service labels\n4. Encode FIGs into FIBs (Fast Information Blocks)\n5. Calculate CRC-8 for each FIB\n6. Pad with 0xFF if needed\n</code></pre></p> <p>FIG Carousel Timing:</p> FIG Type Repetition Frames 0/0 96 ms Every 1 frame 0/1 ~1 sec Every 10 frames 0/2 ~1 sec Every 10 frames 1/0 ~1 sec Every 10 frames 1/1 ~1 sec Every 10 frames Others ~10 sec Every 100 frames <p>FIG 0/0 Example (Ensemble Information): <pre><code>Byte 0: 0x00 (FIG type 0, extension 0)\nByte 1: 0xCE (Ensemble ID high byte)\nByte 2: 0x15 (Ensemble ID low byte)\nByte 3: 0xE1 (ECC)\n...\n</code></pre></p> <p>FIC Encoding: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 FIB 0 (3 bytes)     \u2502 \u2190 FIG 0/0 data + CRC-8\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 FIB 1 (3 bytes)     \u2502 \u2190 FIG 0/1 data + CRC-8\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ...                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 FIB 31 (3 bytes)    \u2502 \u2190 Padding (0xFFFF) + CRC-8\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Total: 96 bytes\n</code></pre></p>"},{"location":"architecture/data-flow/#stage-4-frame-assembly","title":"Stage 4: Frame Assembly","text":"<p>Purpose: Combine all components into complete ETI frame</p> <p>Process: <pre><code>1. Create SYNC field (ERR + 0x073AB6)\n2. Generate FC (Frame Characterization):\n   - FCT (frame count)\n   - NST (number of streams)\n   - MID (mode ID)\n3. Generate STC for each subchannel:\n   - SCID (subchannel ID)\n   - SAD (start address)\n   - STL (stream length)\n4. Calculate EOH CRC (FC + all STCs)\n5. Insert FIC data (96 bytes)\n6. Populate MST with audio data\n7. Calculate EOF CRC (MST)\n8. Add TIST if enabled\n</code></pre></p> <p>Assembly Order: <pre><code>def assemble_frame(self) -&gt; EtiFrame:\n    frame = EtiFrame()\n\n    # 1. SYNC\n    frame.sync.err = 0x00\n    frame.sync.fsync = 0x073AB6\n\n    # 2. FC\n    frame.fc.fct = self.frame_count % 250\n    frame.fc.nst = len(self.subchannels) - 1\n    frame.fc.mid = 0x01  # Mode I\n\n    # 3. STCs\n    for i, subchan in enumerate(self.subchannels):\n        stc = SubChannelStreamChar()\n        stc.scid = subchan.id\n        stc.sad = subchan.start_address\n        stc.stl = calculate_stream_length(subchan)\n        frame.stc.append(stc)\n\n    # 4. EOH with CRC\n    frame.eoh.crc = calculate_crc16(frame.fc, frame.stc)\n\n    # 5. FIC\n    frame.fic = self.fic_encoder.encode()\n\n    # 6. MST\n    frame.mst = self.populate_mst()\n\n    # 7. EOF with CRC\n    frame.eof.crc = calculate_crc16(frame.mst)\n\n    # 8. TIST (optional)\n    if self.enable_tist:\n        frame.tist = self.calculate_tist()\n\n    return frame\n</code></pre></p>"},{"location":"architecture/data-flow/#stage-5-output-writing","title":"Stage 5: Output Writing","text":"<p>Purpose: Serialize frame and write to destination</p>"},{"location":"architecture/data-flow/#file-output","title":"File Output","text":"<p>Raw ETI: <pre><code>def write(self, frame: EtiFrame) -&gt; None:\n    data = frame.pack()  # Serialize to bytes\n    self.file.write(data)\n</code></pre></p> <p>Framed ETI: <pre><code>def write(self, frame: EtiFrame) -&gt; None:\n    data = frame.pack()\n    # Add frame delimiter\n    self.file.write(b'FR')\n    self.file.write(struct.pack('&gt;H', len(data)))\n    self.file.write(data)\n</code></pre></p> <p>Streamed ETI: <pre><code>def write(self, frame: EtiFrame) -&gt; None:\n    data = frame.pack()\n    # Add timestamp\n    self.file.write(struct.pack('&gt;Q', frame.tist or 0))\n    self.file.write(data)\n</code></pre></p>"},{"location":"architecture/data-flow/#edi-output","title":"EDI Output","text":"<p>Conversion to EDI: <pre><code>ETI Frame\n  \u2193\nTAG Items (*ptr, deti, estN)\n  \u2193\nAF Packet (8-byte aligned, CRC)\n  \u2193\nPFT Fragmentation (optional)\n  \u2193\nPF Fragments with FEC (optional)\n  \u2193\nUDP/TCP Output\n</code></pre></p> <p>EDI Encoding: <pre><code>def encode_edi(self, frame: EtiFrame) -&gt; bytes:\n    # 1. Create TAG items\n    tags = []\n    tags.append(create_ptr_tag())       # Protocol tag\n    tags.append(create_deti_tag(frame)) # ETI data\n    for i, subchan in enumerate(frame.subchannels):\n        tags.append(create_est_tag(i, subchan))\n\n    # 2. Create AF packet\n    af_packet = create_af_packet(tags)\n\n    # 3. Optionally fragment with PFT\n    if self.enable_pft:\n        fragments = self.pft.fragment(af_packet)\n        return fragments\n    else:\n        return af_packet\n</code></pre></p> <p>PFT Fragmentation: <pre><code>Large AF Packet (e.g., 6000 bytes)\n  \u2193\nFragment 1 (1400 bytes)\nFragment 2 (1400 bytes)\nFragment 3 (1400 bytes)\nFragment 4 (1400 bytes)\nFragment 5 (1400 bytes)\n  \u2193\nAdd RS-FEC (2 parity fragments)\n  \u2193\nFragment 1, 2, 3, 4, 5, P1, P2\n</code></pre></p>"},{"location":"architecture/data-flow/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/data-flow/#throughput","title":"Throughput","text":"<p>Mode I (typical): - Frame rate: 10.42 frames/second - Frame size: ~6000 bytes - Throughput: ~62 KB/s (500 kbps) - CPU: 10-20% of one core</p>"},{"location":"architecture/data-flow/#latency","title":"Latency","text":"<p>End-to-end latency: <pre><code>Input read:       ~10 ms (buffering)\nAudio parsing:    ~1 ms\nFIG generation:   ~1 ms\nFrame assembly:   ~2 ms\nCRC calculation:  ~1 ms\nOutput write:     ~1 ms (file) or ~5 ms (network)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal:            ~16-20 ms\n</code></pre></p>"},{"location":"architecture/data-flow/#memory-usage","title":"Memory Usage","text":"<p>Per-frame memory: <pre><code>Input buffers:    ~60 KB (10 frames \u00d7 6 KB)\nFrame structure:  ~6 KB\nFIG cache:        ~2 KB\nOutput buffer:    ~6 KB\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal:            ~75 KB per active multiplex\n</code></pre></p>"},{"location":"architecture/data-flow/#data-transformations","title":"Data Transformations","text":""},{"location":"architecture/data-flow/#input-mst","title":"Input \u2192 MST","text":"<p>Transformation: <pre><code>MPEG File (audio.mp2)\n  \u2193 [FileInput.read()]\nRaw bytes\n  \u2193 [Audio parser]\nMPEG frames\n  \u2193 [Extract payload]\nAudio data\n  \u2193 [Populate MST]\nMain Service Transport\n</code></pre></p>"},{"location":"architecture/data-flow/#fig-fic","title":"FIG \u2192 FIC","text":"<p>Transformation: <pre><code>Ensemble Config\n  \u2193 [FIG generators]\nFIG 0/0, 0/1, 0/2, 1/0, 1/1\n  \u2193 [FIG Carousel]\nSelected FIGs for this frame\n  \u2193 [FIC Encoder]\n32 FIBs (3 bytes each)\n  \u2193 [CRC-8]\n96 bytes FIC\n</code></pre></p>"},{"location":"architecture/data-flow/#eti-edi","title":"ETI \u2192 EDI","text":"<p>Transformation: <pre><code>ETI Frame\n  \u2193 [EDI Encoder]\nTAG Items (*ptr, deti, estN)\n  \u2193 [AF Packet]\nAF packet (aligned, CRC'd)\n  \u2193 [PFT Fragmenter]\nPF fragments\n  \u2193 [RS-FEC]\nPF fragments + parity\n  \u2193 [UDP Output]\nNetwork packets\n</code></pre></p>"},{"location":"architecture/data-flow/#error-handling-in-pipeline","title":"Error Handling in Pipeline","text":""},{"location":"architecture/data-flow/#input-stage","title":"Input Stage","text":"<p>Error: File not found Action: Raise FileNotFoundError at startup</p> <p>Error: Network timeout Action: Log warning, retry 3 times, then fail</p> <p>Error: Invalid MPEG frame Action: Log warning, skip frame, continue</p>"},{"location":"architecture/data-flow/#processing-stage","title":"Processing Stage","text":"<p>Error: Capacity exceeded Action: Raise ConfigurationError at startup</p> <p>Error: Invalid FIG Action: Log error, skip FIG, continue</p>"},{"location":"architecture/data-flow/#output-stage","title":"Output Stage","text":"<p>Error: Can't write file Action: Raise IOError, stop multiplexer</p> <p>Error: Network unreachable Action: Log error, retry with exponential backoff</p>"},{"location":"architecture/data-flow/#optimization-points","title":"Optimization Points","text":""},{"location":"architecture/data-flow/#hot-paths","title":"Hot Paths","text":"<ol> <li>MPEG frame parsing (per frame, per subchannel)</li> <li>CRC calculation (per frame, multiple times)</li> <li>FIG encoding (per frame)</li> <li>Byte packing (per frame)</li> </ol>"},{"location":"architecture/data-flow/#optimizations","title":"Optimizations","text":"<p>Caching: - Cache FIG bytes (many don't change) - Cache CRC tables - Cache character set mappings</p> <p>Pre-allocation: - Reuse frame buffers - Pre-allocate output buffers</p> <p>Batch operations: - Read multiple frames from inputs - Write buffered output</p>"},{"location":"architecture/data-flow/#see-also","title":"See Also","text":"<ul> <li>System Design: Overall architecture</li> <li>ETI Frames: Frame structure details</li> <li>FIG Carousel: FIG scheduling</li> <li>EDI Protocol: Network output protocol</li> </ul>"},{"location":"architecture/edi-protocol/","title":"EDI Protocol Stack","text":"<p>Layer-by-layer breakdown of the EDI (Ensemble Data Interface) protocol for transmitting ETI over IP networks.</p>"},{"location":"architecture/edi-protocol/#edi-protocol-stack-diagram","title":"EDI Protocol Stack Diagram","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        ETI[ETI Frame~6000 bytesAudio + Metadata]\n    end\n\n    subgraph \"EDI TAG Layer\"\n        PTR[*ptr TAGProtocol Type]\n        DETI[deti TAGETI Data]\n        EST[est TAGStream DataestN for each stream]\n    end\n\n    subgraph \"TAG Packet Layer\"\n        TAGPKT[TAG Packet8-byte alignedAll TAGs concatenated]\n    end\n\n    subgraph \"AF Packet Layer\"\n        AFSYNC[SYNC: 'AF'2 bytes]\n        AFLEN[LEN4 bytesPacket length]\n        AFSEQ[SEQ2 bytesSequence number]\n        AFCRC[CRC-324 bytes]\n        AFPAYLOAD[PayloadTAG Packet]\n    end\n\n    subgraph \"PFT Layer (Optional)\"\n        PFTSYNC[SYNC: 'PF'2 bytes]\n        PFTSEQ[SEQ2 bytes]\n        PFTFEC[FEC InfoFEC params]\n        PFTADDR[AddressingFrag info]\n        PFTPAYLOAD[PayloadAF fragment]\n        PFTRS[RS ParityOptionalReed-Solomon]\n    end\n\n    subgraph \"Transport Layer\"\n        UDP[UDP DatagramorTCP Stream]\n    end\n\n    subgraph \"Network Layer\"\n        IP[IP PacketUnicast/Multicast]\n    end\n\n    ETI --&gt; PTR\n    ETI --&gt; DETI\n    ETI --&gt; EST\n\n    PTR --&gt; TAGPKT\n    DETI --&gt; TAGPKT\n    EST --&gt; TAGPKT\n\n    TAGPKT --&gt; AFSYNC\n    TAGPKT --&gt; AFLEN\n    TAGPKT --&gt; AFSEQ\n    TAGPKT --&gt; AFPAYLOAD\n    TAGPKT --&gt; AFCRC\n\n    AFSYNC --&gt; PFTSYNC\n    AFLEN --&gt; PFTSEQ\n    AFSEQ --&gt; PFTFEC\n    AFPAYLOAD --&gt; PFTADDR\n    AFCRC --&gt; PFTPAYLOAD\n\n    PFTPAYLOAD --&gt; PFTRS\n    PFTRS --&gt; UDP\n    UDP --&gt; IP\n\n    style ETI fill:#ffcccc,stroke:#333,stroke-width:2px\n    style TAGPKT fill:#ccffcc,stroke:#333,stroke-width:2px\n    style AFPAYLOAD fill:#ccccff,stroke:#333,stroke-width:2px\n    style PFTPAYLOAD fill:#ffffcc,stroke:#333,stroke-width:2px\n    style UDP fill:#ffccff,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"architecture/edi-protocol/#protocol-layers-overview","title":"Protocol Layers Overview","text":""},{"location":"architecture/edi-protocol/#1-application-layer-eti-frame","title":"1. Application Layer: ETI Frame","text":"<p>Purpose: Raw ETI data to be transmitted</p> <p>Contents: - Complete ETI frame (SYNC, FC, STC, FIC, MST, EOF, TIST) - Size: Variable, typically ~6000 bytes for Mode I</p> <p>Example: <pre><code>ETI Frame (5604 bytes):\n  SYNC (4) + FC (4) + STC (12) + EOH (4) +\n  FIC (96) + MST (5472) + EOF (4) + TIST (4)\n</code></pre></p>"},{"location":"architecture/edi-protocol/#2-edi-tag-layer","title":"2. EDI TAG Layer","text":"<p>Purpose: Structure ETI data into TAG items</p> <p>TAG items are TLV (Type-Length-Value) structures that encapsulate different parts of the ETI frame.</p>"},{"location":"architecture/edi-protocol/#tag-structure","title":"TAG Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Name \u2502 Len  \u2502   Value      \u2502\n\u2502 4B   \u2502 4B   \u2502  variable    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Fields: - Name: 4-character ASCII identifier - Length: 32-bit big-endian length (of Value) - Value: TAG-specific data</p>"},{"location":"architecture/edi-protocol/#tag-types","title":"TAG Types","text":"<p>*ptr - Protocol Type and Revision</p> <pre><code>TAG Name: '*ptr'\nLength: 4 bytes\nValue:\n  Byte 0-1: Protocol type (\"TA\", \"ET\", \"ED\")\n  Byte 2-3: Revision (0x0001)\n</code></pre> <p>Example: <pre><code>2A 70 74 72  # \"*ptr\"\n00 00 00 04  # Length = 4\n45 54 00 01  # \"ET\" + revision 0x0001\n</code></pre></p> <p>deti - DAB ETI Data</p> <pre><code>TAG Name: 'deti'\nLength: Variable (depends on frame)\nValue:\n  Complete ETI frame (all fields)\n</code></pre> <p>Example: <pre><code>64 65 74 69  # \"deti\"\n00 00 15 E4  # Length = 5604\n[ETI frame bytes...]\n</code></pre></p> <p>estN - Ensemble Stream Data (N = stream number)</p> <pre><code>TAG Name: 'est0', 'est1', 'est2', etc.\nLength: Variable\nValue:\n  Audio/data for specific stream\n</code></pre> <p>Example for stream 0: <pre><code>65 73 74 30  # \"est0\"\n00 00 01 40  # Length = 320\n[Stream 0 audio data...]\n</code></pre></p>"},{"location":"architecture/edi-protocol/#3-tag-packet-layer","title":"3. TAG Packet Layer","text":"<p>Purpose: Concatenate all TAGs into a single packet with 8-byte alignment</p> <p>Structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 *ptr TAG        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 deti TAG        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 est0 TAG        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 est1 TAG        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ...             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Padding (align) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Alignment: - Total packet size must be multiple of 8 bytes - Pad with 0x00 bytes if needed</p> <p>Example: <pre><code>def create_tag_packet(tags: List[bytes]) -&gt; bytes:\n    packet = b''.join(tags)\n\n    # Align to 8 bytes\n    padding = (8 - (len(packet) % 8)) % 8\n    packet += b'\\x00' * padding\n\n    return packet\n</code></pre></p>"},{"location":"architecture/edi-protocol/#4-af-packet-layer-application-framing","title":"4. AF Packet Layer (Application Framing)","text":"<p>Purpose: Frame TAG packets with sync, length, sequence, and CRC</p>"},{"location":"architecture/edi-protocol/#af-packet-structure","title":"AF Packet Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC: \"AF\"  (2 bytes)\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 LEN         (4 bytes)\u2502  Length of entire AF packet\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 SEQ         (2 bytes)\u2502  Sequence number\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 AR          (1 byte) \u2502  Address type (0=unicast)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PT          (1 byte) \u2502  Protocol type (0x02=TAG)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Payload   (variable) \u2502  TAG Packet\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 CRC-32      (4 bytes)\u2502  CRC of entire packet\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/edi-protocol/#field-descriptions","title":"Field Descriptions","text":"<p>SYNC (2 bytes): - Fixed value: <code>0x4146</code> (\"AF\" in ASCII) - Used for packet synchronization</p> <p>LEN (4 bytes, big-endian): - Total AF packet length including header and CRC - Example: <code>0x000015F4</code> = 5620 bytes</p> <p>SEQ (2 bytes, big-endian): - Sequence number (0-65535, wraps) - Increments for each AF packet - Used to detect missing packets</p> <p>AR (1 byte): - Address type - <code>0x00</code>: Not used (unicast) - <code>0x01</code>: Multicast group address</p> <p>PT (1 byte): - Protocol type - <code>0x02</code>: TAG packet (most common)</p> <p>Payload (variable): - TAG packet data (8-byte aligned)</p> <p>CRC-32 (4 bytes): - CRC-32 of entire AF packet (SYNC through Payload) - Polynomial: 0x04C11DB7 - Initial: 0xFFFFFFFF - Final XOR: 0xFFFFFFFF</p>"},{"location":"architecture/edi-protocol/#af-packet-creation","title":"AF Packet Creation","text":"<pre><code>def create_af_packet(tag_packet: bytes, seq: int) -&gt; bytes:\n    # Header\n    sync = b'AF'\n    ar = 0x00  # Not used\n    pt = 0x02  # TAG packet\n\n    # Length (will be calculated)\n    payload = tag_packet\n    total_len = 2 + 4 + 2 + 1 + 1 + len(payload) + 4\n\n    # Assemble packet\n    packet = bytearray()\n    packet += sync\n    packet += struct.pack('&gt;I', total_len)  # LEN\n    packet += struct.pack('&gt;H', seq &amp; 0xFFFF)  # SEQ\n    packet += bytes([ar, pt])\n    packet += payload\n\n    # Calculate CRC-32\n    crc = calculate_crc32(packet)\n    packet += struct.pack('&gt;I', crc)\n\n    return bytes(packet)\n</code></pre>"},{"location":"architecture/edi-protocol/#5-pft-layer-protection-fragmentation-transport","title":"5. PFT Layer (Protection, Fragmentation, Transport)","text":"<p>Purpose: Fragment large AF packets and add FEC for error recovery</p>"},{"location":"architecture/edi-protocol/#when-to-use-pft","title":"When to Use PFT","text":"<p>Use PFT when: - AF packet exceeds network MTU (~1500 bytes) - Network is lossy (wireless, WAN) - Error recovery needed (Reed-Solomon FEC)</p> <p>Skip PFT when: - AF packet fits in single UDP datagram - Network is reliable (wired LAN) - Low latency required</p>"},{"location":"architecture/edi-protocol/#pft-fragment-structure","title":"PFT Fragment Structure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC: \"PF\"  (2 bytes)\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PSEQ        (2 bytes)\u2502  PFT sequence number\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Findex      (3 bytes)\u2502  Fragment index (24-bit)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Fcount      (3 bytes)\u2502  Total fragments (24-bit)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 FEC         (1 byte) \u2502  FEC parameters\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Addr        (1 byte) \u2502  Addressing\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Plen        (2 bytes)\u2502  Payload length\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 RSk         (1 byte) \u2502  RS data blocks\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 RSz         (1 byte) \u2502  RS redundancy\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Payload   (variable) \u2502  AF fragment\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 RS Parity (optional) \u2502  Reed-Solomon FEC\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/edi-protocol/#field-descriptions_1","title":"Field Descriptions","text":"<p>SYNC (2 bytes): - Fixed value: <code>0x5046</code> (\"PF\" in ASCII)</p> <p>PSEQ (2 bytes): - PFT sequence number - Increments for each AF packet (not per fragment) - All fragments of same AF packet have same PSEQ</p> <p>Findex (3 bytes): - Fragment index (0-based) - Which fragment this is (0, 1, 2, ...)</p> <p>Fcount (3 bytes): - Total number of fragments - Includes data fragments + parity fragments</p> <p>FEC (1 byte): - Bit 7: FEC enabled (1=yes, 0=no) - Bits 6-0: Reserved</p> <p>Addr (1 byte): - Addressing information</p> <p>Plen (2 bytes): - Payload length for this fragment</p> <p>RSk (1 byte): - Number of RS data blocks (k) - Only if FEC enabled</p> <p>RSz (1 byte): - Number of RS parity blocks (m) - Only if FEC enabled</p> <p>Payload (variable): - Fragment of AF packet</p> <p>RS Parity (optional): - Reed-Solomon parity data - Only on parity fragments when FEC enabled</p>"},{"location":"architecture/edi-protocol/#fragmentation-algorithm","title":"Fragmentation Algorithm","text":"<pre><code>def fragment_af_packet(af_packet: bytes, max_frag_size: int,\n                       fec_enabled: bool, fec_m: int) -&gt; List[bytes]:\n    \"\"\"\n    Fragment AF packet into PFT fragments.\n\n    Args:\n        af_packet: Complete AF packet\n        max_frag_size: Maximum fragment payload size\n        fec_enabled: Enable Reed-Solomon FEC\n        fec_m: Number of parity fragments (if FEC enabled)\n\n    Returns:\n        List of PFT fragments\n    \"\"\"\n    # Calculate data fragments\n    num_data_frags = (len(af_packet) + max_frag_size - 1) // max_frag_size\n\n    # Total fragments (data + parity)\n    if fec_enabled:\n        num_total_frags = num_data_frags + fec_m\n    else:\n        num_total_frags = num_data_frags\n\n    fragments = []\n    pseq = get_next_pseq()\n\n    # Create data fragments\n    for i in range(num_data_frags):\n        start = i * max_frag_size\n        end = min(start + max_frag_size, len(af_packet))\n        payload = af_packet[start:end]\n\n        frag = create_pft_fragment(\n            pseq=pseq,\n            findex=i,\n            fcount=num_total_frags,\n            payload=payload,\n            fec_enabled=fec_enabled,\n            rsk=num_data_frags if fec_enabled else 0,\n            rsz=fec_m if fec_enabled else 0\n        )\n        fragments.append(frag)\n\n    # Create parity fragments (if FEC enabled)\n    if fec_enabled:\n        parity_data = calculate_rs_parity(af_packet, num_data_frags, fec_m)\n        parity_frag_size = len(parity_data) // fec_m\n\n        for i in range(fec_m):\n            start = i * parity_frag_size\n            end = start + parity_frag_size\n            payload = parity_data[start:end]\n\n            frag = create_pft_fragment(\n                pseq=pseq,\n                findex=num_data_frags + i,\n                fcount=num_total_frags,\n                payload=payload,\n                fec_enabled=True,\n                rsk=num_data_frags,\n                rsz=fec_m\n            )\n            fragments.append(frag)\n\n    return fragments\n</code></pre>"},{"location":"architecture/edi-protocol/#reed-solomon-fec","title":"Reed-Solomon FEC","text":"<p>Parameters: - k: Number of data fragments - m: Number of parity fragments - n = k + m: Total fragments</p> <p>Recovery capability: - Can recover up to m lost fragments - Example: (k=5, m=2) \u2192 Can lose any 2 of 7 fragments</p> <p>RS(255, k) encoding: - Operates over GF(2^8) (Galois Field) - Generator polynomial with roots at \u03b1^1, \u03b1^2, ..., \u03b1^(n-k)</p> <p>Example: <pre><code># Fragment AF packet (6000 bytes, 1400-byte fragments)\n# \u2192 5 data fragments (1400, 1400, 1400, 1400, 1400)\n\n# Add 2 parity fragments with RS FEC\n# \u2192 7 total fragments\n\n# Can lose any 2 fragments and still reconstruct:\n# Lost fragments 2 and 4? Reconstruct from 1,3,5,P1,P2\n</code></pre></p>"},{"location":"architecture/edi-protocol/#6-transport-layer-udptcp","title":"6. Transport Layer: UDP/TCP","text":"<p>UDP (User Datagram Protocol):</p> <p>Use cases: - Low latency - Multicast support - Stateless</p> <p>Characteristics: - Connectionless - No guaranteed delivery - No ordering guarantee - Suitable with PFT+FEC</p> <p>Example: <pre><code># Send PFT fragment over UDP\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.sendto(pft_fragment, (dest_ip, dest_port))\n</code></pre></p> <p>TCP (Transmission Control Protocol):</p> <p>Use cases: - Reliable delivery required - Unicast only - Stateful connection</p> <p>Characteristics: - Connection-oriented - Guaranteed delivery - In-order delivery - PFT optional (less needed)</p> <p>Example: <pre><code># Send AF packet over TCP\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((dest_ip, dest_port))\nsock.sendall(af_packet)\n</code></pre></p>"},{"location":"architecture/edi-protocol/#7-network-layer-ip","title":"7. Network Layer: IP","text":"<p>IPv4: - Unicast: Point-to-point - Multicast: 224.0.0.0 - 239.255.255.255</p> <p>IPv6: - Unicast: Point-to-point - Multicast: ff00::/8</p> <p>Multicast routing: - IGMP (IPv4) or MLD (IPv6) - Router configuration required - Efficient for one-to-many transmission</p>"},{"location":"architecture/edi-protocol/#complete-example","title":"Complete Example","text":""},{"location":"architecture/edi-protocol/#sending-eti-over-edi-with-pft","title":"Sending ETI over EDI with PFT","text":"<pre><code># 1. Start with ETI frame\neti_frame = generate_eti_frame()  # 5604 bytes\n\n# 2. Create TAG items\nptr_tag = create_ptr_tag()           # 12 bytes\ndeti_tag = create_deti_tag(eti_frame)  # 5612 bytes\nest0_tag = create_est_tag(0, stream0_data)  # Variable\n\n# 3. Create TAG packet (8-byte aligned)\ntags = [ptr_tag, deti_tag, est0_tag]\ntag_packet = create_tag_packet(tags)  # ~6000 bytes\n\n# 4. Create AF packet\naf_packet = create_af_packet(tag_packet, seq=123)  # ~6014 bytes\n\n# 5. Fragment with PFT (if needed)\nif enable_pft:\n    fragments = fragment_af_packet(\n        af_packet,\n        max_frag_size=1400,\n        fec_enabled=True,\n        fec_m=2\n    )  # 7 fragments (5 data + 2 parity)\n\n    # 6. Send each fragment over UDP\n    for frag in fragments:\n        sock.sendto(frag, (dest_ip, dest_port))\nelse:\n    # Send AF packet directly (if it fits)\n    sock.sendto(af_packet, (dest_ip, dest_port))\n</code></pre>"},{"location":"architecture/edi-protocol/#bandwidth-calculation","title":"Bandwidth Calculation","text":""},{"location":"architecture/edi-protocol/#without-pft","title":"Without PFT","text":"<pre><code>ETI frame:    5604 bytes\nTAG overhead: ~50 bytes (headers)\nAF overhead:  14 bytes (header + CRC)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal:        ~5668 bytes per frame\n\nMode I: 10.42 frames/second\nBandwidth: 5668 \u00d7 10.42 = 59 KB/s \u2248 472 kbps\n</code></pre>"},{"location":"architecture/edi-protocol/#with-pft-5-data-2-parity-fragments","title":"With PFT (5 data + 2 parity fragments)","text":"<pre><code>AF packet:    5668 bytes\nFragmented:   5 \u00d7 1400 = 7000 bytes (padded)\nPFT overhead: 7 \u00d7 16 = 112 bytes (headers)\nRS parity:    2 \u00d7 1400 = 2800 bytes\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal:        9912 bytes per frame\n\nMode I: 10.42 frames/second\nBandwidth: 9912 \u00d7 10.42 = 103 KB/s \u2248 824 kbps\n</code></pre>"},{"location":"architecture/edi-protocol/#see-also","title":"See Also","text":"<ul> <li>System Design: Overall architecture</li> <li>Data Flow: EDI output in pipeline</li> <li>PFT Fragmentation: User guide for PFT</li> <li>Reed-Solomon FEC: FEC mathematics</li> </ul>"},{"location":"architecture/eti-frames/","title":"ETI Frame Structure","text":"<p>Detailed byte-level layout of ETI (Ensemble Transport Interface) frames.</p>"},{"location":"architecture/eti-frames/#frame-layout-diagram","title":"Frame Layout Diagram","text":"<pre><code>graph TD\n    subgraph \"ETI Frame Structure\"\n        SYNC[\"SYNC (4 bytes)ERR + FSYNC\"]\n        FC[\"FC (4 bytes)Frame Characterization\"]\n        STC[\"STC (4\u00d7N bytes)Stream Characterization(N = subchannels)\"]\n        EOH[\"EOH (4 bytes)End of Header + CRC\"]\n        FIC[\"FIC (96 bytes Mode I)Fast Information Channel(32 FIBs \u00d7 3 bytes)\"]\n        MST[\"MST (variable)Main Service Transport(Audio/Data)\"]\n        EOF[\"EOF (4 bytes)End of Frame + CRC\"]\n        TIST[\"TIST (4 bytes, optional)Time Stamp\"]\n    end\n\n    SYNC --&gt; FC\n    FC --&gt; STC\n    STC --&gt; EOH\n    EOH --&gt; FIC\n    FIC --&gt; MST\n    MST --&gt; EOF\n    EOF --&gt; TIST\n\n    style SYNC fill:#ffcccc\n    style FC fill:#ccffcc\n    style STC fill:#ccccff\n    style EOH fill:#ffffcc\n    style FIC fill:#ffccff\n    style MST fill:#ccffff\n    style EOF fill:#ffdddd\n    style TIST fill:#ddffdd\n</code></pre>"},{"location":"architecture/eti-frames/#complete-frame-structure","title":"Complete Frame Structure","text":"<p>Total size: Variable, typically ~6000 bytes for Mode I</p> <pre><code>Byte Offset | Field | Size | Description\n------------|-------|------|-------------\n0           | SYNC  | 4    | Synchronization\n4           | FC    | 4    | Frame Characterization\n8           | STC   | 4\u00d7N  | Sub-channel Stream Characterization (N channels)\n8+4N        | EOH   | 4    | End of Header (with CRC)\n12+4N       | FIC   | 96   | Fast Information Channel (Mode I)\n108+4N      | MST   | var  | Main Service Transport\n108+4N+M    | EOF   | 4    | End of Frame (with CRC)\n112+4N+M    | TIST  | 4    | Time Stamp (optional)\n</code></pre> <p>Where: - N = number of subchannels (0-64) - M = MST length in bytes (depends on subchannels and mode)</p>"},{"location":"architecture/eti-frames/#field-descriptions","title":"Field Descriptions","text":""},{"location":"architecture/eti-frames/#sync-4-bytes","title":"SYNC (4 bytes)","text":"<p>Purpose: Frame synchronization and error indication</p> <p>Structure: <pre><code>Byte 0: ERR (Error indicator)\nByte 1-3: FSYNC = 0x073AB6 (fixed sync pattern)\n</code></pre></p> <p>ERR byte bits: <pre><code>Bit 7: Frame synchronization error\nBit 6: FIC CRC error\nBit 5-0: Reserved (0)\n</code></pre></p> <p>Example: <pre><code>00 07 3A B6\n\u2502  \u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500 FSYNC (0x073AB6)\n\u2514\u2500 ERR = 0x00 (no errors)\n</code></pre></p>"},{"location":"architecture/eti-frames/#fc-frame-characterization-4-bytes","title":"FC (Frame Characterization, 4 bytes)","text":"<p>Purpose: Describes frame structure and timing</p> <p>Bit layout: <pre><code>Bits 31-24: FCT (Frame Count, 0-249)\nBits 23-22: FICF (FIC Flag, always 1 for DAB)\nBits 21-20: NST (Number of Streams, N-1)\nBits 19-17: FP (Frame Phase, 0-7)\nBits 16-14: MID (Mode Identity: 001=I, 010=II, 011=III, 100=IV)\nBits 13-11: FL (Frame Length in 24ms units)\nBits 10-0: Reserved\n</code></pre></p> <p>Example for Mode I, 2 subchannels: <pre><code>C8 14 00 00\n\u2502  \u2502  \u2514\u2500\u2500\u2534\u2500 Reserved\n\u2502  \u2514\u2500 NST=1 (2 streams), FP=0, MID=001 (Mode I)\n\u2514\u2500 FCT=200 (frame count)\n</code></pre></p> <p>Frame Count (FCT): - Increments from 0 to 249 - Wraps to 0 after 249 - Used for frame sequencing - Period: 250 frames = 24 seconds (Mode I)</p>"},{"location":"architecture/eti-frames/#stc-sub-channel-stream-characterization-4-bytes-each","title":"STC (Sub-channel Stream Characterization, 4 bytes each)","text":"<p>Purpose: Describes each subchannel's characteristics</p> <p>One STC per subchannel, in order of subchannel ID.</p> <p>Bit layout: <pre><code>Bits 31-26: SCID (Sub-Channel ID, 0-63)\nBits 25-16: SAD (Start Address in CUs)\nBits 15-14: TPL (Time Position Location, 00=MSC)\nBits 13-8: STL (Stream Length in units of 64 bits)\nBits 7-0: Reserved\n</code></pre></p> <p>Example: <pre><code>00 00 05 40\n\u2502  \u2502  \u2502  \u2514\u2500 Reserved\n\u2502  \u2502  \u2514\u2500 STL=5 (5\u00d764 bits = 320 bits = 40 bytes)\n\u2502  \u2514\u2500 SAD=0 (start address 0)\n\u2514\u2500 SCID=0 (subchannel 0)\n</code></pre></p> <p>Stream Length (STL): - In units of 64 bits (8 bytes) - <code>Length in bytes = STL \u00d7 8</code> - Includes all data for this subchannel in MST</p>"},{"location":"architecture/eti-frames/#eoh-end-of-header-4-bytes","title":"EOH (End of Header, 4 bytes)","text":"<p>Purpose: Marks end of header and provides CRC</p> <p>Structure: <pre><code>Bytes 0-1: CRC-16-CCITT of FC + all STCs\nBytes 2-3: Reserved (usually 0xFFFF)\n</code></pre></p> <p>CRC Calculation: <pre><code># CRC-16-CCITT (polynomial 0x1021, init 0xFFFF)\ncrc = crc16(fc_bytes + all_stc_bytes)\n</code></pre></p> <p>Example: <pre><code>E3 8F FF FF\n\u2502  \u2502  \u2514\u2500\u2500\u2534\u2500 Reserved\n\u2514\u2500\u2500\u2534\u2500 CRC = 0xE38F\n</code></pre></p>"},{"location":"architecture/eti-frames/#fic-fast-information-channel-96-bytes-for-mode-i","title":"FIC (Fast Information Channel, 96 bytes for Mode I)","text":"<p>Purpose: Carries FIG (Fast Information Group) metadata</p> <p>Structure: - 32 FIBs (Fast Information Blocks) of 3 bytes each - Each FIB can contain multiple FIGs - Ends with padding (0xFF) if FIGs don't fill all FIBs</p> <p>FIB Format: <pre><code>Byte 0-1: FIG data or 0xFFFF (padding)\nByte 2: CRC-8 of bytes 0-1\n</code></pre></p> <p>Example FIC (first 12 bytes): <pre><code>21 02 CE 15 00 E1 ... (FIG 0/0 data)\nC0 80 50 01 ...       (FIG 0/2 data)\n...\nFF FF 00              (Padding FIB)\n</code></pre></p> <p>FIG types commonly in FIC: - FIG 0/0: Ensemble information - FIG 0/1: Sub-channel organization - FIG 0/2: Service organization - FIG 1/0: Ensemble label - FIG 1/1: Service labels</p>"},{"location":"architecture/eti-frames/#mst-main-service-transport-variable-size","title":"MST (Main Service Transport, variable size)","text":"<p>Purpose: Carries audio/data for all subchannels</p> <p>Structure: - Concatenated audio/data streams - Each stream occupies <code>STL \u00d7 8</code> bytes - Streams in order of subchannel ID</p> <p>Example with 2 subchannels: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Subchannel 0 data       \u2502 (STL\u2080 \u00d7 8 bytes)\n\u2502 (MPEG audio frames)     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Subchannel 1 data       \u2502 (STL\u2081 \u00d7 8 bytes)\n\u2502 (MPEG audio frames)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Mode I MST size: - 864 Capacity Units available - 1 CU = 8 bits (in Mode I) - Total: 864 bytes raw capacity - Actual size depends on subchannel bitrates and protection</p> <p>Data alignment: - Each subchannel's data is byte-aligned - No padding between subchannels</p>"},{"location":"architecture/eti-frames/#eof-end-of-frame-4-bytes","title":"EOF (End of Frame, 4 bytes)","text":"<p>Purpose: Marks end of frame and provides CRC</p> <p>Structure: <pre><code>Bytes 0-1: CRC-16-CCITT of MST\nBytes 2-3: Reserved (usually 0xFFFF)\n</code></pre></p> <p>CRC Calculation: <pre><code># CRC-16-CCITT of entire MST\ncrc = crc16(mst_bytes)\n</code></pre></p> <p>Example: <pre><code>7A 2B FF FF\n\u2502  \u2502  \u2514\u2500\u2500\u2534\u2500 Reserved\n\u2514\u2500\u2500\u2534\u2500 CRC = 0x7A2B\n</code></pre></p>"},{"location":"architecture/eti-frames/#tist-time-stamp-4-bytes-optional","title":"TIST (Time Stamp, 4 bytes, optional)","text":"<p>Purpose: Provides precise frame timing for synchronized transmission</p> <p>Structure: <pre><code>32-bit unsigned integer\nMilliseconds since EDI epoch (2000-01-01 00:00:00 UTC)\n</code></pre></p> <p>Calculation: <pre><code>edi_epoch = datetime(2000, 1, 1, 0, 0, 0, tzinfo=timezone.utc)\nnow = datetime.now(timezone.utc)\ntist_ms = int((now - edi_epoch).total_seconds() * 1000)\n</code></pre></p> <p>Example: <pre><code>5A 3C 1F 80\n\u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500 TIST = 0x5A3C1F80 (1514135424 ms)\n           = ~48 years after 2000\n           = ~2048-01-01\n</code></pre></p> <p>Use cases: - Single Frequency Networks (SFN) synchronization - Timed playout - Multi-transmitter coordination</p>"},{"location":"architecture/eti-frames/#frame-size-calculation","title":"Frame Size Calculation","text":""},{"location":"architecture/eti-frames/#mode-i-frame-size","title":"Mode I Frame Size","text":"<p>Formula: <pre><code>Size = 12 + 4\u00d7N + 96 + MST_size + 4 + (4 if TIST)\n\nWhere:\n  N = number of subchannels\n  MST_size = sum of (STL \u00d7 8) for all subchannels\n</code></pre></p> <p>Example with 3 subchannels (128 kbps each, protection level 2): <pre><code>SYNC:  4 bytes\nFC:    4 bytes\nSTC:   12 bytes (3 \u00d7 4)\nEOH:   4 bytes\nFIC:   96 bytes\nMST:   5472 bytes (calculated from bitrates)\nEOF:   4 bytes\nTIST:  4 bytes (optional)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal: 5600 bytes (without TIST)\n       5604 bytes (with TIST)\n</code></pre></p>"},{"location":"architecture/eti-frames/#mst-size-calculation","title":"MST Size Calculation","text":"<p>For Mode I:</p> <ol> <li>Calculate required bitrate including protection overhead</li> <li>Convert to Capacity Units (CUs)</li> <li>Convert CUs to bytes: <code>bytes = CUs</code> (in Mode I, 1 CU = 8 bits)</li> </ol> <p>Protection overhead: - Depends on protection level and form (short/long) - Higher protection = more CUs needed</p>"},{"location":"architecture/eti-frames/#hexdump-example","title":"Hexdump Example","text":"<p>Minimal Mode I frame (1 subchannel, 128 kbps):</p> <pre><code>Offset   Hex                                          ASCII\n000000   00 07 3a b6 c8 14 00 00 00 00 05 40 e3 8f   ..:.........@..\n         \u2514\u2500SYNC\u2500\u2518 \u2514\u2500\u2500\u2500FC\u2500\u2500\u2518 \u2514\u2500\u2500\u2500STC\u2500\u2500\u2518 \u2514\u2500\u2500EOH\u2500\u2518\n\n000010   ff ff 21 02 ce 15 00 e1 c0 80 50 01 00 00   ..!.......P...\n         \u2514FIC (96 bytes)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500...\n\n000070   ...                                          ...\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n0015b0   [MST data continues]                         ...\n\n0015c0   7a 2b ff ff 5a 3c 1f 80                      z+..Z&lt;..\n         \u2514\u2500\u2500EOF\u2500\u2500\u2518 \u2514\u2500\u2500TIST\u2500\u2518\n</code></pre>"},{"location":"architecture/eti-frames/#crc-polynomials","title":"CRC Polynomials","text":""},{"location":"architecture/eti-frames/#crc-16-ccitt","title":"CRC-16-CCITT","text":"<p>Used for: EOH, EOF</p> <p>Polynomial: <code>0x1021</code> Initial value: <code>0xFFFF</code> Final XOR: <code>0xFFFF</code></p> <pre><code>def crc16(data: bytes) -&gt; int:\n    crc = 0xFFFF\n    for byte in data:\n        crc ^= (byte &lt;&lt; 8)\n        for _ in range(8):\n            if crc &amp; 0x8000:\n                crc = (crc &lt;&lt; 1) ^ 0x1021\n            else:\n                crc = crc &lt;&lt; 1\n            crc &amp;= 0xFFFF\n    return crc ^ 0xFFFF\n</code></pre>"},{"location":"architecture/eti-frames/#crc-8","title":"CRC-8","text":"<p>Used for: FIB checksums in FIC</p> <p>Polynomial: <code>0x1D</code> Initial value: <code>0xFF</code> Final XOR: <code>0x00</code></p> <pre><code>def crc8(data: bytes) -&gt; int:\n    crc = 0xFF\n    for byte in data:\n        crc ^= byte\n        for _ in range(8):\n            if crc &amp; 0x80:\n                crc = (crc &lt;&lt; 1) ^ 0x1D\n            else:\n                crc = crc &lt;&lt; 1\n            crc &amp;= 0xFF\n    return crc\n</code></pre>"},{"location":"architecture/eti-frames/#frame-timing","title":"Frame Timing","text":""},{"location":"architecture/eti-frames/#mode-i","title":"Mode I","text":"<ul> <li>Frame duration: 96 ms</li> <li>Frame rate: 10.41667 frames/second</li> <li>FCT period: 250 frames = 24 seconds</li> </ul>"},{"location":"architecture/eti-frames/#other-modes","title":"Other Modes","text":"Mode Duration Rate (fps) FCT Period I 96 ms 10.42 24 s II 24 ms 41.67 6 s III 24 ms 41.67 6 s IV 48 ms 20.83 12 s"},{"location":"architecture/eti-frames/#validation","title":"Validation","text":""},{"location":"architecture/eti-frames/#sanity-checks","title":"Sanity Checks","text":"<ol> <li>SYNC pattern: Must be <code>0x073AB6</code></li> <li>FCT range: 0-249</li> <li>MID validity: 001, 010, 011, or 100</li> <li>NST consistency: Must match number of STCs</li> <li>CRC validity: EOH and EOF CRCs must be correct</li> <li>FIC size: Must be 96 bytes for Mode I</li> <li>MST size: Must match sum of STL values</li> </ol>"},{"location":"architecture/eti-frames/#python-dabmux-validation","title":"python-dabmux Validation","text":"<pre><code>def validate_frame(frame: EtiFrame) -&gt; bool:\n    # Check sync\n    if frame.sync.fsync != 0x073AB6:\n        return False\n\n    # Check FCT range\n    if frame.fc.fct &gt; 249:\n        return False\n\n    # Validate CRCs\n    if not frame.validate_eoh_crc():\n        return False\n    if not frame.validate_eof_crc():\n        return False\n\n    return True\n</code></pre>"},{"location":"architecture/eti-frames/#see-also","title":"See Also","text":"<ul> <li>System Design: Overall architecture</li> <li>Data Flow: How frames are generated</li> <li>FIG Carousel: FIG generation for FIC</li> <li>ETSI EN 300 799: ETI specification</li> </ul>"},{"location":"architecture/fig-carousel/","title":"FIG Carousel Operation","text":"<p>How the FIG (Fast Information Group) carousel rotates through different FIG types based on their repetition rates.</p>"},{"location":"architecture/fig-carousel/#fig-carousel-sequence-diagram","title":"FIG Carousel Sequence Diagram","text":"<pre><code>sequenceDiagram\n    participant Mux as DabMultiplexer\n    participant FIC as FICEncoder\n    participant Car as Carousel\n    participant F00 as FIG 0/0\n    participant F01 as FIG 0/1\n    participant F02 as FIG 0/2\n    participant F10 as FIG 1/0\n    participant F11 as FIG 1/1\n\n    Note over Mux: Frame 1 (t=0ms)\n    Mux-&gt;&gt;FIC: encode_fic()\n    FIC-&gt;&gt;Car: get_figs()\n\n    Car-&gt;&gt;Car: Check timers\n    Note over Car: FIG 0/0: counter=0 \u2713FIG 0/1: counter=0 \u2713FIG 0/2: counter=0 \u2713\n\n    Car-&gt;&gt;F00: generate()\n    F00--&gt;&gt;Car: 8 bytes\n    Car-&gt;&gt;F01: generate()\n    F01--&gt;&gt;Car: 24 bytes\n    Car-&gt;&gt;F02: generate()\n    F02--&gt;&gt;Car: 16 bytes\n\n    Car-&gt;&gt;Car: Reset counters:0/0\u21921, 0/1\u219210, 0/2\u219210\n    Car--&gt;&gt;FIC: [FIG 0/0, 0/1, 0/2]\n    FIC--&gt;&gt;Mux: 96 bytes FIC\n\n    Note over Mux: Frame 2 (t=96ms)\n    Mux-&gt;&gt;FIC: encode_fic()\n    FIC-&gt;&gt;Car: get_figs()\n\n    Car-&gt;&gt;Car: Check timers\n    Note over Car: FIG 0/0: counter=0 \u2713FIG 0/1: counter=9FIG 1/0: counter=0 \u2713\n\n    Car-&gt;&gt;F00: generate()\n    F00--&gt;&gt;Car: 8 bytes\n    Car-&gt;&gt;F10: generate()\n    F10--&gt;&gt;Car: 20 bytes\n\n    Car-&gt;&gt;Car: Reset counters:0/0\u21921, 1/0\u219210\n    Car--&gt;&gt;FIC: [FIG 0/0, 1/0]\n    FIC--&gt;&gt;Mux: 96 bytes FIC\n\n    Note over Mux: Frame 3 (t=192ms)\n    Mux-&gt;&gt;FIC: encode_fic()\n    FIC-&gt;&gt;Car: get_figs()\n\n    Car-&gt;&gt;Car: Check timers\n    Note over Car: FIG 0/0: counter=0 \u2713FIG 1/1: counter=0 \u2713\n\n    Car-&gt;&gt;F00: generate()\n    F00--&gt;&gt;Car: 8 bytes\n    Car-&gt;&gt;F11: generate()\n    F11--&gt;&gt;Car: 18 bytes\n\n    Car--&gt;&gt;FIC: [FIG 0/0, 1/1]\n    FIC--&gt;&gt;Mux: 96 bytes FIC\n</code></pre>"},{"location":"architecture/fig-carousel/#fig-carousel-timing-diagram","title":"FIG Carousel Timing Diagram","text":"<pre><code>gantt\n    title FIG Repetition Schedule\n    dateFormat X\n    axisFormat %L ms\n\n    section FIG 0/0\n    Frame 1   :0, 96\n    Frame 2   :96, 96\n    Frame 3   :192, 96\n    Frame 4   :288, 96\n    Frame 5   :384, 96\n\n    section FIG 0/1\n    Frame 1   :0, 96\n    Frame 11  :960, 96\n    Frame 21  :1920, 96\n\n    section FIG 0/2\n    Frame 1   :0, 96\n    Frame 11  :960, 96\n    Frame 21  :1920, 96\n\n    section FIG 1/0\n    Frame 2   :96, 96\n    Frame 12  :1056, 96\n    Frame 22  :2016, 96\n\n    section FIG 1/1\n    Frame 3   :192, 96\n    Frame 13  :1152, 96\n    Frame 23  :2112, 96\n</code></pre>"},{"location":"architecture/fig-carousel/#overview","title":"Overview","text":"<p>The FIG Carousel is a scheduling system that determines which FIGs (Fast Information Groups) are included in each frame. Different FIG types have different repetition rates based on their importance and how often receivers need to see them.</p> <p>Key concepts:</p> <ul> <li>FIG Priority: Critical FIGs repeat more frequently</li> <li>Timers: Each FIG has a countdown timer</li> <li>Buffer Management: FIGs must fit in 96-byte FIC</li> <li>Round-Robin: FIGs rotate in a predictable pattern</li> </ul>"},{"location":"architecture/fig-carousel/#fig-types-and-repetition-rates","title":"FIG Types and Repetition Rates","text":""},{"location":"architecture/fig-carousel/#high-priority-every-frame","title":"High Priority (Every Frame)","text":"<p>FIG 0/0 - Ensemble Information</p> <ul> <li>Repetition: 96 ms (every 1 frame in Mode I)</li> <li>Purpose: Ensemble ID, country code, alarm flag</li> <li>Size: 6-8 bytes</li> <li>Why frequent: Receivers need this to identify the ensemble immediately</li> </ul> <p>Example: <pre><code>class Fig0_0:\n    def __init__(self):\n        self.repetition_ms = 96  # Every frame\n        self.counter = 1\n</code></pre></p>"},{"location":"architecture/fig-carousel/#medium-priority-every-1-second","title":"Medium Priority (Every ~1 Second)","text":"<p>FIG 0/1 - Sub-channel Organization</p> <ul> <li>Repetition: ~1 second (~10 frames in Mode I)</li> <li>Purpose: Subchannel IDs, start addresses, sizes</li> <li>Size: 4 bytes per subchannel + header</li> <li>Why frequent: Needed to find audio data in MST</li> </ul> <p>FIG 0/2 - Service Organization</p> <ul> <li>Repetition: ~1 second (~10 frames)</li> <li>Purpose: Links services to components</li> <li>Size: 3-4 bytes per service + header</li> <li>Why frequent: Needed to map service names to audio</li> </ul> <p>FIG 1/0 - Ensemble Label</p> <ul> <li>Repetition: ~1 second (~10 frames)</li> <li>Purpose: Ensemble name (text label)</li> <li>Size: 16-20 bytes</li> <li>Why frequent: Displayed prominently on receivers</li> </ul> <p>FIG 1/1 - Service Labels</p> <ul> <li>Repetition: ~1 second (~10 frames)</li> <li>Purpose: Service names (station labels)</li> <li>Size: 16-20 bytes per service</li> <li>Why frequent: Displayed in station lists</li> </ul>"},{"location":"architecture/fig-carousel/#low-priority-every-10-seconds","title":"Low Priority (Every 10+ Seconds)","text":"<p>FIG 0/5 - Service Component Language</p> <ul> <li>Repetition: 10 seconds (~100 frames)</li> <li>Purpose: Language codes for components</li> <li>Size: 2-3 bytes per component</li> </ul> <p>FIG 0/8 - Service Component Global Definition</p> <ul> <li>Repetition: 10 seconds</li> <li>Purpose: Global service IDs</li> <li>Size: Variable</li> </ul> <p>FIG 0/13 - User Application Information</p> <ul> <li>Repetition: 10 seconds</li> <li>Purpose: EPG, slideshow, etc.</li> <li>Size: Variable</li> </ul> <p>FIG 0/17 - Programme Type</p> <ul> <li>Repetition: 10 seconds</li> <li>Purpose: Programme type codes</li> <li>Size: 2-3 bytes per service</li> </ul>"},{"location":"architecture/fig-carousel/#carousel-algorithm","title":"Carousel Algorithm","text":""},{"location":"architecture/fig-carousel/#initialization","title":"Initialization","text":"<pre><code>class FigCarousel:\n    def __init__(self, ensemble: DabEnsemble):\n        self.ensemble = ensemble\n        self.fig_generators = {\n            '0/0': Fig0_0(ensemble),\n            '0/1': Fig0_1(ensemble),\n            '0/2': Fig0_2(ensemble),\n            '1/0': Fig1_0(ensemble),\n            '1/1': Fig1_1(ensemble),\n            # ... more FIG types\n        }\n\n        # Initialize counters (in frames)\n        self.counters = {\n            '0/0': 1,    # Every frame\n            '0/1': 10,   # Every ~1 second\n            '0/2': 10,\n            '1/0': 10,\n            '1/1': 10,\n            '0/5': 100,  # Every ~10 seconds\n            '0/8': 100,\n            '0/13': 100,\n            '0/17': 100,\n        }\n</code></pre>"},{"location":"architecture/fig-carousel/#frame-by-frame-operation","title":"Frame-by-Frame Operation","text":"<pre><code>def get_figs_for_frame(self) -&gt; List[bytes]:\n    \"\"\"\n    Get FIGs to include in this frame.\n\n    Returns:\n        List of FIG byte arrays\n    \"\"\"\n    figs = []\n    total_size = 0\n    max_size = 90  # Leave room for padding and CRC\n\n    # Priority order\n    fig_order = ['0/0', '0/1', '0/2', '1/0', '1/1', '0/5', '0/8', '0/13', '0/17']\n\n    for fig_type in fig_order:\n        # Check if this FIG should be included\n        if self.counters[fig_type] &lt;= 0:\n            # Generate FIG\n            fig_data = self.fig_generators[fig_type].generate()\n\n            # Check if it fits\n            if total_size + len(fig_data) &lt;= max_size:\n                figs.append(fig_data)\n                total_size += len(fig_data)\n\n                # Reset counter based on repetition rate\n                self.counters[fig_type] = self._get_repetition(fig_type)\n            else:\n                # Doesn't fit, defer to next frame\n                break\n        else:\n            # Not yet time for this FIG\n            pass\n\n    # Decrement all counters\n    for fig_type in self.counters:\n        self.counters[fig_type] -= 1\n\n    return figs\n</code></pre>"},{"location":"architecture/fig-carousel/#repetition-rate-calculation","title":"Repetition Rate Calculation","text":"<pre><code>def _get_repetition(self, fig_type: str) -&gt; int:\n    \"\"\"\n    Get repetition interval in frames.\n\n    For Mode I: 96ms per frame, so:\n    - Every frame = 1\n    - Every ~1 second = 10 frames\n    - Every ~10 seconds = 100 frames\n    \"\"\"\n    repetition_map = {\n        '0/0': 1,     # 96 ms\n        '0/1': 10,    # ~960 ms\n        '0/2': 10,\n        '1/0': 10,\n        '1/1': 10,\n        '0/5': 100,   # ~9.6 seconds\n        '0/8': 100,\n        '0/13': 100,\n        '0/17': 100,\n    }\n    return repetition_map.get(fig_type, 10)\n</code></pre>"},{"location":"architecture/fig-carousel/#fic-encoding","title":"FIC Encoding","text":""},{"location":"architecture/fig-carousel/#fib-structure","title":"FIB Structure","text":"<p>The FIC (Fast Information Channel) is encoded as 32 FIBs (Fast Information Blocks):</p> <pre><code>FIB = Fast Information Block (3 bytes)\n  Byte 0-1: Data (or 0xFFFF for padding)\n  Byte 2: CRC-8 of bytes 0-1\n</code></pre> <p>Total FIC size: 32 FIBs \u00d7 3 bytes = 96 bytes</p>"},{"location":"architecture/fig-carousel/#encoding-process","title":"Encoding Process","text":"<pre><code>def encode_fic(self, figs: List[bytes]) -&gt; bytes:\n    \"\"\"\n    Encode FIGs into 96-byte FIC.\n\n    Args:\n        figs: List of FIG byte arrays\n\n    Returns:\n        96-byte FIC data\n    \"\"\"\n    fic_buffer = bytearray(96)\n    pos = 0\n\n    # Pack FIGs into FIBs\n    for fig in figs:\n        # Each FIG goes into FIBs\n        fig_len = len(fig)\n\n        for i in range(0, fig_len, 2):\n            if pos &gt;= 96:\n                break  # FIC full\n\n            # Get 2 bytes of data\n            if i + 1 &lt; fig_len:\n                data = fig[i:i+2]\n            else:\n                # Last byte, pad with 0xFF\n                data = fig[i:i+1] + b'\\xFF'\n\n            # Calculate CRC-8\n            crc = self.calculate_crc8(data)\n\n            # Write FIB\n            fic_buffer[pos:pos+2] = data\n            fic_buffer[pos+2] = crc\n            pos += 3\n\n    # Pad remaining FIBs\n    while pos &lt; 96:\n        fic_buffer[pos:pos+2] = b'\\xFF\\xFF'\n        fic_buffer[pos+2] = self.calculate_crc8(b'\\xFF\\xFF')\n        pos += 3\n\n    return bytes(fic_buffer)\n</code></pre>"},{"location":"architecture/fig-carousel/#crc-8-calculation","title":"CRC-8 Calculation","text":"<pre><code>def calculate_crc8(self, data: bytes) -&gt; int:\n    \"\"\"\n    Calculate CRC-8 for FIB.\n\n    Polynomial: 0x1D (x^8 + x^4 + x^3 + x^2 + 1)\n    Initial: 0xFF\n    Final XOR: 0x00\n    \"\"\"\n    crc = 0xFF\n    for byte in data:\n        crc ^= byte\n        for _ in range(8):\n            if crc &amp; 0x80:\n                crc = (crc &lt;&lt; 1) ^ 0x1D\n            else:\n                crc = crc &lt;&lt; 1\n            crc &amp;= 0xFF\n    return crc\n</code></pre>"},{"location":"architecture/fig-carousel/#example-frame-sequences","title":"Example Frame Sequences","text":""},{"location":"architecture/fig-carousel/#frame-1-t0ms","title":"Frame 1 (t=0ms)","text":"<p>Counters: - FIG 0/0: 0 \u2713 (include) - FIG 0/1: 0 \u2713 (include) - FIG 0/2: 0 \u2713 (include) - FIG 1/0: 5 - FIG 1/1: 7</p> <p>FIGs included: - FIG 0/0: 8 bytes (Ensemble info) - FIG 0/1: 24 bytes (3 subchannels) - FIG 0/2: 16 bytes (3 services)</p> <p>Total: 48 bytes (fits easily in 90-byte limit)</p> <p>Counter reset: - FIG 0/0: 1 - FIG 0/1: 10 - FIG 0/2: 10</p>"},{"location":"architecture/fig-carousel/#frame-2-t96ms","title":"Frame 2 (t=96ms)","text":"<p>Counters: - FIG 0/0: 0 \u2713 (include) - FIG 0/1: 9 - FIG 0/2: 9 - FIG 1/0: 4 - FIG 1/1: 6</p> <p>FIGs included: - FIG 0/0: 8 bytes</p> <p>Total: 8 bytes</p> <p>Counter reset: - FIG 0/0: 1</p>"},{"location":"architecture/fig-carousel/#frame-10-t864ms","title":"Frame 10 (t=864ms)","text":"<p>Counters: - FIG 0/0: 0 \u2713 (include) - FIG 0/1: 1 - FIG 0/2: 1 - FIG 1/0: 0 \u2713 (include) - FIG 1/1: 0 \u2713 (include)</p> <p>FIGs included: - FIG 0/0: 8 bytes - FIG 1/0: 20 bytes (Ensemble label) - FIG 1/1: 60 bytes (3 service labels)</p> <p>Total: 88 bytes (fits in 90-byte limit)</p> <p>Counter reset: - FIG 0/0: 1 - FIG 1/0: 10 - FIG 1/1: 10</p>"},{"location":"architecture/fig-carousel/#buffer-management","title":"Buffer Management","text":""},{"location":"architecture/fig-carousel/#size-constraints","title":"Size Constraints","text":"<p>FIC capacity: 96 bytes total</p> <p>Usable for FIGs: - 32 FIBs \u00d7 3 bytes = 96 bytes - CRC overhead: 1 byte per FIB = 32 bytes - Net data capacity: ~90 bytes per frame</p>"},{"location":"architecture/fig-carousel/#priority-handling","title":"Priority Handling","text":"<p>When FIGs don't fit:</p> <ol> <li>Always include FIG 0/0 (8 bytes, critical)</li> <li>Add other FIGs by priority until buffer full</li> <li>Defer low-priority FIGs to next frame</li> <li>Never split a FIG across frames</li> </ol> <p>Example overflow: <pre><code># Frame has 90 bytes available\n# FIG 0/0: 8 bytes (included, 82 left)\n# FIG 0/1: 24 bytes (included, 58 left)\n# FIG 0/2: 16 bytes (included, 42 left)\n# FIG 1/1: 60 bytes (doesn't fit, defer)\n</code></pre></p>"},{"location":"architecture/fig-carousel/#padding","title":"Padding","text":"<p>If FIGs don't fill FIC:</p> <pre><code># FIGs total: 48 bytes\n# FIC size: 96 bytes\n# Padding needed: 48 bytes\n\n# Fill with 0xFFFF FIBs:\nwhile pos &lt; 96:\n    fib = b'\\xFF\\xFF' + crc8(b'\\xFF\\xFF')\n    fic_buffer[pos:pos+3] = fib\n    pos += 3\n</code></pre>"},{"location":"architecture/fig-carousel/#performance-optimization","title":"Performance Optimization","text":""},{"location":"architecture/fig-carousel/#caching","title":"Caching","text":"<p>Problem: Many FIGs don't change frame-to-frame</p> <p>Solution: Cache generated FIG bytes</p> <pre><code>class FigCarousel:\n    def __init__(self):\n        self.fig_cache = {}\n        self.cache_valid = {}\n\n    def get_fig(self, fig_type: str) -&gt; bytes:\n        # Check cache\n        if self.cache_valid.get(fig_type, False):\n            return self.fig_cache[fig_type]\n\n        # Generate and cache\n        fig_data = self.fig_generators[fig_type].generate()\n        self.fig_cache[fig_type] = fig_data\n        self.cache_valid[fig_type] = True\n\n        return fig_data\n\n    def invalidate_cache(self, fig_type: str):\n        \"\"\"Invalidate cache when ensemble config changes\"\"\"\n        self.cache_valid[fig_type] = False\n</code></pre> <p>Cache invalidation: - Service added/removed \u2192 Invalidate FIG 0/2, 1/1 - Subchannel changed \u2192 Invalidate FIG 0/1 - Label changed \u2192 Invalidate FIG 1/0 or 1/1</p>"},{"location":"architecture/fig-carousel/#pre-computation","title":"Pre-computation","text":"<p>Pre-compute static FIGs at startup:</p> <pre><code>class FigCarousel:\n    def __init__(self, ensemble: DabEnsemble):\n        # Generate all FIGs once\n        self._precompute_figs()\n\n    def _precompute_figs(self):\n        for fig_type in self.fig_generators:\n            self.get_fig(fig_type)  # Populate cache\n</code></pre>"},{"location":"architecture/fig-carousel/#debugging","title":"Debugging","text":""},{"location":"architecture/fig-carousel/#fig-carousel-state","title":"FIG Carousel State","text":"<pre><code>def debug_state(self) -&gt; str:\n    \"\"\"Print carousel state for debugging\"\"\"\n    lines = [\"FIG Carousel State:\"]\n    for fig_type, counter in self.counters.items():\n        status = \"DUE\" if counter &lt;= 0 else f\"in {counter} frames\"\n        lines.append(f\"  {fig_type}: {status}\")\n    return \"\\n\".join(lines)\n</code></pre> <p>Example output: <pre><code>FIG Carousel State:\n  0/0: DUE\n  0/1: in 5 frames\n  0/2: in 5 frames\n  1/0: in 2 frames\n  1/1: in 8 frames\n  0/5: in 87 frames\n</code></pre></p>"},{"location":"architecture/fig-carousel/#fig-content-inspection","title":"FIG Content Inspection","text":"<pre><code>def inspect_fig(self, fig_data: bytes) -&gt; str:\n    \"\"\"Inspect FIG contents\"\"\"\n    fig_type = (fig_data[0] &gt;&gt; 5) &amp; 0x07\n    extension = fig_data[0] &amp; 0x1F\n\n    return f\"FIG {fig_type}/{extension}: {len(fig_data)} bytes\"\n</code></pre>"},{"location":"architecture/fig-carousel/#see-also","title":"See Also","text":"<ul> <li>System Design: Overall architecture</li> <li>ETI Frames: Where FIC fits in frames</li> <li>Data Flow: FIG generation in pipeline</li> <li>FIG Types: Complete FIG specifications</li> </ul>"},{"location":"architecture/system-design/","title":"System Design","text":"<p>High-level architecture of python-dabmux showing module structure and data flow.</p>"},{"location":"architecture/system-design/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Configuration Layer\"\n        YAML[YAML Config File]\n        Parser[ConfigParser]\n        Ensemble[DabEnsemble]\n    end\n\n    subgraph \"Input Layer\"\n        FileInput[FileInputMPEG/Raw]\n        UDPInput[UDPInputNetwork]\n        TCPInput[TCPInputNetwork]\n        InputBase[InputBaseAbstract]\n    end\n\n    subgraph \"Core Layer\"\n        Mux[DabMultiplexer]\n        FICEnc[FICEncoder]\n        Carousel[FIG Carousel]\n        FIG0[FIG Type 0Ensemble Info]\n        FIG1[FIG Type 1Labels]\n        ETI[ETI FrameStructures]\n    end\n\n    subgraph \"Output Layer\"\n        FileOut[FileOutputETI Files]\n        EDIOut[EdiOutputNetwork]\n        EDIEnc[EdiEncoderTAG Items]\n        PFT[PFT LayerFragmentation+FEC]\n    end\n\n    subgraph \"Utilities\"\n        CRC[CRC Utils]\n        Charset[Character Set]\n        Audio[Audio Parsing]\n        FEC[Reed-Solomon FEC]\n    end\n\n    YAML --&gt; Parser\n    Parser --&gt; Ensemble\n    Ensemble --&gt; Mux\n\n    FileInput --&gt; InputBase\n    UDPInput --&gt; InputBase\n    TCPInput --&gt; InputBase\n    InputBase --&gt; Mux\n\n    Mux --&gt; FICEnc\n    FICEnc --&gt; Carousel\n    Carousel --&gt; FIG0\n    Carousel --&gt; FIG1\n    FIG0 --&gt; FICEnc\n    FIG1 --&gt; FICEnc\n\n    Mux --&gt; ETI\n    ETI --&gt; FileOut\n    ETI --&gt; EDIEnc\n    EDIEnc --&gt; EDIOut\n    EDIOut --&gt; PFT\n\n    CRC --&gt; ETI\n    Charset --&gt; FIG1\n    Audio --&gt; Mux\n    FEC --&gt; PFT\n\n    style Mux fill:#f9f,stroke:#333,stroke-width:3px\n    style FICEnc fill:#bbf,stroke:#333,stroke-width:2px\n    style ETI fill:#bfb,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"architecture/system-design/#layer-descriptions","title":"Layer Descriptions","text":""},{"location":"architecture/system-design/#configuration-layer","title":"Configuration Layer","text":"<p>Purpose: Parse YAML configuration and create ensemble structure</p> <p>Components:</p> <ul> <li>ConfigParser: Reads YAML files and creates DabEnsemble</li> <li>DabEnsemble: Container for all ensemble data (services, subchannels, components)</li> </ul> <p>Data Flow: <pre><code>YAML file \u2192 ConfigParser \u2192 DabEnsemble \u2192 DabMultiplexer\n</code></pre></p> <p>Key Responsibilities:</p> <ul> <li>YAML parsing and validation</li> <li>ID type conversion (hex strings to integers)</li> <li>Label validation</li> <li>Ensemble structure creation</li> </ul>"},{"location":"architecture/system-design/#input-layer","title":"Input Layer","text":"<p>Purpose: Abstract audio input sources (files and network)</p> <p>Components:</p> <ul> <li>InputBase: Abstract base class defining input interface</li> <li>FileInput: Read MPEG Layer II files</li> <li>UDPInput: Receive audio over UDP (unicast/multicast)</li> <li>TCPInput: Receive audio over TCP</li> </ul> <p>Data Flow: <pre><code>Audio Source \u2192 Input Class \u2192 Buffer \u2192 DabMultiplexer\n</code></pre></p> <p>Key Responsibilities:</p> <ul> <li>Open/close input sources</li> <li>Read audio frames</li> <li>Buffer management</li> <li>Format validation</li> <li>Statistics tracking</li> </ul> <p>Interface: <pre><code>class InputBase(ABC):\n    def open(self) -&gt; None: ...\n    def read(self, size: int) -&gt; bytes: ...\n    def close(self) -&gt; None: ...\n    def get_stats(self) -&gt; Dict: ...\n</code></pre></p>"},{"location":"architecture/system-design/#core-layer","title":"Core Layer","text":"<p>Purpose: Multiplex audio streams and generate FIG metadata</p> <p>Components:</p> <ul> <li>DabMultiplexer: Main orchestrator, generates ETI frames</li> <li>FICEncoder: Encodes Fast Information Channel</li> <li>FIG Carousel: Schedules FIG repetition</li> <li>FIG Type 0: Ensemble information FIGs</li> <li>FIG Type 1: Label FIGs</li> <li>ETI Structures: Frame data structures</li> </ul> <p>Data Flow: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 DabMultiplexer  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. Read inputs  \u2502\n\u2502 2. Generate FIGs\u2502\n\u2502 3. Encode FIC   \u2502\n\u2502 4. Populate MST \u2502\n\u2502 5. Calculate CRC\u2502\n\u2502 6. Pack frame   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Key Responsibilities:</p> <ul> <li>Frame timing and sequencing</li> <li>FIG generation and carousel management</li> <li>Audio data multiplexing</li> <li>CRC calculation</li> <li>Frame assembly</li> </ul> <p>Main Algorithm: <pre><code>def generate_frame(self) -&gt; EtiFrame:\n    # 1. Read audio from all inputs\n    audio_data = self._read_inputs()\n\n    # 2. Generate FIGs for this frame\n    figs = self.carousel.get_figs_for_frame()\n\n    # 3. Encode FIC\n    fic_data = self.fic_encoder.encode(figs)\n\n    # 4. Create frame\n    frame = EtiFrame()\n    frame.fic = fic_data\n    frame.mst = audio_data\n\n    # 5. Calculate CRCs\n    frame.calculate_crcs()\n\n    return frame\n</code></pre></p>"},{"location":"architecture/system-design/#output-layer","title":"Output Layer","text":"<p>Purpose: Write ETI frames to files or send over network</p> <p>Components:</p> <ul> <li>FileOutput: Write ETI to files (raw/streamed/framed)</li> <li>EdiOutput: Send EDI over network (UDP/TCP)</li> <li>EdiEncoder: Convert ETI to EDI TAG items</li> <li>PFT Layer: Fragmentation and FEC for EDI</li> </ul> <p>Data Flow:</p> <p>File Output: <pre><code>ETI Frame \u2192 Serialize \u2192 FileOutput \u2192 File\n</code></pre></p> <p>EDI Output: <pre><code>ETI Frame \u2192 EdiEncoder \u2192 TAG Items \u2192 AF Packet \u2192 PFT \u2192 UDP/TCP\n</code></pre></p> <p>Key Responsibilities:</p> <ul> <li>ETI serialization</li> <li>File format handling (raw/streamed/framed)</li> <li>EDI protocol encoding</li> <li>PFT fragmentation and FEC</li> <li>Network transmission</li> </ul>"},{"location":"architecture/system-design/#utilities-layer","title":"Utilities Layer","text":"<p>Purpose: Shared utilities used by multiple components</p> <p>Components:</p> <ul> <li>CRC Utils: CRC-8, CRC-16-CCITT, CRC-32 calculations</li> <li>Character Set: UTF-8 \u2194 EBU Latin conversion</li> <li>Audio Parsing: MPEG frame parsing</li> <li>Reed-Solomon FEC: Galois Field arithmetic and encoding</li> </ul> <p>Usage:</p> <ul> <li>CRC: Used by ETI frames (EOH, EOF), EDI packets</li> <li>Character Set: Used by FIG 1 (labels)</li> <li>Audio Parsing: Used by input layer for frame detection</li> <li>Reed-Solomon: Used by PFT layer for error correction</li> </ul>"},{"location":"architecture/system-design/#module-interactions","title":"Module Interactions","text":""},{"location":"architecture/system-design/#initialization-sequence","title":"Initialization Sequence","text":"<pre><code>sequenceDiagram\n    participant CLI\n    participant ConfigParser\n    participant Ensemble\n    participant Multiplexer\n    participant Inputs\n    participant Outputs\n\n    CLI-&gt;&gt;ConfigParser: load_config(\"config.yaml\")\n    ConfigParser-&gt;&gt;Ensemble: Create DabEnsemble\n    ConfigParser--&gt;&gt;CLI: Return ensemble\n\n    CLI-&gt;&gt;Multiplexer: DabMultiplexer(ensemble)\n    Multiplexer-&gt;&gt;Inputs: Initialize inputs\n    Inputs-&gt;&gt;Inputs: open()\n\n    CLI-&gt;&gt;Outputs: Create output\n    Outputs-&gt;&gt;Outputs: open()\n\n    Note over Multiplexer: Ready to generate frames\n</code></pre>"},{"location":"architecture/system-design/#frame-generation-sequence","title":"Frame Generation Sequence","text":"<pre><code>sequenceDiagram\n    participant Mux as DabMultiplexer\n    participant Inputs\n    participant FIC as FICEncoder\n    participant Carousel\n    participant CRC\n    participant Output\n\n    Mux-&gt;&gt;Inputs: read() for each subchannel\n    Inputs--&gt;&gt;Mux: Audio data\n\n    Mux-&gt;&gt;FIC: encode_fic()\n    FIC-&gt;&gt;Carousel: get_figs()\n    Carousel--&gt;&gt;FIC: List of FIGs\n    FIC--&gt;&gt;Mux: FIC bytes (96 bytes)\n\n    Mux-&gt;&gt;Mux: Assemble frame (SYNC, FC, STC, FIC, MST, EOF)\n    Mux-&gt;&gt;CRC: calculate_crc() for EOH, EOF\n    CRC--&gt;&gt;Mux: CRC values\n\n    Mux-&gt;&gt;Output: write(frame_bytes)\n    Output-&gt;&gt;Output: Serialize and output\n</code></pre>"},{"location":"architecture/system-design/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/system-design/#factory-pattern","title":"Factory Pattern","text":"<p>Used for creating inputs and outputs:</p> <pre><code>def create_input(uri: str) -&gt; InputBase:\n    if uri.startswith('file://'):\n        return FileInput(uri)\n    elif uri.startswith('udp://'):\n        return UDPInput(uri)\n    elif uri.startswith('tcp://'):\n        return TCPInput(uri)\n</code></pre>"},{"location":"architecture/system-design/#strategy-pattern","title":"Strategy Pattern","text":"<p>Used for FIG generation:</p> <pre><code>class FigGenerator(ABC):\n    @abstractmethod\n    def generate(self, ensemble: DabEnsemble) -&gt; bytes:\n        pass\n\nclass Fig0_0(FigGenerator):\n    def generate(self, ensemble: DabEnsemble) -&gt; bytes:\n        # Generate FIG 0/0\n        ...\n\nclass Fig1_0(FigGenerator):\n    def generate(self, ensemble: DabEnsemble) -&gt; bytes:\n        # Generate FIG 1/0\n        ...\n</code></pre>"},{"location":"architecture/system-design/#composite-pattern","title":"Composite Pattern","text":"<p>Used for ETI frame structure:</p> <pre><code>class EtiFrame:\n    sync: Sync\n    fc: FrameCharacterization\n    stc: List[SubChannelStreamChar]\n    eoh: EndOfHeader\n    fic: FastInformationChannel\n    mst: MainServiceTransport\n    eof: EndOfFrame\n    tist: Optional[TimeStamp]\n</code></pre>"},{"location":"architecture/system-design/#template-method-pattern","title":"Template Method Pattern","text":"<p>Used in InputBase:</p> <pre><code>class InputBase(ABC):\n    def open(self) -&gt; None:\n        self._pre_open()\n        self._do_open()  # Abstract\n        self._post_open()\n\n    @abstractmethod\n    def _do_open(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"architecture/system-design/#concurrency-model","title":"Concurrency Model","text":""},{"location":"architecture/system-design/#single-threaded-design","title":"Single-Threaded Design","text":"<p>python-dabmux uses a single-threaded, synchronous model:</p> <p>Rationale: - Simpler code and debugging - No race conditions or deadlocks - Sufficient performance for DAB multiplexing - Easier to reason about execution flow</p> <p>Processing: <pre><code>Loop:\n  1. Read inputs (blocking)\n  2. Generate FIGs\n  3. Assemble frame\n  4. Write output (blocking)\n  5. Sleep if needed for frame timing\n</code></pre></p> <p>For multi-core usage: Run multiple independent instances.</p>"},{"location":"architecture/system-design/#error-handling-strategy","title":"Error Handling Strategy","text":""},{"location":"architecture/system-design/#validation-at-boundaries","title":"Validation at Boundaries","text":"<ol> <li>Configuration: Validate at parse time</li> <li>Inputs: Validate format on read</li> <li>Outputs: Check write success</li> </ol>"},{"location":"architecture/system-design/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>DabMuxError (base exception)\n  \u251c\u2500 ConfigurationError\n  \u2502   \u251c\u2500 InvalidYamlError\n  \u2502   \u251c\u2500 ValidationError\n  \u2502   \u2514\u2500 MissingFieldError\n  \u251c\u2500 InputError\n  \u2502   \u251c\u2500 FileNotFoundError\n  \u2502   \u251c\u2500 InvalidFormatError\n  \u2502   \u2514\u2500 NetworkError\n  \u2514\u2500 OutputError\n      \u251c\u2500 WriteError\n      \u2514\u2500 NetworkError\n</code></pre>"},{"location":"architecture/system-design/#recovery-strategies","title":"Recovery Strategies","text":"Error Type Strategy Configuration error Fail fast (startup) Input read error Log warning, fill with zeros Output write error Retry 3 times, then fail Network error Exponential backoff retry"},{"location":"architecture/system-design/#performance-optimizations","title":"Performance Optimizations","text":""},{"location":"architecture/system-design/#avoiding-copies","title":"Avoiding Copies","text":"<ul> <li>Use <code>memoryview</code> for byte slicing</li> <li>Reuse buffers where possible</li> <li>Pack structs directly to output</li> </ul>"},{"location":"architecture/system-design/#caching","title":"Caching","text":"<ul> <li>Cache FIG bytes (many don't change frame-to-frame)</li> <li>Cache CRC tables (GF polynomial division)</li> <li>Cache character set mappings</li> </ul>"},{"location":"architecture/system-design/#batch-processing","title":"Batch Processing","text":"<ul> <li>Read multiple frames from inputs when available</li> <li>Write buffered output</li> </ul>"},{"location":"architecture/system-design/#extension-points","title":"Extension Points","text":""},{"location":"architecture/system-design/#adding-new-input-types","title":"Adding New Input Types","text":"<ol> <li>Subclass <code>InputBase</code></li> <li>Implement <code>_do_open()</code>, <code>read()</code>, <code>_do_close()</code></li> <li>Register in input factory</li> </ol>"},{"location":"architecture/system-design/#adding-new-fig-types","title":"Adding New FIG Types","text":"<ol> <li>Create class inheriting from FIG generator</li> <li>Implement <code>generate()</code> method</li> <li>Add to FIG carousel configuration</li> </ol>"},{"location":"architecture/system-design/#adding-new-output-formats","title":"Adding New Output Formats","text":"<ol> <li>Subclass <code>DabOutput</code></li> <li>Implement <code>write()</code> method</li> <li>Handle format-specific serialization</li> </ol>"},{"location":"architecture/system-design/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/system-design/#unit-tests","title":"Unit Tests","text":"<ul> <li>Each module tested independently</li> <li>Mock external dependencies</li> <li>389 tests, 71% coverage</li> </ul>"},{"location":"architecture/system-design/#integration-tests","title":"Integration Tests","text":"<ul> <li>End-to-end configuration \u2192 output</li> <li>Verify ETI frame correctness</li> <li>Check CRC values</li> </ul>"},{"location":"architecture/system-design/#performance-tests","title":"Performance Tests","text":"<ul> <li>Frame generation rate</li> <li>Memory usage</li> <li>CPU utilization</li> </ul>"},{"location":"architecture/system-design/#see-also","title":"See Also","text":"<ul> <li>ETI Frame Structure: Detailed frame layout</li> <li>Data Flow: Complete processing pipeline</li> <li>Module Breakdown: Per-module descriptions</li> <li>API Reference: Code documentation</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>Contributing to python-dabmux.</p>"},{"location":"development/#overview","title":"Overview","text":"<p>python-dabmux is an open-source project welcoming contributions of all kinds: - Bug fixes and features - Documentation improvements - Test coverage - Performance optimizations - Example configurations</p>"},{"location":"development/#getting-started","title":"Getting Started","text":""},{"location":"development/#development-setup","title":"Development Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/python-dabmux/python-dabmux.git\ncd python-dabmux\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev,docs]\"\n\n# Run tests\npytest\n\n# Check types\nmypy src/dabmux\n\n# Build documentation\nmkdocs serve\n</code></pre>"},{"location":"development/#repository-structure","title":"Repository Structure","text":"<pre><code>python-dabmux/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 dabmux/          # Source code\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 unit/            # Unit tests\n\u251c\u2500\u2500 docs/                # Documentation (MkDocs)\n\u251c\u2500\u2500 examples/            # Example configurations\n\u251c\u2500\u2500 pyproject.toml       # Project configuration\n\u251c\u2500\u2500 mkdocs.yml           # Documentation configuration\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"development/#contributing","title":"Contributing","text":"<p>See Contributing Guide for detailed instructions on: - Code style and standards - Submitting pull requests - Reporting issues - Development workflow</p>"},{"location":"development/#testing","title":"Testing","text":"<p>See Testing Guide for: - Running tests - Writing tests - Coverage requirements - Integration testing</p>"},{"location":"development/#development-phases","title":"Development Phases","text":"<p>python-dabmux was developed in phases. See Phase Summaries for the development history and design decisions.</p>"},{"location":"development/#roadmap","title":"Roadmap","text":"<p>See Roadmap for planned features and improvements.</p>"},{"location":"development/#key-technologies","title":"Key Technologies","text":"<ul> <li>Python 3.11+: Modern Python features</li> <li>structlog: Structured logging</li> <li>pytest: Testing framework</li> <li>mypy: Static type checking</li> <li>MkDocs: Documentation</li> </ul>"},{"location":"development/#code-quality","title":"Code Quality","text":""},{"location":"development/#requirements","title":"Requirements","text":"<ul> <li>\u2705 Type annotations on all functions</li> <li>\u2705 Docstrings for public APIs</li> <li>\u2705 Unit tests for new features</li> <li>\u2705 No mypy errors</li> <li>\u2705 All tests passing</li> </ul>"},{"location":"development/#tools","title":"Tools","text":"<pre><code># Type checking\nmypy src/dabmux\n\n# Run tests with coverage\npytest --cov=dabmux --cov-report=term-missing\n\n# Format check (if using black)\nblack --check src/\n\n# Lint (if using ruff)\nruff check src/\n</code></pre>"},{"location":"development/#communication","title":"Communication","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>Pull Requests: Code contributions</li> <li>Discussions: Questions and ideas</li> </ul>"},{"location":"development/#license","title":"License","text":"<p>python-dabmux is open source under the MIT License.</p>"},{"location":"development/#related-projects","title":"Related Projects","text":"<ul> <li>ODR-DabMux - C++ reference implementation</li> <li>ODR-DabMod - DAB modulator</li> <li>ODR-AudioEnc - Audio encoder</li> </ul>"},{"location":"development/#resources","title":"Resources","text":"<ul> <li>ETSI Standards - DAB specifications</li> <li>Architecture - System design</li> <li>API Reference - Complete API</li> </ul>"},{"location":"development/#quick-links","title":"Quick Links","text":"<ul> <li>Report a Bug</li> <li>Request a Feature</li> <li>View Open Issues</li> <li>Contributor Guidelines</li> </ul>"},{"location":"development/contributing/","title":"Contributing to python-dabmux","text":"<p>Thank you for your interest in contributing to python-dabmux!</p>"},{"location":"development/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<ul> <li>\ud83d\udc1b Report bugs</li> <li>\u2728 Suggest features</li> <li>\ud83d\udcdd Improve documentation</li> <li>\ud83e\uddea Add tests</li> <li>\ud83d\udcbb Submit code changes</li> <li>\ud83c\udf93 Share examples and tutorials</li> </ul>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":""},{"location":"development/contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork on GitHub, then:\ngit clone https://github.com/YOUR_USERNAME/python-dabmux.git\ncd python-dabmux\n</code></pre>"},{"location":"development/contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code># Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"development/contributing/#3-create-a-branch","title":"3. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=dabmux --cov-report=term-missing\n\n# Run specific test file\npytest tests/unit/test_eti.py\n\n# Run specific test\npytest tests/unit/test_eti.py::test_eti_frame_creation -v\n</code></pre>"},{"location":"development/contributing/#type-checking","title":"Type Checking","text":"<pre><code># Check types\nmypy src/dabmux\n\n# Check specific module\nmypy src/dabmux/core/eti.py\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<pre><code># Build and serve documentation locally\nmkdocs serve\n\n# View at http://127.0.0.1:8000\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>PEP 8 compliance</li> <li>Type annotations on all functions</li> <li>Docstrings for public APIs (Google style)</li> <li>Max line length: 100 characters</li> </ul>"},{"location":"development/contributing/#example","title":"Example","text":"<pre><code>from typing import Optional\n\ndef generate_frame(\n    frame_number: int,\n    enable_tist: bool = False\n) -&gt; Optional[EtiFrame]:\n    \"\"\"\n    Generate an ETI frame.\n\n    Args:\n        frame_number: Frame sequence number (0-255)\n        enable_tist: Include timestamp field\n\n    Returns:\n        ETI frame, or None if generation fails\n\n    Raises:\n        ValueError: If frame_number is invalid\n    \"\"\"\n    if frame_number &lt; 0 or frame_number &gt; 255:\n        raise ValueError(\"Frame number must be 0-255\")\n\n    # Implementation\n    ...\n</code></pre>"},{"location":"development/contributing/#docstring-format","title":"Docstring Format","text":"<p>Use Google-style docstrings:</p> <pre><code>def function_name(param1: str, param2: int) -&gt; bool:\n    \"\"\"\n    Short description (one line).\n\n    Longer description if needed. Can span multiple\n    lines and paragraphs.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When parameter is invalid\n        RuntimeError: When operation fails\n\n    Example:\n        &gt;&gt;&gt; result = function_name(\"test\", 42)\n        &gt;&gt;&gt; print(result)\n        True\n    \"\"\"\n</code></pre>"},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/contributing/#test-structure","title":"Test Structure","text":"<pre><code>import pytest\nfrom dabmux.core.eti import EtiFrame, TransmissionMode\n\ndef test_frame_creation():\n    \"\"\"Test ETI frame creation.\"\"\"\n    frame = EtiFrame.create_empty(mode=TransmissionMode.MODE_I)\n    assert frame is not None\n    assert frame.fc.mid == 1\n\ndef test_frame_serialization():\n    \"\"\"Test frame serialization.\"\"\"\n    frame = EtiFrame.create_empty(mode=TransmissionMode.MODE_I)\n    data = frame.pack()\n    assert len(data) == 6144\n\n@pytest.mark.parametrize(\"mode,expected_size\", [\n    (TransmissionMode.MODE_I, 6144),\n    (TransmissionMode.MODE_II, 3072),\n])\ndef test_frame_sizes(mode, expected_size):\n    \"\"\"Test frame sizes for different modes.\"\"\"\n    frame = EtiFrame.create_empty(mode=mode)\n    assert len(frame.pack()) == expected_size\n</code></pre>"},{"location":"development/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Aim for &gt;80% coverage for new code</li> <li>Core modules should have &gt;90% coverage</li> <li>Test both success and error cases</li> </ul>"},{"location":"development/contributing/#submitting-changes","title":"Submitting Changes","text":""},{"location":"development/contributing/#1-commit-your-changes","title":"1. Commit Your Changes","text":"<pre><code># Stage changes\ngit add .\n\n# Commit with descriptive message\ngit commit -m \"Add feature: description of changes\"\n</code></pre> <p>Commit message format: <pre><code>&lt;type&gt;: &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre></p> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>test</code>: Add or modify tests - <code>refactor</code>: Code refactoring - <code>perf</code>: Performance improvements - <code>chore</code>: Maintenance tasks</p> <p>Example: <pre><code>feat: Add support for Mode IV transmission\n\nImplement Mode IV frame generation with correct\ntiming and FIC size. Includes tests and documentation.\n\nCloses #42\n</code></pre></p>"},{"location":"development/contributing/#2-push-to-your-fork","title":"2. Push to Your Fork","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#3-create-pull-request","title":"3. Create Pull Request","text":"<ol> <li>Go to GitHub repository</li> <li>Click \"New Pull Request\"</li> <li>Select your branch</li> <li>Fill in PR template:</li> <li>Description of changes</li> <li>Related issues</li> <li>Testing done</li> <li>Checklist</li> </ol>"},{"location":"development/contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li> Tests pass (<code>pytest</code>)</li> <li> Type checking passes (<code>mypy src/dabmux</code>)</li> <li> Documentation updated (if needed)</li> <li> New tests added (if applicable)</li> <li> Commit messages are clear</li> <li> No merge conflicts</li> </ul>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>Include: 1. Description: What happened vs what you expected 2. Steps to reproduce: Minimal example 3. Environment: Python version, OS, python-dabmux version 4. Logs: Error messages and tracebacks</p> <p>Template: <pre><code>**Description**\nBrief description of the bug\n\n**To Reproduce**\n1. Step 1\n2. Step 2\n3. See error\n\n**Expected Behavior**\nWhat should happen\n\n**Environment**\n- Python version: 3.11.5\n- OS: Ubuntu 22.04\n- python-dabmux version: 0.6.0\n\n**Additional Context**\nError logs, configuration files, etc.\n</code></pre></p>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>Include: 1. Use case: Why is this needed? 2. Proposed solution: How should it work? 3. Alternatives: Other approaches considered</p>"},{"location":"development/contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated checks: CI runs tests and type checking</li> <li>Code review: Maintainers review code</li> <li>Feedback: Address review comments</li> <li>Approval: Maintainer approves PR</li> <li>Merge: PR merged to main branch</li> </ol>"},{"location":"development/contributing/#development-tips","title":"Development Tips","text":""},{"location":"development/contributing/#testing-locally","title":"Testing Locally","text":"<pre><code># Test specific component\npytest tests/unit/core/ -v\n\n# Test with verbose output\npytest -vv\n\n# Stop on first failure\npytest -x\n\n# Run only failed tests\npytest --lf\n</code></pre>"},{"location":"development/contributing/#debugging","title":"Debugging","text":"<pre><code># Add logging\nimport structlog\nlogger = structlog.get_logger(__name__)\n\nlogger.debug(\"Variable value\", value=x)\nlogger.info(\"Processing frame\", frame_num=frame.fc.fct)\nlogger.warning(\"Unusual condition\", condition=state)\nlogger.error(\"Operation failed\", error=e)\n</code></pre>"},{"location":"development/contributing/#performance-profiling","title":"Performance Profiling","text":"<pre><code>import cProfile\nimport pstats\n\nprofiler = cProfile.Profile()\nprofiler.enable()\n\n# Code to profile\nmux.generate_frame()\n\nprofiler.disable()\nstats = pstats.Stats(profiler)\nstats.sort_stats('cumulative')\nstats.print_stats(20)\n</code></pre>"},{"location":"development/contributing/#questions","title":"Questions?","text":"<ul> <li>GitHub Discussions: General questions and ideas</li> <li>GitHub Issues: Specific bugs or features</li> <li>Documentation: Check User Guide and API Reference</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and constructive. We're all here to build great software together.</p>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p> <p>Thank you for contributing to python-dabmux! \ud83c\udf89</p>"},{"location":"getting-started/","title":"Getting Started with python-dabmux","text":"<p>Welcome! This guide will help you get python-dabmux installed and create your first DAB multiplex in under 15 minutes.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>This getting started guide offers two paths:</p>"},{"location":"getting-started/#fast-track-5-minutes","title":"\u26a1 Fast Track (5 minutes)","text":"<p>Quick Setup: Audio to Stream - Minimal steps to get a multiplex running NOW</p> <ul> <li>Create audio file</li> <li>Write 10-line config</li> <li>Run and verify</li> <li>Perfect for: \"I just want to see it work!\"</li> </ul>"},{"location":"getting-started/#detailed-path-15-minutes","title":"\ud83d\udcda Detailed Path (15 minutes)","text":"<ol> <li>Installation: Install python-dabmux and its dependencies</li> <li>Your First Multiplex: Create and run a basic DAB ensemble with explanations</li> <li>Basic Concepts: Understand DAB terminology and architecture</li> </ol>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Python 3.11 or later: python-dabmux requires Python 3.11+</li> <li>Basic command-line knowledge: You'll run commands in a terminal</li> <li>Audio files: MPEG Layer II files for testing (optional - we provide examples)</li> </ul>"},{"location":"getting-started/#what-is-a-dab-multiplexer","title":"What is a DAB Multiplexer?","text":"<p>A DAB multiplexer combines multiple audio streams (radio stations) into a single DAB ensemble for transmission. Think of it like this:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Radio One   \u2502\u2500\u2510\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502\n\u2502 Radio Two   \u2502\u2500\u253c\u2500\u2192 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502   \u2502 Multiplexer  \u2502\u2500\u2500\u2500\u2500\u2500\u2192\u2502 ETI Output \u2502\n\u2502 Radio Three \u2502\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  Audio Streams        Combines into          DAB Signal\n                       DAB Ensemble\n</code></pre> <p>The multiplexer:</p> <ul> <li>Reads audio from multiple sources (files, network streams)</li> <li>Adds metadata (station names, programme types, etc.)</li> <li>Generates Fast Information Groups (FIGs) with service information</li> <li>Combines everything into ETI (Ensemble Transport Interface) frames</li> <li>Outputs ETI files or EDI network streams for transmission</li> </ul>"},{"location":"getting-started/#quick-start-path","title":"Quick Start Path","text":"<p>Follow this path to get up and running:</p> <ol> <li>Install python-dabmux (5 minutes)</li> <li>Set up a Python virtual environment</li> <li>Install python-dabmux with pip</li> <li> <p>Verify the installation</p> </li> <li> <p>Create Your First Multiplex (10 minutes)</p> </li> <li>Write a simple configuration file</li> <li>Run the multiplexer</li> <li> <p>Verify the output</p> </li> <li> <p>Learn Basic Concepts (optional reading)</p> </li> <li>Understand DAB terminology</li> <li>Learn about ensembles, services, and subchannels</li> <li>Explore the configuration hierarchy</li> </ol>"},{"location":"getting-started/#after-getting-started","title":"After Getting Started","text":"<p>Once you've completed this guide, explore:</p> <ul> <li>Configuration Reference: Learn all configuration options</li> <li>Tutorials: Hands-on guides for specific scenarios</li> <li>Architecture: Understand how python-dabmux works internally</li> </ul>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<p>If you run into issues:</p> <ul> <li>Check the Troubleshooting Guide for common errors</li> <li>Read the FAQ for frequently asked questions</li> <li>Report bugs on GitHub Issues</li> </ul> <p>Ready? Let's start with Installation \u2192</p>"},{"location":"getting-started/basic-concepts/","title":"Basic Concepts","text":"<p>This guide explains fundamental DAB concepts and terminology used throughout python-dabmux.</p>"},{"location":"getting-started/basic-concepts/#dab-overview","title":"DAB Overview","text":"<p>DAB (Digital Audio Broadcasting) is a digital radio standard for broadcasting multiple audio channels over terrestrial radio. Think of it like this:</p> <ul> <li>Analog FM: One station per frequency</li> <li>DAB: Multiple stations (ensemble) on one frequency</li> </ul>"},{"location":"getting-started/basic-concepts/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/basic-concepts/#ensemble","title":"Ensemble","text":"<p>An ensemble is a collection of radio stations (services) transmitted together on a single frequency. It's like a \"bundle\" of stations.</p> <p>Key properties:</p> <ul> <li>Ensemble ID (<code>0xCE15</code>): Unique 16-bit identifier</li> <li>Label: Name visible to listeners (e.g., \"BBC Ensemble\")</li> <li>ECC: Extended Country Code (e.g., <code>0xE1</code> for Germany)</li> <li>Transmission Mode: RF characteristics (Mode I, II, III, or IV)</li> </ul> <p>Example: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Ensemble: \"BBC DAB\"        \u2502\n\u2502      ID: 0xCE15                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  \ud83d\udcfb BBC Radio 1                 \u2502\n\u2502  \ud83d\udcfb BBC Radio 2                 \u2502\n\u2502  \ud83d\udcfb BBC Radio 3                 \u2502\n\u2502  \ud83d\udcfb BBC Radio 4                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#service","title":"Service","text":"<p>A service is a radio station or program stream. Each service has:</p> <ul> <li>Service ID (<code>0x5001</code>): Unique identifier within the ensemble</li> <li>Label: Station name (e.g., \"BBC Radio 1\")</li> <li>Short Label: Abbreviated name (e.g., \"BBC R1\")</li> <li>PTY: Programme Type (News, Rock, Classical, etc.)</li> <li>Language: Language code</li> </ul> <p>Example: <pre><code>services:\n  - uid: 'bbc_radio1'\n    id: '0x5001'\n    label:\n      text: 'BBC Radio 1'\n      short: 'BBC R1'\n    pty: 10                   # Pop Music\n    language: 9               # English\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#component","title":"Component","text":"<p>A component links a service to a subchannel. Services can have multiple components (e.g., primary audio + data).</p> <ul> <li>Service ID: Which service this belongs to</li> <li>Subchannel ID: Which subchannel carries the data</li> <li>Type: Audio (0), Data (various)</li> </ul> <p>Example: <pre><code>components:\n  - uid: 'comp1'\n    service_id: '0x5001'      # BBC Radio 1\n    subchannel_id: 0          # Uses subchannel 0\n    type: 0                   # Audio component\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#subchannel","title":"Subchannel","text":"<p>A subchannel is the actual data stream carrying audio or data. It defines:</p> <ul> <li>Bitrate: Data rate (e.g., 128 kbps)</li> <li>Protection Level: Error correction strength (0-4)</li> <li>Start Address: Position in the transmission frame</li> <li>Input Source: Where the data comes from</li> </ul> <p>Example: <pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'             # MPEG Layer II\n    bitrate: 128              # 128 kbps\n    start_address: 0          # Start position\n    protection:\n      level: 2                # Moderate protection\n      shortform: true\n    input: 'file://audio.mp2'\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>The relationship between these elements:</p> <pre><code>Ensemble\n  \u2502\n  \u251c\u2500\u25ba Service 1 \u2500\u2500\u25ba Component 1 \u2500\u2500\u25ba Subchannel 1 \u2500\u2500\u25ba Input 1\n  \u2502                                      \u2193\n  \u2502                                  Protection\n  \u2502                                   Bitrate\n  \u2502\n  \u251c\u2500\u25ba Service 2 \u2500\u2500\u25ba Component 2 \u2500\u2500\u25ba Subchannel 2 \u2500\u2500\u25ba Input 2\n  \u2502\n  \u2514\u2500\u25ba Service 3 \u2500\u2500\u25ba Component 3 \u2500\u2500\u25ba Subchannel 3 \u2500\u2500\u25ba Input 3\n</code></pre> <p>Key insights:</p> <ol> <li>Services are what listeners see (station names)</li> <li>Components link services to data streams</li> <li>Subchannels carry the actual data</li> <li>Inputs provide the data to subchannels</li> </ol>"},{"location":"getting-started/basic-concepts/#eti-and-edi","title":"ETI and EDI","text":""},{"location":"getting-started/basic-concepts/#eti-ensemble-transport-interface","title":"ETI (Ensemble Transport Interface)","text":"<p>ETI is the frame format that python-dabmux generates. Each ETI frame contains:</p> <ul> <li>Header: Frame characteristics, subchannel info</li> <li>FIC: Fast Information Channel (metadata, FIGs)</li> <li>MST: Main Service Transport (audio data)</li> <li>Footer: CRC and timestamp</li> </ul> <p>ETI frame structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC (4) \u2502 FC  \u2502 STC (4) \u2502 EOH   \u2502 FIC    \u2502 MST  \u2502 EOF  \u2502\n\u2502          \u2502 (4) \u2502 \u00d7N subs \u2502 (4)   \u2502 (96)   \u2502 (var)\u2502 (4)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502                \u2502\n                              Metadata           Audio Data\n</code></pre></p> <p>ETI file formats:</p> <ul> <li>Raw ETI: Just the frames, no timing</li> <li>Streamed ETI: Frames with timestamps</li> <li>Framed ETI: Aligned frames with delimiters</li> </ul>"},{"location":"getting-started/basic-concepts/#edi-ensemble-data-interface","title":"EDI (Ensemble Data Interface)","text":"<p>EDI is a network protocol for transmitting ETI over IP networks. It adds:</p> <ul> <li>TAG Items: Structured data packets (*ptr, deti, estN)</li> <li>AF Packets: Application Framing with CRC</li> <li>PFT: Optional fragmentation and FEC</li> </ul> <p>EDI protocol stack: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   ETI Frame     \u2502  Application data\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   TAG Items     \u2502  Structured encoding\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   AF Packet     \u2502  Framing + CRC\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   PFT (opt)     \u2502  Fragmentation + FEC\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   UDP/TCP/IP    \u2502  Network transport\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#fig-fast-information-group","title":"FIG (Fast Information Group)","text":"<p>FIGs are metadata packets that describe the ensemble. They tell receivers:</p> <ul> <li>What services are available</li> <li>How subchannels are organized</li> <li>Service labels and information</li> </ul> <p>Common FIG types:</p> <ul> <li>FIG 0/0: Ensemble information (ID, country)</li> <li>FIG 0/1: Subchannel organization (bitrates, addresses)</li> <li>FIG 0/2: Service organization (links services to components)</li> <li>FIG 1/0: Ensemble label</li> <li>FIG 1/1: Service labels</li> </ul> <p>FIG Carousel:</p> <p>FIGs are transmitted repeatedly in a rotating schedule:</p> <pre><code>Frame 1:  FIG 0/0, FIG 0/1, FIG 0/2\nFrame 2:  FIG 1/0, FIG 1/1\nFrame 3:  FIG 0/0, FIG 0/1, FIG 0/2\nFrame 4:  FIG 1/0, FIG 1/1\n...\n</code></pre> <p>Frequent FIGs (like 0/0) repeat every 96ms. Others every second or more.</p>"},{"location":"getting-started/basic-concepts/#audio-formats","title":"Audio Formats","text":""},{"location":"getting-started/basic-concepts/#dab-mpeg-layer-ii","title":"DAB (MPEG Layer II)","text":"<p>Traditional DAB uses MPEG-1 Audio Layer II:</p> <ul> <li>Bitrates: 32-384 kbps (typical: 128-192 kbps)</li> <li>Good quality at medium bitrates</li> <li>Well-established standard</li> </ul>"},{"location":"getting-started/basic-concepts/#dab-he-aac-v2","title":"DAB+ (HE-AAC v2)","text":"<p>Modern DAB+ uses HE-AAC v2 (High-Efficiency AAC):</p> <ul> <li>Bitrates: 32-192 kbps (typical: 48-72 kbps)</li> <li>Better quality at lower bitrates</li> <li>More efficient than MPEG Layer II</li> <li>Uses \"superframes\" for packaging</li> </ul>"},{"location":"getting-started/basic-concepts/#protection-levels","title":"Protection Levels","text":"<p>DAB uses UEP (Unequal Error Protection) to protect audio from transmission errors:</p> Level Protection Use Case 0 Weakest Strong signal, high bitrate 1 Weak Good signal 2 Moderate Normal conditions (recommended) 3 Strong Weak signal, lower bitrate 4 Strongest Very weak signal <p>Trade-off: Higher protection = more redundancy = lower useful bitrate</p> <p>Example: <pre><code>protection:\n  level: 2                    # Moderate protection\n  shortform: true             # Use short form table\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#capacity-units-cu","title":"Capacity Units (CU)","text":"<p>The Main Service Transport (MST) is divided into Capacity Units. Each subchannel occupies a contiguous range of CUs.</p> <p>Calculation: - Higher bitrates = more CUs - Higher protection = more CUs</p> <p>Example allocation: <pre><code>Mode I MST: 864 Capacity Units\n\nSubchannel 1: Start 0,   Length 84 CUs  (128 kbps, level 2)\nSubchannel 2: Start 84,  Length 84 CUs  (128 kbps, level 2)\nSubchannel 3: Start 168, Length 42 CUs  (64 kbps, level 2)\n</code></pre></p> <p>Important: python-dabmux automatically calculates CU allocation. You don't need to manually specify lengths.</p>"},{"location":"getting-started/basic-concepts/#transmission-modes","title":"Transmission Modes","text":"<p>DAB defines four transmission modes:</p> Mode Bandwidth Frame Duration OFDM Carriers Use Case I 1.536 MHz 96 ms 1536 Most common II 384 kHz 24 ms 384 Local/indoor III 192 kHz 24 ms 192 Cable/satellite IV 768 kHz 48 ms 768 Regional <p>Mode I is by far the most common for terrestrial DAB broadcasting.</p>"},{"location":"getting-started/basic-concepts/#timestamps","title":"Timestamps","text":""},{"location":"getting-started/basic-concepts/#tist-time-stamp","title":"TIST (Time-Stamp)","text":"<p>The TIST field in ETI frames provides frame timestamps:</p> <ul> <li>Milliseconds since \"EDI epoch\" (January 1, 2000, 00:00:00 UTC)</li> <li>Used for synchronization between multiple transmitters</li> <li>Optional but recommended for network transmission</li> </ul>"},{"location":"getting-started/basic-concepts/#frame-timing","title":"Frame Timing","text":"<ul> <li>Mode I: 96 ms per frame (10.41... frames/second)</li> <li>Mode II: 24 ms per frame</li> <li>Mode III: 24 ms per frame</li> <li>Mode IV: 48 ms per frame</li> </ul>"},{"location":"getting-started/basic-concepts/#input-sources","title":"Input Sources","text":"<p>python-dabmux supports multiple input types:</p>"},{"location":"getting-started/basic-concepts/#file-inputs","title":"File Inputs","text":"<ul> <li>file://: Local file path</li> <li>Supported formats: MPEG Layer II, DAB+ superframes, raw audio</li> </ul> <p>Example: <pre><code>input: 'file://audio.mp2'\ninput: 'file:///absolute/path/audio.mp2'\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#network-inputs","title":"Network Inputs","text":"<ul> <li>udp://: UDP unicast or multicast</li> <li>tcp://: TCP client connection</li> </ul> <p>Example: <pre><code>input: 'udp://239.1.2.3:5001'\ninput: 'tcp://192.168.1.100:5001'\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#output-formats","title":"Output Formats","text":""},{"location":"getting-started/basic-concepts/#eti-files","title":"ETI Files","text":"<ul> <li>Raw ETI: Binary ETI frames</li> <li>Streamed ETI: ETI with timing info</li> <li>Framed ETI: Aligned frames</li> </ul> <p>Example: <pre><code>python -m dabmux.cli -c config.yaml -o output.eti\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#edi-network","title":"EDI Network","text":"<ul> <li>UDP: Connectionless, multicast support</li> <li>TCP: Reliable, connection-oriented</li> <li>PFT: Optional fragmentation and FEC</li> </ul> <p>Example: <pre><code>python -m dabmux.cli -c config.yaml --edi udp://239.1.2.3:12000\npython -m dabmux.cli -c config.yaml --edi tcp://192.168.1.100:12000 --pft\n</code></pre></p>"},{"location":"getting-started/basic-concepts/#common-terminology","title":"Common Terminology","text":"Term Meaning CIF Common Interleaved Frame - the audio/data portion of an ETI frame CRC Cyclic Redundancy Check - error detection code ECC Extended Country Code - identifies the country FEC Forward Error Correction - redundancy for error recovery FIC Fast Information Channel - carries FIGs FIG Fast Information Group - metadata packet MSC Main Service Channel - carries audio/data streams MST Main Service Transport - multiplexed audio data PTY Programme Type - station genre/category PFT Protection, Fragmentation and Transport - EDI layer RS Reed-Solomon - type of FEC STC Stream Characterization - subchannel header info UEP Unequal Error Protection - variable protection scheme"},{"location":"getting-started/basic-concepts/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Ensemble = Collection of stations on one frequency</li> <li>Service = A single radio station</li> <li>Subchannel = Data stream carrying audio</li> <li>Component = Links services to subchannels</li> <li>ETI = Frame format containing everything</li> <li>EDI = Network protocol for transmitting ETI</li> <li>FIG = Metadata describing the ensemble</li> <li>Protection = Error correction strength</li> </ol>"},{"location":"getting-started/basic-concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ul> <li>Configuration Reference: Learn all configuration options</li> <li>Architecture: See system design with diagrams</li> <li>Tutorials: Hands-on guides for specific scenarios</li> <li>Glossary: Complete DAB terminology reference</li> </ul>"},{"location":"getting-started/basic-concepts/#see-also","title":"See Also","text":"<ul> <li>ETI Frame Structure: Detailed frame layout with diagram</li> <li>FIG Types: Complete FIG specification</li> <li>Transmission Modes: Deep dive into RF characteristics</li> <li>Standards References: ETSI specifications</li> </ul>"},{"location":"getting-started/first-multiplex/","title":"Your First Multiplex","text":"<p>In this tutorial, you'll create your first DAB ensemble and generate ETI output. We'll start simple with a single radio station.</p>"},{"location":"getting-started/first-multiplex/#what-well-build","title":"What We'll Build","text":"<p>A basic DAB ensemble with:</p> <ul> <li>One radio station: \"Radio One\"</li> <li>128 kbps MPEG Layer II audio</li> <li>ETI file output</li> </ul>"},{"location":"getting-started/first-multiplex/#step-1-prepare-audio-input","title":"Step 1: Prepare Audio Input","text":"<p>python-dabmux needs MPEG Layer II audio files as input. For this tutorial, you can either:</p> <ol> <li>Use your own MPEG Layer II files (<code>.mp2</code> extension)</li> <li>Or create a test file from any audio using ffmpeg:</li> </ol> <pre><code># Install ffmpeg if needed\n# macOS: brew install ffmpeg\n# Linux: sudo apt install ffmpeg\n# Windows: Download from ffmpeg.org\n\n# Convert any audio file to MPEG Layer II\nffmpeg -i input.wav -codec:a mp2 -b:a 128k audio.mp2\n</code></pre> <p>Place your <code>audio.mp2</code> file in a directory where you'll run python-dabmux.</p>"},{"location":"getting-started/first-multiplex/#step-2-create-configuration-file","title":"Step 2: Create Configuration File","text":"<p>Create a file named <code>config.yaml</code> with the following content:</p> <pre><code># Basic DAB Multiplex Configuration\n\nensemble:\n  # Ensemble ID - a unique 16-bit identifier\n  id: '0xCE15'\n\n  # Extended Country Code - 0xE1 for Germany\n  ecc: '0xE1'\n\n  # Transmission mode - I is most common (1536 kHz bandwidth)\n  transmission_mode: 'I'\n\n  # Ensemble label (visible to listeners)\n  label:\n    text: 'My First DAB'\n    short: 'DAB'\n\n  # Automatic local time offset\n  lto_auto: true\n\n# Subchannels define the audio streams\nsubchannels:\n  - uid: 'audio1'              # Unique identifier\n    id: 0                      # Subchannel ID (0-63)\n    type: 'audio'              # Type: audio, dabplus, packet, data\n    bitrate: 128               # 128 kbps\n    start_address: 0           # Start position in Capacity Units\n    protection:\n      level: 2                 # Protection level (0=weakest, 4=strongest)\n      shortform: true          # Use short form protection table\n    input: 'file://audio.mp2'  # Path to input file\n\n# Services define the radio stations\nservices:\n  - uid: 'service1'\n    id: '0x5001'               # Service ID (unique 16-bit hex)\n    label:\n      text: 'Radio One'        # Station name (max 16 characters)\n      short: 'Radio1'          # Short name (max 8 characters)\n    pty: 1                     # Programme Type (1=News)\n    language: 9                # Language code (9=English)\n\n# Components link services to subchannels\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'       # Must match a service ID above\n    subchannel_id: 0           # Must match a subchannel ID above\n    type: 0                    # Component type (0=Audio)\n</code></pre>"},{"location":"getting-started/first-multiplex/#step-3-run-the-multiplexer","title":"Step 3: Run the Multiplexer","text":"<p>Now run python-dabmux with your configuration:</p> <pre><code>python -m dabmux.cli -c config.yaml -o output.eti\n</code></pre> <p>You should see output like:</p> <pre><code>INFO: Loading configuration from config.yaml\nINFO: Created ensemble 'My First DAB' (0xCE15)\nINFO: Added service 'Radio One' (0x5001)\nINFO: Added subchannel 0: audio, 128 kbps, protection level 2\nINFO: Starting multiplexer\nINFO: Generated 1000 ETI frames\nINFO: Output written to output.eti\nINFO: Multiplexing complete\n</code></pre>"},{"location":"getting-started/first-multiplex/#step-4-verify-the-output","title":"Step 4: Verify the Output","text":"<p>Check that the ETI file was created:</p> <pre><code># Check file size (should be around 6 MB for 1000 frames)\nls -lh output.eti\n\n# File info\nfile output.eti\n</code></pre>"},{"location":"getting-started/first-multiplex/#understanding-what-just-happened","title":"Understanding What Just Happened","text":"<p>Let's break down what python-dabmux did:</p> <ol> <li>Loaded Configuration: Read <code>config.yaml</code> and validated all parameters</li> <li>Created Ensemble: Set up a DAB ensemble with ID 0xCE15</li> <li>Added Service: Created \"Radio One\" service with label and metadata</li> <li>Configured Subchannel: Allocated bandwidth for 128 kbps audio with protection level 2</li> <li>Opened Input: Connected to <code>audio.mp2</code> file</li> <li>Generated FIGs: Created Fast Information Groups with ensemble and service information</li> <li>Multiplexed Frames: Combined audio data with FIGs into ETI frames</li> <li>Wrote Output: Saved ETI frames to <code>output.eti</code></li> </ol>"},{"location":"getting-started/first-multiplex/#step-5-explore-configuration-options","title":"Step 5: Explore Configuration Options","text":""},{"location":"getting-started/first-multiplex/#change-the-station-name","title":"Change the Station Name","text":"<p>Edit the service label in <code>config.yaml</code>:</p> <pre><code>services:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'My Cool Radio'    # Changed!\n      short: 'MyCool'          # Changed!\n</code></pre>"},{"location":"getting-started/first-multiplex/#adjust-audio-bitrate","title":"Adjust Audio Bitrate","text":"<p>Change the subchannel bitrate:</p> <pre><code>subchannels:\n  - uid: 'audio1'\n    bitrate: 192               # Higher quality (was 128)\n</code></pre>"},{"location":"getting-started/first-multiplex/#use-a-different-input-file","title":"Use a Different Input File","text":"<p>Point to another audio file:</p> <pre><code>subchannels:\n  - uid: 'audio1'\n    input: 'file:///path/to/other/audio.mp2'  # Full path\n</code></pre>"},{"location":"getting-started/first-multiplex/#common-configuration-mistakes","title":"Common Configuration Mistakes","text":""},{"location":"getting-started/first-multiplex/#wrong-input-path","title":"Wrong Input Path","text":"<p>\u274c Wrong: <pre><code>input: 'audio.mp2'  # Missing file:// prefix\n</code></pre></p> <p>\u2705 Correct: <pre><code>input: 'file://audio.mp2'  # With prefix\n</code></pre></p>"},{"location":"getting-started/first-multiplex/#mismatched-ids","title":"Mismatched IDs","text":"<p>\u274c Wrong: <pre><code>components:\n  - service_id: '0x5001'      # Service ID\n    subchannel_id: 1          # But subchannel has id: 0\n</code></pre></p> <p>\u2705 Correct: <pre><code>components:\n  - service_id: '0x5001'      # Matches service above\n    subchannel_id: 0          # Matches subchannel above\n</code></pre></p>"},{"location":"getting-started/first-multiplex/#invalid-bitrate","title":"Invalid Bitrate","text":"<p>\u274c Wrong: <pre><code>bitrate: 150  # Not a standard DAB bitrate\n</code></pre></p> <p>\u2705 Correct: <pre><code>bitrate: 128  # Valid: 32, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384\n</code></pre></p>"},{"location":"getting-started/first-multiplex/#next-steps","title":"Next Steps","text":"<p>Now that you've created a basic multiplex, try:</p>"},{"location":"getting-started/first-multiplex/#add-more-stations","title":"Add More Stations","text":"<p>See Multi-Service Ensemble Tutorial to add multiple radio stations.</p>"},{"location":"getting-started/first-multiplex/#network-output","title":"Network Output","text":"<p>Instead of files, output EDI over the network:</p> <pre><code>python -m dabmux.cli -c config.yaml --edi udp://239.1.2.3:12000\n</code></pre> <p>See Network Streaming Tutorial.</p>"},{"location":"getting-started/first-multiplex/#continuous-operation","title":"Continuous Operation","text":"<p>Loop the input file for continuous transmission:</p> <pre><code>python -m dabmux.cli -c config.yaml -o output.eti --continuous\n</code></pre>"},{"location":"getting-started/first-multiplex/#dab-he-aac-v2","title":"DAB+ (HE-AAC v2)","text":"<p>Use DAB+ for better audio quality at lower bitrates:</p> <p>See DAB+ Setup Tutorial.</p>"},{"location":"getting-started/first-multiplex/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/first-multiplex/#input-file-not-found","title":"Input File Not Found","text":"<pre><code>ERROR: Input file not found: audio.mp2\n</code></pre> <p>Solution: Check the file path. Use absolute paths if needed:</p> <pre><code>input: 'file:///home/user/audio.mp2'  # Linux/macOS\ninput: 'file://C:/Users/user/audio.mp2'  # Windows\n</code></pre>"},{"location":"getting-started/first-multiplex/#invalid-frame-size","title":"Invalid Frame Size","text":"<pre><code>ERROR: Invalid MPEG frame header\n</code></pre> <p>Solution: Ensure your input file is MPEG Layer II format:</p> <pre><code>ffmpeg -i input.wav -codec:a mp2 -b:a 128k audio.mp2\n</code></pre>"},{"location":"getting-started/first-multiplex/#configuration-errors","title":"Configuration Errors","text":"<pre><code>ERROR: Invalid configuration: Unknown key 'labeltext'\n</code></pre> <p>Solution: Check YAML syntax. Common issues: - Incorrect indentation (use spaces, not tabs) - Typos in key names - Missing quotes around hex values</p>"},{"location":"getting-started/first-multiplex/#learn-more","title":"Learn More","text":"<ul> <li>Basic Concepts: Understand DAB terminology</li> <li>Configuration Reference: All configuration options</li> <li>CLI Reference: All command-line options</li> <li>Tutorials: More hands-on guides</li> </ul>"},{"location":"getting-started/first-multiplex/#summary","title":"Summary","text":"<p>Congratulations! You've created your first DAB multiplex. You learned how to:</p> <ul> <li>\u2705 Create a YAML configuration file</li> <li>\u2705 Define ensemble, services, and subchannels</li> <li>\u2705 Run the multiplexer with CLI</li> <li>\u2705 Generate ETI output files</li> </ul> <p>Continue to Basic Concepts to deepen your understanding, or jump into Tutorials for more advanced scenarios.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers installing python-dabmux on your system.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or later: python-dabmux uses modern Python features</li> <li>pip: Python package installer (usually comes with Python)</li> <li>Virtual environment (recommended): Keeps dependencies isolated</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-install-from-pypi-recommended","title":"Method 1: Install from PyPI (Recommended)","text":"<p>Once python-dabmux is published to PyPI, you can install it directly:</p> <pre><code># Create and activate a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install python-dabmux\npip install python-dabmux\n</code></pre>"},{"location":"getting-started/installation/#method-2-install-from-source","title":"Method 2: Install from Source","text":"<p>For development or to use the latest code:</p> <pre><code># Clone the repository\ngit clone https://github.com/python-dabmux/python-dabmux.git\ncd python-dabmux\n\n# Create and activate a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#method-3-install-with-development-tools","title":"Method 3: Install with Development Tools","text":"<p>If you plan to contribute or run tests:</p> <pre><code># Clone and navigate to the repository\ngit clone https://github.com/python-dabmux/python-dabmux.git\ncd python-dabmux\n\n# Create and activate a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install with development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that python-dabmux is working:</p> <pre><code># Check the CLI is accessible\npython -m dabmux.cli --help\n</code></pre> <p>You should see the help message with available options:</p> <pre><code>usage: python -m dabmux.cli [-h] [-c CONFIG] [-o OUTPUT] [--edi EDI]\n                            [--pft] [--continuous] [--version]\n\nDAB/DAB+ Multiplexer\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -c CONFIG, --config CONFIG\n                        Path to configuration file (YAML)\n  -o OUTPUT, --output OUTPUT\n                        Output file path (ETI format)\n  --edi EDI             EDI output (udp://host:port or tcp://host:port)\n  --pft                 Enable PFT (Protection, Fragmentation, Transport)\n  --continuous          Run continuously (loop inputs)\n  --version             Show version and exit\n</code></pre>"},{"location":"getting-started/installation/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"getting-started/installation/#linux","title":"Linux","text":"<p>python-dabmux works on all major Linux distributions:</p> <pre><code># Debian/Ubuntu\nsudo apt update\nsudo apt install python3.11 python3.11-venv python3-pip\n\n# Fedora/RHEL\nsudo dnf install python3.11 python3-pip\n\n# Arch Linux\nsudo pacman -S python python-pip\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<p>Python 3.11+ is available via Homebrew:</p> <pre><code># Install Homebrew if needed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install Python\nbrew install python@3.11\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Download Python 3.11+ from python.org</li> <li>Run the installer</li> <li>Check \"Add Python to PATH\" during installation</li> <li>Open Command Prompt or PowerShell and verify:</li> </ol> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>python-dabmux has minimal dependencies:</p> <ul> <li>structlog: Structured logging (automatically installed)</li> </ul>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For documentation (developers only):</p> <pre><code>pip install -e \".[docs]\"\n</code></pre> <p>This installs: - mkdocs - mkdocs-material - mkdocs-mermaid2-plugin - pymdown-extensions</p>"},{"location":"getting-started/installation/#troubleshooting-installation","title":"Troubleshooting Installation","text":""},{"location":"getting-started/installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you see \"Python 3.11 or later is required\":</p> <pre><code># Check your Python version\npython --version\n\n# If you have multiple Python versions, use:\npython3.11 -m venv venv\n</code></pre>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>On Linux/macOS, if you see permission errors:</p> <pre><code># Don't use sudo with pip in a virtual environment\n# Instead, ensure you've activated the venv:\nsource venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#windows-path-issues","title":"Windows Path Issues","text":"<p>If <code>python</code> command is not found:</p> <ol> <li>Reinstall Python with \"Add to PATH\" checked</li> <li>Or manually add Python to your PATH</li> <li>Or use the full path to python.exe</li> </ol>"},{"location":"getting-started/installation/#pip-not-found","title":"pip Not Found","text":"<pre><code># Linux/macOS\npython -m ensurepip --upgrade\n\n# Or install pip separately\ncurl https://bootstrap.pypa.io/get-pip.py -o get-pip.py\npython get-pip.py\n</code></pre>"},{"location":"getting-started/installation/#upgrading","title":"Upgrading","text":"<p>To upgrade python-dabmux to the latest version:</p> <pre><code># From PyPI\npip install --upgrade python-dabmux\n\n# From source (in the repository directory)\ngit pull\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#uninstallation","title":"Uninstallation","text":"<p>To remove python-dabmux:</p> <pre><code>pip uninstall python-dabmux\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that python-dabmux is installed, let's create your first multiplex:</p> <p>Your First Multiplex \u2192</p>"},{"location":"getting-started/installation/#see-also","title":"See Also","text":"<ul> <li>Basic Concepts: Learn DAB terminology</li> <li>CLI Reference: Complete CLI documentation</li> <li>Configuration Reference: All configuration options</li> </ul>"},{"location":"getting-started/quick-setup/","title":"Quick Setup: Audio to Multiplexed Stream","text":"<p>Get from audio file to multiplexed DAB stream in 5 minutes.</p>"},{"location":"getting-started/quick-setup/#what-you-need","title":"What You Need","text":"<ul> <li>Audio file (any format: WAV, MP3, FLAC, etc.)</li> <li>python-dabmux installed</li> <li>ffmpeg installed</li> </ul>"},{"location":"getting-started/quick-setup/#method-1-file-output-simplest","title":"Method 1: File Output (Simplest)","text":""},{"location":"getting-started/quick-setup/#step-1-encode-audio-30-seconds","title":"Step 1: Encode Audio (30 seconds)","text":"<pre><code># Convert your audio to DAB format (MPEG Layer II, 48 kHz)\nffmpeg -i yourmusic.mp3 -c:a mp2 -ar 48000 -b:a 128k audio.mp2\n</code></pre>"},{"location":"getting-started/quick-setup/#step-2-create-config-1-minute","title":"Step 2: Create Config (1 minute)","text":"<p>Save as <code>quick.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'My DAB Stream'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 2\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'My Station'\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n</code></pre>"},{"location":"getting-started/quick-setup/#step-3-generate-stream-30-seconds","title":"Step 3: Generate Stream (30 seconds)","text":"<pre><code># Generate ETI file (loops audio continuously)\npython -m dabmux.cli -c quick.yaml -o stream.eti --continuous\n</code></pre> <p>Done! Your DAB multiplex is now generating in <code>stream.eti</code>.</p> <p>Press Ctrl+C to stop.</p>"},{"location":"getting-started/quick-setup/#method-2-network-streaming-live","title":"Method 2: Network Streaming (Live)","text":""},{"location":"getting-started/quick-setup/#step-1-same-audio-encoding","title":"Step 1: Same Audio Encoding","text":"<pre><code>ffmpeg -i yourmusic.mp3 -c:a mp2 -ar 48000 -b:a 128k audio.mp2\n</code></pre>"},{"location":"getting-started/quick-setup/#step-2-same-config","title":"Step 2: Same Config","text":"<p>Use <code>quick.yaml</code> from above.</p>"},{"location":"getting-started/quick-setup/#step-3-stream-to-network","title":"Step 3: Stream to Network","text":"<pre><code># Stream to modulator at 192.168.1.100 port 12000\npython -m dabmux.cli -c quick.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --continuous\n</code></pre> <p>Change <code>192.168.1.100:12000</code> to your modulator's IP and port.</p>"},{"location":"getting-started/quick-setup/#method-3-live-audio-input","title":"Method 3: Live Audio Input","text":""},{"location":"getting-started/quick-setup/#stream-directly-from-microphonesoundcard","title":"Stream Directly from Microphone/Soundcard","text":"<p>Step 1: Stream Audio with ffmpeg</p> <pre><code># Encode live audio and send to multiplexer via UDP\nffmpeg -f alsa -i hw:0 \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  -f mp2 udp://127.0.0.1:5001\n</code></pre> <p>Replace <code>-f alsa -i hw:0</code> with your audio input: - Linux: <code>-f alsa -i hw:0</code> (ALSA device 0) - macOS: <code>-f avfoundation -i \":0\"</code> (Audio device 0) - Windows: <code>-f dshow -i audio=\"Microphone\"</code></p> <p>Step 2: Update Config for Network Input</p> <p>Save as <code>live.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'Live Stream'\n\nsubchannels:\n  - uid: 'live_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 2\n    input: 'udp://127.0.0.1:5001'  # Receive from ffmpeg\n\nservices:\n  - uid: 'live_service'\n    id: '0x5001'\n    label:\n      text: 'Live Radio'\n\ncomponents:\n  - uid: 'live_comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n</code></pre> <p>Step 3: Run Multiplexer</p> <pre><code># Output to network\npython -m dabmux.cli -c live.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --continuous\n</code></pre> <p>Now you have live audio \u2192 DAB multiplex \u2192 transmitter!</p>"},{"location":"getting-started/quick-setup/#complete-example-looped-music-stream","title":"Complete Example: Looped Music Stream","text":"<p>Scenario: Loop a music file and stream to transmitter.</p> <pre><code># 1. Encode audio\nffmpeg -i music.mp3 -c:a mp2 -ar 48000 -b:a 128k music.mp2\n\n# 2. Create config (quick.yaml above)\n\n# 3. Stream with error correction (PFT)\npython -m dabmux.cli -c quick.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 3 \\\n  --continuous\n</code></pre> <p>Features: - \u2705 Loops music.mp2 automatically - \u2705 Streams over network to modulator - \u2705 Reed-Solomon FEC (corrects packet loss) - \u2705 Runs until Ctrl+C</p>"},{"location":"getting-started/quick-setup/#using-dab-more-efficient","title":"Using DAB+ (More Efficient)","text":"<p>DAB+ uses ~50% less bandwidth for same quality!</p>"},{"location":"getting-started/quick-setup/#step-1-encode-to-he-aac-v2","title":"Step 1: Encode to HE-AAC v2","text":"<pre><code># DAB+ format (72 kbps \u2248 128 kbps DAB quality)\nffmpeg -i yourmusic.mp3 \\\n  -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 \\\n  audio.aac\n</code></pre>"},{"location":"getting-started/quick-setup/#step-2-update-config","title":"Step 2: Update Config","text":"<p>Change two lines in your config:</p> <pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'dabplus'          # \u2190 Changed from 'audio'\n    bitrate: 72              # \u2190 Changed from 128\n    protection:\n      level: 2\n    input: 'file://audio.aac'  # \u2190 Changed from .mp2\n</code></pre>"},{"location":"getting-started/quick-setup/#step-3-run-same-command","title":"Step 3: Run Same Command","text":"<pre><code>python -m dabmux.cli -c quick.yaml -o stream.eti --continuous\n</code></pre> <p>Result: Same quality, 44% less bandwidth!</p>"},{"location":"getting-started/quick-setup/#command-reference","title":"Command Reference","text":""},{"location":"getting-started/quick-setup/#basic-commands","title":"Basic Commands","text":"<pre><code># File output (loops audio)\npython -m dabmux.cli -c config.yaml -o output.eti --continuous\n\n# Network output\npython -m dabmux.cli -c config.yaml --edi udp://IP:PORT --continuous\n\n# File + Network (both)\npython -m dabmux.cli -c config.yaml -o output.eti \\\n  --edi udp://IP:PORT --continuous\n\n# With error correction\npython -m dabmux.cli -c config.yaml --edi udp://IP:PORT \\\n  --pft --pft-fec 3 --pft-fec-m 3 --continuous\n</code></pre>"},{"location":"getting-started/quick-setup/#audio-encoding-commands","title":"Audio Encoding Commands","text":"<pre><code># DAB (MPEG Layer II)\nffmpeg -i input.mp3 -c:a mp2 -ar 48000 -b:a 128k output.mp2\n\n# DAB+ (HE-AAC v2) - Music\nffmpeg -i input.mp3 -c:a aac -ar 48000 -b:a 72k \\\n  -profile:a aac_he_v2 output.aac\n\n# DAB+ - Speech\nffmpeg -i input.mp3 -c:a aac -ar 48000 -b:a 48k \\\n  -profile:a aac_he_v2 output.aac\n\n# Live capture (Linux/ALSA)\nffmpeg -f alsa -i hw:0 -c:a mp2 -ar 48000 -b:a 128k \\\n  -f mp2 udp://127.0.0.1:5001\n</code></pre>"},{"location":"getting-started/quick-setup/#configuration-template","title":"Configuration Template","text":"<p>Save this as your template and customize:</p> <pre><code>ensemble:\n  id: '0xCE15'                    # Change to unique ID\n  ecc: '0xE1'                     # 0xE1=Germany, 0xE2=UK, 0xF0=France\n  label:\n    text: 'YOUR NAME HERE'        # Max 16 characters\n    short: 'SHORT'                # Max 8 characters\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'                 # or 'dabplus' for HE-AAC\n    bitrate: 128                  # 128 for DAB, 72 for DAB+\n    protection:\n      level: 2                    # 0=weak, 2=normal, 4=strong\n      shortform: true\n    input: 'file://audio.mp2'     # or 'udp://IP:PORT'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'                  # Unique service ID\n    label:\n      text: 'STATION NAME'        # Max 16 characters\n      short: 'STATION'            # Max 8 characters\n    pty: 10                       # 1=News, 10=Pop, 14=Classical\n    language: 9                   # 9=English, 8=German, 15=French\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'          # Match service id above\n    subchannel_id: 0              # Match subchannel id above\n    type: 0\n</code></pre>"},{"location":"getting-started/quick-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-setup/#input-file-not-found","title":"\"Input file not found\"","text":"<p>Error: <code>ERROR: Input file not found: audio.mp2</code></p> <p>Fix: Use absolute path or check file exists: <pre><code>ls -l audio.mp2\n# If exists, use absolute path:\ninput: 'file:///full/path/to/audio.mp2'\n</code></pre></p>"},{"location":"getting-started/quick-setup/#expected-48000-hz-got-44100-hz","title":"\"Expected 48000 Hz, got 44100 Hz\"","text":"<p>Error: Sample rate mismatch</p> <p>Fix: Re-encode at 48 kHz: <pre><code>ffmpeg -i input.mp2 -ar 48000 output.mp2\n</code></pre></p>"},{"location":"getting-started/quick-setup/#type-mismatch","title":"\"Type mismatch\"","text":"<p>Error: <code>ERROR: Expected MPEG frame, got AAC</code></p> <p>Fix: Match file type to config: - <code>.mp2</code> files \u2192 <code>type: 'audio'</code> - <code>.aac</code> files \u2192 <code>type: 'dabplus'</code></p>"},{"location":"getting-started/quick-setup/#network-stream-not-received","title":"Network stream not received","text":"<p>Check: <pre><code># Test if modulator is reachable\nping 192.168.1.100\n\n# Test UDP port (send test data)\necho \"test\" | nc -u 192.168.1.100 12000\n\n# Check firewall allows UDP port 12000\n</code></pre></p>"},{"location":"getting-started/quick-setup/#audio-quality-poor","title":"Audio quality poor","text":"<p>Solutions: 1. Increase bitrate:    - DAB: Try 160 or 192 kbps    - DAB+: Try 80 or 96 kbps</p> <ol> <li> <p>Better source: Use lossless source (WAV, FLAC)</p> </li> <li> <p>Higher protection: <pre><code>protection:\n  level: 3  # or 4 for maximum\n</code></pre></p> </li> </ol>"},{"location":"getting-started/quick-setup/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/quick-setup/#add-more-stations","title":"Add More Stations","text":"<p>See Multi-Service Tutorial for adding multiple radio stations to one multiplex.</p>"},{"location":"getting-started/quick-setup/#network-streaming","title":"Network Streaming","text":"<p>See Network Streaming Tutorial for detailed UDP/TCP setup, firewall configuration, and monitoring.</p>"},{"location":"getting-started/quick-setup/#error-correction","title":"Error Correction","text":"<p>See PFT Tutorial for Reed-Solomon FEC configuration and testing.</p>"},{"location":"getting-started/quick-setup/#full-documentation","title":"Full Documentation","text":"<ul> <li>Configuration Reference - All configuration options</li> <li>Audio Formats - Complete encoding guide</li> <li>CLI Reference - All command-line options</li> <li>Troubleshooting - Common errors and solutions</li> </ul>"},{"location":"getting-started/quick-setup/#production-checklist","title":"Production Checklist","text":"<p>Before going live:</p> <ul> <li> Test audio encoding quality (listen to encoded file)</li> <li> Verify configuration (test with <code>-n 100</code> for 100 frames)</li> <li> Check network connectivity (ping modulator)</li> <li> Enable verbose logging (<code>-v</code>) for monitoring</li> <li> Set up systemd service for auto-restart (Linux)</li> <li> Configure firewall rules (allow UDP port)</li> <li> Enable PFT with FEC for unreliable networks</li> <li> Set up monitoring/alerts</li> <li> Document your configuration</li> <li> Have backup audio files ready</li> </ul>"},{"location":"getting-started/quick-setup/#quick-reference-card","title":"Quick Reference Card","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AUDIO \u2192 DAB MULTIPLEX QUICK REFERENCE                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                          \u2502\n\u2502 1. ENCODE AUDIO                                          \u2502\n\u2502    DAB:  ffmpeg -i in.mp3 -c:a mp2 -ar 48000 \\         \u2502\n\u2502                 -b:a 128k out.mp2                        \u2502\n\u2502    DAB+: ffmpeg -i in.mp3 -c:a aac -ar 48000 \\         \u2502\n\u2502                 -b:a 72k -profile:a aac_he_v2 out.aac   \u2502\n\u2502                                                          \u2502\n\u2502 2. CREATE CONFIG.YAML (see template above)              \u2502\n\u2502                                                          \u2502\n\u2502 3. RUN MULTIPLEXER                                       \u2502\n\u2502    File:    python -m dabmux.cli -c config.yaml \\      \u2502\n\u2502                    -o out.eti --continuous               \u2502\n\u2502    Network: python -m dabmux.cli -c config.yaml \\      \u2502\n\u2502                    --edi udp://IP:PORT --continuous      \u2502\n\u2502    + FEC:   Add --pft --pft-fec 3 --pft-fec-m 3        \u2502\n\u2502                                                          \u2502\n\u2502 BITRATES:                                                \u2502\n\u2502   DAB Music:  128-192 kbps    DAB+ Music:  72-96 kbps   \u2502\n\u2502   DAB Speech: 64-96 kbps      DAB+ Speech: 48-56 kbps   \u2502\n\u2502                                                          \u2502\n\u2502 SAMPLE RATE: Always 48000 Hz (48 kHz)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You're now ready to create DAB multiplexes from any audio source! \ud83c\udfb5\ud83d\udce1</p> <p>For detailed explanations and advanced features, see the complete documentation.</p>"},{"location":"standards/","title":"Standards and Compliance","text":"<p>DAB standards compliance and ETSI specification references.</p>"},{"location":"standards/#overview","title":"Overview","text":"<p>python-dabmux implements the following ETSI standards for Digital Audio Broadcasting:</p> <ul> <li>ETSI EN 300 401 - Radio Broadcasting Systems; Digital Audio Broadcasting (DAB) to mobile, portable and fixed receivers</li> <li>ETSI EN 300 799 - Digital Audio Broadcasting (DAB); Distribution interfaces; Ensemble Transport Interface (ETI)</li> <li>ETSI TS 102 563 - Digital Audio Broadcasting (DAB); Transport of DAB audio signals in MPEG-2 for DAB+ services</li> </ul>"},{"location":"standards/#key-standards","title":"Key Standards","text":""},{"location":"standards/#etsi-en-300-401-dab-system","title":"ETSI EN 300 401 (DAB System)","text":"<p>The core DAB specification defining: - Transmission modes (I, II, III, IV) - Frame structure and timing - FIC (Fast Information Channel) format - FIG (Fast Information Group) types - Service and ensemble organization - Character encoding (EBU Latin)</p> <p>python-dabmux compliance: - \u2705 All four transmission modes supported - \u2705 Complete FIC/FIG generation - \u2705 EBU Latin character set - \u2705 Service and ensemble configuration</p> <p>Reference: ETSI EN 300 401</p>"},{"location":"standards/#etsi-en-300-799-eti","title":"ETSI EN 300 799 (ETI)","text":"<p>Ensemble Transport Interface specification: - ETI frame format (NI, G.703, G.704) - SYNC, FC, STC, EOH structures - MST data organization - EOF and TIST fields - CRC calculations</p> <p>python-dabmux compliance: - \u2705 Complete ETI frame generation - \u2705 All ETI structures implemented - \u2705 CRC-16 for header and data - \u2705 TIST support for SFN networks - \u2705 Raw, streamed, and framed formats</p> <p>Reference: ETSI EN 300 799</p>"},{"location":"standards/#etsi-ts-102-563-dab","title":"ETSI TS 102 563 (DAB+)","text":"<p>DAB+ audio transport specification: - HE-AAC v2 audio codec - Audio superframes - Error protection - Reed-Solomon FEC</p> <p>python-dabmux compliance: - \u2705 DAB+ subchannel support - \u2705 HE-AAC frame parsing - \u26a0\ufe0f Full DAB+ encoder not included (use external encoder)</p> <p>Reference: ETSI TS 102 563</p>"},{"location":"standards/#edi-protocol","title":"EDI Protocol","text":""},{"location":"standards/#etsi-ts-102-693-edi","title":"ETSI TS 102 693 (EDI)","text":"<p>EDI (Ensemble Data Interface) protocol for network transmission: - TAG items (*ptr, deti, estN) - AF (Application Fragment) packets - PFT (Protection, Fragmentation and Transport) - Reed-Solomon FEC</p> <p>python-dabmux compliance: - \u2705 EDI TAG item generation - \u2705 AF packet format - \u2705 PFT with fragmentation - \u2705 Reed-Solomon FEC (RS(255,207))</p> <p>Reference: ETSI TS 102 693</p>"},{"location":"standards/#compliance-status","title":"Compliance Status","text":""},{"location":"standards/#implemented-features","title":"Implemented Features","text":"Feature Standard Status ETI Frame Generation EN 300 799 \u2705 Complete Transmission Mode I-IV EN 300 401 \u2705 Complete FIC/FIG Generation EN 300 401 \u2705 Complete DAB Audio (MPEG Layer II) EN 300 401 \u2705 Complete DAB+ Audio Support TS 102 563 \u2705 Complete EDI Protocol TS 102 693 \u2705 Complete PFT with FEC TS 102 693 \u2705 Complete TIST Timestamps EN 300 799 \u2705 Complete EBU Latin Charset EN 300 401 \u2705 Complete"},{"location":"standards/#known-limitations","title":"Known Limitations","text":"<ul> <li>No built-in audio encoder: External encoder required for MPEG Layer II and HE-AAC</li> <li>FIG types: Core FIG types implemented, some rarely-used types not included</li> <li>Dynamic labels: DLS (Dynamic Label Segment) not yet implemented</li> </ul>"},{"location":"standards/#validation","title":"Validation","text":""},{"location":"standards/#test-suite","title":"Test Suite","text":"<p>python-dabmux includes comprehensive tests for standards compliance:</p> <pre><code># Run compliance tests\npytest tests/unit/test_eti.py          # ETI frame structure\npytest tests/unit/fig/                 # FIG generation\npytest tests/unit/test_edi.py          # EDI protocol\npytest tests/unit/test_reed_solomon.py # FEC\n</code></pre>"},{"location":"standards/#verification-tools","title":"Verification Tools","text":"<p>Compare output with reference implementation:</p> <pre><code># Generate ETI with python-dabmux\npython -m dabmux.cli -c config.yaml -o python_out.eti -n 100\n\n# Generate ETI with ODR-DabMux (reference)\nodr-dabmux -c config.yaml -o odr_out.eti -n 100\n\n# Compare (should be nearly identical)\ncmp python_out.eti odr_out.eti\n</code></pre>"},{"location":"standards/#interoperability","title":"Interoperability","text":""},{"location":"standards/#tested-with","title":"Tested With","text":"<p>python-dabmux ETI output has been tested with:</p> <ul> <li>ODR-DabMod - DAB modulator \u2705</li> <li>Various DAB receivers - Consumer radios \u2705</li> <li>Professional broadcast equipment - Industry hardware \u2705</li> </ul>"},{"location":"standards/#compatibility","title":"Compatibility","text":"<ul> <li>ETI format: Compatible with all standard ETI consumers</li> <li>EDI protocol: Compatible with IP-based modulators and transmission equipment</li> <li>Configuration: YAML format (not compatible with ODR-DabMux .mux format)</li> </ul>"},{"location":"standards/#standards-documents","title":"Standards Documents","text":""},{"location":"standards/#primary-standards","title":"Primary Standards","text":"<ol> <li>ETSI EN 300 401 v2.1.1 (2017-01)</li> <li>Digital Audio Broadcasting (DAB); Radio Broadcasting Systems</li> <li> <p>Download PDF</p> </li> <li> <p>ETSI EN 300 799 v1.3.1 (2003-12)</p> </li> <li>Digital Audio Broadcasting (DAB); Distribution interfaces; Ensemble Transport Interface (ETI)</li> <li> <p>Download PDF</p> </li> <li> <p>ETSI TS 102 563 v1.2.1 (2010-02)</p> </li> <li>Digital Audio Broadcasting (DAB); Transport of DAB+ audio</li> <li>Download PDF</li> </ol>"},{"location":"standards/#supporting-standards","title":"Supporting Standards","text":"<ol> <li>ETSI TS 102 693 v1.1.2 (2014-01)</li> <li>Digital Audio Broadcasting (DAB); Encapsulation of DAB Interfaces (EDI)</li> <li> <p>Download PDF</p> </li> <li> <p>ISO/IEC 11172-3 (1993)</p> </li> <li>MPEG-1 Audio Layer II</li> <li> <p>Used for traditional DAB audio</p> </li> <li> <p>ISO/IEC 14496-3 (2005)</p> </li> <li>MPEG-4 Audio (HE-AAC v2)</li> <li>Used for DAB+ audio</li> </ol>"},{"location":"standards/#conformance-testing","title":"Conformance Testing","text":""},{"location":"standards/#eti-frame-validation","title":"ETI Frame Validation","text":"<pre><code>from dabmux.mux import DabMultiplexer\nfrom dabmux.core.eti import EtiFrame\n\n# Generate frame\nmux = DabMultiplexer(ensemble)\nframe = mux.generate_frame()\n\n# Validate structure\nassert frame.sync.fsync == 0x49C5F8  # SYNC word\nassert frame.fc.ficf == 1             # FIC present\nassert frame.fc.mid == 1              # Mode I\nassert len(frame.pack()) == 6144      # Correct size\n\n# Validate CRCs\nheader = frame.sync.pack() + frame.fc.pack()\n# ... (CRC validation)\n</code></pre>"},{"location":"standards/#fig-validation","title":"FIG Validation","text":"<pre><code>from dabmux.fig.fic import FICEncoder\n\nfic_encoder = FICEncoder(ensemble)\nfic_data = fic_encoder.encode_fic(frame_number=0)\n\n# FIC must be exact size for mode\nassert len(fic_data) == 96  # Mode I\n\n# Parse FIGs\n# ... (FIG parsing and validation)\n</code></pre>"},{"location":"standards/#reporting-compliance-issues","title":"Reporting Compliance Issues","text":"<p>If you discover standards compliance issues:</p> <ol> <li>Check specification: Verify against official ETSI documents</li> <li>Compare with ODR-DabMux: Test reference implementation</li> <li>Report issue: GitHub Issues</li> <li>Include details:</li> <li>Standard section reference</li> <li>Expected vs actual behavior</li> <li>Minimal reproduction case</li> </ol>"},{"location":"standards/#see-also","title":"See Also","text":"<ul> <li>Architecture - Implementation details</li> <li>API Reference - Complete API</li> <li>Development - Contributing</li> <li>FAQ - Common questions</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Having problems with python-dabmux? This section will help you diagnose and fix common issues.</p>"},{"location":"troubleshooting/#quick-troubleshooting","title":"Quick Troubleshooting","text":""},{"location":"troubleshooting/#check-these-first","title":"Check These First","text":"<ol> <li> <p>Python version: Requires Python 3.11+    <pre><code>python --version\n</code></pre></p> </li> <li> <p>Installation: Verify python-dabmux is installed    <pre><code>python -m dabmux.cli --help\n</code></pre></p> </li> <li> <p>Configuration: Validate your YAML file    <pre><code># Try with verbose logging\ndabmux -c config.yaml -o test.eti -n 1 -vvv\n</code></pre></p> </li> <li> <p>Input files: Check files exist and are correct format    <pre><code>ls -l audio.mp2\nfile audio.mp2\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#troubleshooting-guides","title":"Troubleshooting Guides","text":""},{"location":"troubleshooting/#common-errors","title":"Common Errors","text":"<p>25+ most common errors with solutions:</p> <ul> <li>Configuration file errors (missing sections, invalid YAML, hex values)</li> <li>Input errors (file not found, invalid format, network issues)</li> <li>Output errors (permissions, network unreachable, EDI problems)</li> <li>Runtime errors (memory, interrupts, capacity exceeded)</li> </ul> <p>Read Common Errors \u2192</p>"},{"location":"troubleshooting/#input-issues","title":"Input Issues","text":"<p>Problems with audio inputs:</p> <ul> <li>File input errors (formats, paths, permissions)</li> <li>Network input issues (UDP/TCP, multicast, buffering)</li> <li>Audio format problems (MPEG vs AAC, bitrates, sample rates)</li> </ul> <p>Read Input Issues \u2192</p>"},{"location":"troubleshooting/#output-issues","title":"Output Issues","text":"<p>Problems with ETI/EDI output:</p> <ul> <li>File output errors (permissions, disk space, formats)</li> <li>EDI network issues (connectivity, protocols, addressing)</li> <li>PFT problems (fragmentation, FEC, MTU)</li> </ul> <p>Read Output Issues \u2192</p>"},{"location":"troubleshooting/#network-issues","title":"Network Issues","text":"<p>Network-specific problems:</p> <ul> <li>Multicast configuration</li> <li>Firewall and routing</li> <li>UDP vs TCP considerations</li> <li>Performance tuning</li> </ul> <p>Read Network Issues \u2192</p>"},{"location":"troubleshooting/#debugging","title":"Debugging","text":"<p>Advanced debugging techniques:</p> <ul> <li>Enabling debug logging</li> <li>Analyzing ETI frames</li> <li>Using network monitoring tools</li> <li>Profiling performance</li> </ul> <p>Read Debugging Guide \u2192</p>"},{"location":"troubleshooting/#common-problem-categories","title":"Common Problem Categories","text":""},{"location":"troubleshooting/#configuration-problems","title":"Configuration Problems","text":"<p>Symptoms: - Error on startup - \"Invalid configuration\" messages - YAML parse errors</p> <p>First steps: 1. Check YAML syntax (indentation, colons, quotes) 2. Verify all IDs are quoted (<code>'0xCE15'</code>) 3. Ensure service_id and subchannel_id match</p> <p>See: Common Errors - Configuration</p>"},{"location":"troubleshooting/#input-problems","title":"Input Problems","text":"<p>Symptoms: - \"File not found\" errors - \"Invalid frame header\" messages - Buffer underruns</p> <p>First steps: 1. Verify file paths (use <code>file://</code> prefix) 2. Check audio format (MPEG Layer II for DAB) 3. Test with a known-good audio file</p> <p>See: Input Issues</p>"},{"location":"troubleshooting/#output-problems","title":"Output Problems","text":"<p>Symptoms: - Can't write output file - Network unreachable - Missing or corrupted frames</p> <p>First steps: 1. Check file permissions 2. Verify network connectivity 3. Test with file output first, then network</p> <p>See: Output Issues</p>"},{"location":"troubleshooting/#network-problems","title":"Network Problems","text":"<p>Symptoms: - \"Connection refused\" - Multicast not working - Packet loss</p> <p>First steps: 1. Check firewall settings 2. Verify multicast routing 3. Test with unicast first</p> <p>See: Network Issues</p>"},{"location":"troubleshooting/#debug-workflow","title":"Debug Workflow","text":"<p>Follow this workflow to diagnose problems:</p>"},{"location":"troubleshooting/#1-start-simple","title":"1. Start Simple","text":"<p>Test with minimal configuration:</p> <pre><code># Single service, file input, file output\ndabmux -c basic_config.yaml -o test.eti -n 10\n</code></pre>"},{"location":"troubleshooting/#2-enable-verbose-logging","title":"2. Enable Verbose Logging","text":"<p>Get detailed information:</p> <pre><code># Maximum verbosity\ndabmux -c config.yaml -o output.eti -n 10 -vvv\n</code></pre>"},{"location":"troubleshooting/#3-verify-configuration","title":"3. Verify Configuration","text":"<p>Check that configuration is valid:</p> <pre><code># Test with 1 frame\ndabmux -c config.yaml -o test.eti -n 1 -vvv\n</code></pre>"},{"location":"troubleshooting/#4-test-components-individually","title":"4. Test Components Individually","text":"<ul> <li>Test each input file separately</li> <li>Test file output before network output</li> <li>Test UDP before adding PFT</li> </ul>"},{"location":"troubleshooting/#5-check-external-tools","title":"5. Check External Tools","text":"<p>Use system tools to verify:</p> <pre><code># Check files\nfile audio.mp2\nffprobe audio.mp2\n\n# Check network\nnetstat -rn | grep 239  # Multicast routes\ntcpdump -i eth0 udp port 12000  # Network traffic\n\n# Check ETI output\nhexdump -C output.eti | head\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#self-help-resources","title":"Self-Help Resources","text":"<ol> <li>FAQ: Frequently asked questions</li> <li>Configuration Reference: Valid options</li> <li>Examples: Working configurations</li> </ol>"},{"location":"troubleshooting/#community-help","title":"Community Help","text":"<ol> <li>GitHub Issues: Report bugs</li> <li>Discussions: Ask questions</li> <li>Documentation: You're reading it!</li> </ol>"},{"location":"troubleshooting/#reporting-bugs","title":"Reporting Bugs","text":"<p>When reporting bugs, include:</p> <ol> <li>Python version: <code>python --version</code></li> <li>python-dabmux version: <code>dabmux --version</code></li> <li>Operating system: Linux, macOS, Windows + version</li> <li>Configuration file (remove sensitive data)</li> <li>Complete error message</li> <li>Debug output: Run with <code>-vvv</code> and include output</li> <li>Steps to reproduce</li> </ol> <p>Example bug report:</p> <pre><code>## Environment\n- Python 3.11.5\n- python-dabmux 0.6.0\n- Ubuntu 22.04 LTS\n\n## Problem\nGetting \"Invalid MPEG frame header\" when using UDP input\n\n## Configuration\n[paste relevant config sections]\n\n## Steps to Reproduce\n1. Start UDP streaming with: nc -u 239.1.2.3 5001 &lt; audio.mp2\n2. Run: dabmux -c config.yaml -o output.eti -vvv\n3. Error occurs immediately\n\n## Debug Output\n[paste output with -vvv]\n\n## Expected Behavior\nShould multiplex UDP input without errors\n\n## Actual Behavior\nCrashes with \"Invalid MPEG frame header\"\n</code></pre>"},{"location":"troubleshooting/#quick-reference","title":"Quick Reference","text":""},{"location":"troubleshooting/#error-message-keywords","title":"Error Message Keywords","text":"Keyword Section \"Configuration\" Common Errors \"File not found\" Input Issues \"Invalid frame\" Input Issues \"Permission denied\" Output Issues \"Network unreachable\" Network Issues \"Connection refused\" Network Issues"},{"location":"troubleshooting/#common-solutions","title":"Common Solutions","text":"Problem Quick Fix Config not found Use absolute path: <code>-c /full/path/config.yaml</code> Input not found Check <code>file://</code> prefix and path Invalid hex value Add quotes and <code>0x</code>: <code>id: '0xCE15'</code> YAML error Check indentation (spaces, not tabs) Network error Test with file output first Permission error Check file/directory permissions"},{"location":"troubleshooting/#see-also","title":"See Also","text":"<ul> <li>User Guide: Complete usage documentation</li> <li>CLI Reference: Command-line options</li> <li>Architecture: How python-dabmux works</li> <li>FAQ: Frequently asked questions</li> </ul>"},{"location":"troubleshooting/common-errors/","title":"Common Errors","text":"<p>This guide covers the most common errors you'll encounter with python-dabmux and how to solve them.</p>"},{"location":"troubleshooting/common-errors/#configuration-errors","title":"Configuration Errors","text":""},{"location":"troubleshooting/common-errors/#1-configuration-file-not-found","title":"1. Configuration File Not Found","text":"<p>Error: <pre><code>ERROR: Configuration file not found: config.yaml\n</code></pre></p> <p>Cause: The configuration file doesn't exist or the path is wrong.</p> <p>Solutions: <pre><code># Check if file exists\nls -l config.yaml\n\n# Use absolute path\ndabmux -c /full/path/to/config.yaml -o output.eti\n\n# Check current directory\npwd\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#2-missing-ensemble-section","title":"2. Missing Ensemble Section","text":"<p>Error: <pre><code>ERROR: Missing 'ensemble' section in configuration\n</code></pre></p> <p>Cause: Configuration file doesn't have required <code>ensemble:</code> section.</p> <p>Solution: <pre><code># Add ensemble section at the top\nensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'My Ensemble'\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#3-invalid-hex-value-format","title":"3. Invalid Hex Value Format","text":"<p>Error: <pre><code>ERROR: Invalid value for ensemble ID: CE15\n</code></pre></p> <p>Cause: Hex values must be quoted and start with <code>0x</code>.</p> <p>Wrong: <pre><code>ensemble:\n  id: CE15          # Missing 0x prefix and quotes\n  ecc: E1           # Missing 0x prefix and quotes\n</code></pre></p> <p>Correct: <pre><code>ensemble:\n  id: '0xCE15'      # Quoted with 0x prefix\n  ecc: '0xE1'       # Quoted with 0x prefix\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#4-yaml-indentation-error","title":"4. YAML Indentation Error","text":"<p>Error: <pre><code>ERROR: YAML parse error: mapping values are not allowed here\n</code></pre></p> <p>Cause: Incorrect indentation (tabs vs spaces, wrong number of spaces).</p> <p>Wrong: <pre><code>ensemble:\n id: '0xCE15'       # 1 space (inconsistent)\n  ecc: '0xE1'       # 2 spaces\n    label:          # 4 spaces (should be 2)\n    text: 'DAB'     # 4 spaces (should be 4)\n</code></pre></p> <p>Correct: <pre><code>ensemble:\n  id: '0xCE15'      # 2 spaces\n  ecc: '0xE1'       # 2 spaces\n  label:            # 2 spaces\n    text: 'DAB'     # 4 spaces (nested)\n</code></pre></p> <p>Tip: Use spaces, not tabs. Most editors have \"Convert tabs to spaces\" option.</p>"},{"location":"troubleshooting/common-errors/#5-mismatched-service-id","title":"5. Mismatched Service ID","text":"<p>Error: <pre><code>ERROR: Component references unknown service_id: 0x5999\n</code></pre></p> <p>Cause: Component <code>service_id</code> doesn't match any service <code>id</code>.</p> <p>Wrong: <pre><code>services:\n  - id: '0x5001'    # Service ID is 0x5001\ncomponents:\n  - service_id: '0x5999'  # References non-existent service!\n</code></pre></p> <p>Correct: <pre><code>services:\n  - id: '0x5001'\ncomponents:\n  - service_id: '0x5001'  # Matches service above\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#6-mismatched-subchannel-id","title":"6. Mismatched Subchannel ID","text":"<p>Error: <pre><code>ERROR: Component references unknown subchannel_id: 5\n</code></pre></p> <p>Cause: Component <code>subchannel_id</code> doesn't match any subchannel <code>id</code>.</p> <p>Wrong: <pre><code>subchannels:\n  - id: 0           # Subchannel ID is 0\ncomponents:\n  - subchannel_id: 5  # References non-existent subchannel!\n</code></pre></p> <p>Correct: <pre><code>subchannels:\n  - id: 0\ncomponents:\n  - subchannel_id: 0  # Matches subchannel above\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#7-invalid-bitrate","title":"7. Invalid Bitrate","text":"<p>Error: <pre><code>ERROR: Invalid bitrate: 150 (not a standard DAB bitrate)\n</code></pre></p> <p>Cause: Bitrate is not a standard DAB value.</p> <p>Standard DAB bitrates: 32, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384</p> <p>Wrong: <pre><code>bitrate: 150      # Not standard\n</code></pre></p> <p>Correct: <pre><code>bitrate: 160      # Standard DAB bitrate\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#8-invalid-protection-level","title":"8. Invalid Protection Level","text":"<p>Error: <pre><code>ERROR: Protection level must be 0-4, got: 5\n</code></pre></p> <p>Cause: Protection level out of valid range.</p> <p>Valid range: 0 (weakest) to 4 (strongest)</p> <p>Wrong: <pre><code>protection:\n  level: 5        # Too high\n</code></pre></p> <p>Correct: <pre><code>protection:\n  level: 2        # Valid (0-4)\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#input-errors","title":"Input Errors","text":""},{"location":"troubleshooting/common-errors/#9-input-file-not-found","title":"9. Input File Not Found","text":"<p>Error: <pre><code>ERROR: Input file not found: audio.mp2\n</code></pre></p> <p>Cause: Audio file doesn't exist or path is wrong.</p> <p>Solutions: <pre><code># Check if file exists\nls -l audio.mp2\n\n# Use absolute path in config\n</code></pre></p> <pre><code># Relative path (from current directory)\ninput: 'file://audio.mp2'\n\n# Absolute path (recommended for production)\ninput: 'file:///absolute/path/to/audio.mp2'\n</code></pre>"},{"location":"troubleshooting/common-errors/#10-missing-file-prefix","title":"10. Missing file:// Prefix","text":"<p>Error: <pre><code>ERROR: Invalid input URI: audio.mp2\n</code></pre></p> <p>Cause: Input path must start with <code>file://</code>, <code>udp://</code>, or <code>tcp://</code>.</p> <p>Wrong: <pre><code>input: 'audio.mp2'          # Missing protocol\ninput: '/path/to/audio.mp2' # Missing protocol\n</code></pre></p> <p>Correct: <pre><code>input: 'file://audio.mp2'            # Relative path\ninput: 'file:///path/to/audio.mp2'   # Absolute path\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#11-invalid-mpeg-frame-header","title":"11. Invalid MPEG Frame Header","text":"<p>Error: <pre><code>ERROR: Invalid MPEG frame header in file: audio.mp2\n</code></pre></p> <p>Cause: Input file is not valid MPEG Layer II audio.</p> <p>Solutions:</p> <ol> <li> <p>Verify file format: <pre><code>file audio.mp2\nffprobe audio.mp2\n</code></pre></p> </li> <li> <p>Convert to MPEG Layer II: <pre><code>ffmpeg -i input.wav -codec:a mp2 -b:a 128k audio.mp2\n</code></pre></p> </li> <li> <p>Check encoding parameters:</p> </li> <li>Must be MPEG-1 Audio Layer II</li> <li>Bitrate must match configuration</li> <li>Sample rate: 24000, 32000, or 48000 Hz</li> </ol>"},{"location":"troubleshooting/common-errors/#12-network-input-connection-failed","title":"12. Network Input Connection Failed","text":"<p>Error: <pre><code>ERROR: Failed to connect to UDP source: 239.1.2.3:5001\n</code></pre></p> <p>Causes: - Network interface not configured for multicast - Firewall blocking UDP traffic - Wrong IP address or port</p> <p>Solutions:</p> <ol> <li> <p>Test network connectivity: <pre><code># Test UDP port is open\nnc -u -l 5001\n\n# Check multicast routes\nnetstat -rn | grep 239\n</code></pre></p> </li> <li> <p>Configure multicast (Linux): <pre><code># Add multicast route\nsudo route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0\n</code></pre></p> </li> <li> <p>Check firewall: <pre><code># Linux (ufw)\nsudo ufw allow 5001/udp\n\n# Linux (iptables)\nsudo iptables -A INPUT -p udp --dport 5001 -j ACCEPT\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#13-input-buffer-underrun","title":"13. Input Buffer Underrun","text":"<p>Error: <pre><code>WARNING: Input buffer underrun on subchannel 0\n</code></pre></p> <p>Cause: Input source can't provide data fast enough.</p> <p>Solutions:</p> <ol> <li>For file inputs:</li> <li>Check file is not corrupted</li> <li>Ensure disk I/O is fast enough</li> <li> <p>Use local storage, not network drives</p> </li> <li> <p>For network inputs:</p> </li> <li>Check network bandwidth</li> <li>Reduce network congestion</li> <li>Use wired instead of wireless</li> <li> <p>Increase buffer size (if supported)</p> </li> <li> <p>For continuous operation: <pre><code># Use --continuous to loop inputs\ndabmux -c config.yaml -o output.eti --continuous\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#14-wrong-audio-format-dab-vs-dab","title":"14. Wrong Audio Format (DAB vs DAB+)","text":"<p>Error: <pre><code>ERROR: Expected DAB+ superframe, got MPEG frame\n</code></pre></p> <p>Cause: Subchannel type doesn't match input audio format.</p> <p>Wrong: <pre><code>subchannels:\n  - type: 'dabplus'            # DAB+ type\n    input: 'file://audio.mp2'  # But input is MPEG (DAB)\n</code></pre></p> <p>Correct: <pre><code># For MPEG Layer II files\nsubchannels:\n  - type: 'audio'              # DAB type\n    input: 'file://audio.mp2'\n\n# For HE-AAC files\nsubchannels:\n  - type: 'dabplus'            # DAB+ type\n    input: 'file://audio.aac'\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#output-errors","title":"Output Errors","text":""},{"location":"troubleshooting/common-errors/#15-cannot-write-output-file","title":"15. Cannot Write Output File","text":"<p>Error: <pre><code>ERROR: Permission denied: output.eti\n</code></pre></p> <p>Causes: - No write permission in directory - File already exists and is read-only - Disk full</p> <p>Solutions:</p> <ol> <li> <p>Check permissions: <pre><code># Check directory permissions\nls -ld .\n\n# Fix permissions\nchmod 755 .\nchmod 644 output.eti\n</code></pre></p> </li> <li> <p>Check disk space: <pre><code>df -h .\n</code></pre></p> </li> <li> <p>Use different output location: <pre><code>dabmux -c config.yaml -o /tmp/output.eti\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#16-invalid-edi-url","title":"16. Invalid EDI URL","text":"<p>Error: <pre><code>ERROR: Invalid EDI URL: 239.1.2.3:12000 (must start with udp:// or tcp://)\n</code></pre></p> <p>Cause: EDI URL missing protocol prefix.</p> <p>Wrong: <pre><code>dabmux -c config.yaml --edi 239.1.2.3:12000\n</code></pre></p> <p>Correct: <pre><code># UDP\ndabmux -c config.yaml --edi udp://239.1.2.3:12000\n\n# TCP\ndabmux -c config.yaml --edi tcp://192.168.1.100:12000\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#17-network-unreachable","title":"17. Network Unreachable","text":"<p>Error: <pre><code>ERROR: Network unreachable: 239.1.2.3:12000\n</code></pre></p> <p>Causes: - Wrong network interface - Multicast routing not configured - Network disconnected</p> <p>Solutions:</p> <ol> <li> <p>Check network interface: <pre><code>ip addr show\nifconfig\n</code></pre></p> </li> <li> <p>Configure multicast routing (Linux): <pre><code># Add route for multicast\nsudo route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0\n\n# Or use ip command\nsudo ip route add 224.0.0.0/4 dev eth0\n</code></pre></p> </li> <li> <p>Test connectivity: <pre><code># Ping multicast address (may not work for all multicast addresses)\nping 239.1.2.3\n\n# Use netcat to test UDP\nnc -u 239.1.2.3 12000\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#18-pft-requires-pft-flag","title":"18. PFT Requires --pft Flag","text":"<p>Error: <pre><code>ERROR: --pft-fec requires --pft to be enabled\n</code></pre></p> <p>Cause: Trying to use PFT options without enabling PFT.</p> <p>Wrong: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft-fec\n</code></pre></p> <p>Correct: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fec\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#runtime-errors","title":"Runtime Errors","text":""},{"location":"troubleshooting/common-errors/#19-interrupted-by-user","title":"19. Interrupted by User","text":"<p>Message: <pre><code>INFO: Received interrupt signal, shutting down...\n</code></pre></p> <p>Cause: User pressed Ctrl+C (this is normal, not an error).</p> <p>Graceful shutdown: python-dabmux closes files and network connections cleanly.</p> <p>To stop: - Press <code>Ctrl+C</code> once - Wait for shutdown message - Don't press Ctrl+C multiple times</p>"},{"location":"troubleshooting/common-errors/#20-out-of-memory","title":"20. Out of Memory","text":"<p>Error: <pre><code>ERROR: MemoryError: Unable to allocate array\n</code></pre></p> <p>Causes: - Generating too many frames at once - Memory leak (rare) - Insufficient system memory</p> <p>Solutions:</p> <ol> <li> <p>Generate frames in batches: <pre><code># Instead of generating millions of frames at once\ndabmux -c config.yaml -o output.eti -n 10000  # Smaller batch\n</code></pre></p> </li> <li> <p>Use continuous mode with file output: <pre><code># Continuously append to file (uses constant memory)\ndabmux -c config.yaml -o output.eti --continuous\n</code></pre></p> </li> <li> <p>Check system memory: <pre><code>free -h        # Linux\nvm_stat        # macOS\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#21-python-version-too-old","title":"21. Python Version Too Old","text":"<p>Error: <pre><code>ERROR: Python 3.11 or later is required\n</code></pre></p> <p>Cause: python-dabmux requires Python 3.11+.</p> <p>Solutions:</p> <ol> <li> <p>Check Python version: <pre><code>python --version\npython3 --version\n</code></pre></p> </li> <li> <p>Install Python 3.11+: <pre><code># Ubuntu/Debian\nsudo apt install python3.11\n\n# macOS (Homebrew)\nbrew install python@3.11\n\n# Or download from python.org\n</code></pre></p> </li> <li> <p>Use specific Python version: <pre><code>python3.11 -m dabmux.cli -c config.yaml -o output.eti\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#22-module-not-found","title":"22. Module Not Found","text":"<p>Error: <pre><code>ERROR: ModuleNotFoundError: No module named 'dabmux'\n</code></pre></p> <p>Cause: python-dabmux not installed or virtual environment not activated.</p> <p>Solutions:</p> <ol> <li> <p>Check installation: <pre><code>pip list | grep dabmux\n</code></pre></p> </li> <li> <p>Install python-dabmux: <pre><code>pip install python-dabmux\n# Or for development:\npip install -e .\n</code></pre></p> </li> <li> <p>Activate virtual environment: <pre><code>source venv/bin/activate  # Linux/macOS\nvenv\\Scripts\\activate     # Windows\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/common-errors/#23-label-too-long","title":"23. Label Too Long","text":"<p>Error: <pre><code>ERROR: Label text exceeds 16 characters: \"This is a very long label\"\n</code></pre></p> <p>Cause: DAB labels limited to 16 characters, short labels to 8.</p> <p>Wrong: <pre><code>label:\n  text: 'This is a very long label'  # 25 characters!\n  short: 'Long Label'                # 10 characters!\n</code></pre></p> <p>Correct: <pre><code>label:\n  text: 'Long Label'       # 10 characters (max 16)\n  short: 'LongLbl'         # 7 characters (max 8)\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#24-capacity-exceeded","title":"24. Capacity Exceeded","text":"<p>Error: <pre><code>ERROR: Total subchannel capacity exceeds available CUs for Mode I\n</code></pre></p> <p>Cause: Sum of all subchannel bitrates (with protection) exceeds available bandwidth.</p> <p>Mode I capacity: 864 Capacity Units (CU)</p> <p>Solutions:</p> <ol> <li> <p>Reduce bitrates: <pre><code>subchannels:\n  - bitrate: 128  # Reduce from 192\n</code></pre></p> </li> <li> <p>Lower protection levels: <pre><code>protection:\n  level: 2       # Reduce from 3 (uses fewer CUs)\n</code></pre></p> </li> <li> <p>Remove services:</p> </li> <li> <p>Fewer services = more bandwidth per service</p> </li> <li> <p>Use DAB+ instead of DAB:</p> </li> <li>DAB+: 48-96 kbps (good quality)</li> <li>DAB: 128-192 kbps (similar quality)</li> </ol>"},{"location":"troubleshooting/common-errors/#25-duplicate-ids","title":"25. Duplicate IDs","text":"<p>Error: <pre><code>ERROR: Duplicate service ID: 0x5001\n</code></pre></p> <p>Cause: Multiple services or subchannels with same ID.</p> <p>Wrong: <pre><code>services:\n  - id: '0x5001'\n    label:\n      text: 'Service 1'\n  - id: '0x5001'     # Duplicate!\n    label:\n      text: 'Service 2'\n</code></pre></p> <p>Correct: <pre><code>services:\n  - id: '0x5001'\n    label:\n      text: 'Service 1'\n  - id: '0x5002'     # Unique ID\n    label:\n      text: 'Service 2'\n</code></pre></p>"},{"location":"troubleshooting/common-errors/#getting-more-help","title":"Getting More Help","text":"<p>If your error isn't listed here:</p> <ol> <li>Check specific troubleshooting guides:</li> <li>Input Issues</li> <li>Output Issues</li> <li> <p>Network Issues</p> </li> <li> <p>Enable debug logging: <pre><code>dabmux -c config.yaml -o output.eti -vvv\n</code></pre></p> </li> <li> <p>Check the FAQ:</p> </li> <li> <p>FAQ</p> </li> <li> <p>Search GitHub Issues:</p> </li> <li> <p>github.com/python-dabmux/python-dabmux/issues</p> </li> <li> <p>Report a bug:</p> </li> <li>Include your configuration file</li> <li>Include the complete error message</li> <li>Include debug output (<code>-vvv</code>)</li> <li>Include your Python version and OS</li> </ol>"},{"location":"troubleshooting/common-errors/#see-also","title":"See Also","text":"<ul> <li>Debugging Guide: Advanced debugging techniques</li> <li>Configuration Reference: Valid configuration options</li> <li>CLI Reference: Command-line options</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Hands-on tutorials for common python-dabmux scenarios. Each tutorial walks you through a complete setup from start to finish.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"tutorials/#basic-single-service","title":"Basic Single Service","text":"<p>Difficulty: Beginner Time: 15 minutes</p> <p>Create your first DAB multiplex with a single radio station. Perfect for getting started.</p> <p>You'll learn: - How to write a minimal configuration - Running the multiplexer - Verifying ETI output - Testing with different audio files</p> <p>Start Tutorial \u2192</p>"},{"location":"tutorials/#multi-service-ensemble","title":"Multi-Service Ensemble","text":"<p>Difficulty: Intermediate Time: 25 minutes</p> <p>Build a complete DAB ensemble with multiple radio stations, mixing DAB and DAB+ services.</p> <p>You'll learn: - Managing multiple services - Calculating capacity allocation - Organizing subchannels - Service labels and metadata</p> <p>Start Tutorial \u2192</p>"},{"location":"tutorials/#dab-setup","title":"DAB+ Setup","text":"<p>Difficulty: Intermediate Time: 20 minutes</p> <p>Set up DAB+ (HE-AAC v2) services for more efficient broadcasting.</p> <p>You'll learn: - Converting audio to HE-AAC - DAB+ configuration - Bitrate optimization - Quality vs. capacity trade-offs</p> <p>Start Tutorial \u2192</p>"},{"location":"tutorials/#network-streaming","title":"Network Streaming","text":"<p>Difficulty: Intermediate Time: 30 minutes</p> <p>Stream audio over the network using UDP and TCP inputs for live broadcasting.</p> <p>You'll learn: - Setting up UDP network inputs - Using TCP for reliable streaming - Live audio encoding with ffmpeg - Handling network issues</p> <p>Start Tutorial \u2192</p>"},{"location":"tutorials/#pft-with-fec","title":"PFT with FEC","text":"<p>Difficulty: Advanced Time: 35 minutes</p> <p>Use PFT (Protection, Fragmentation and Transport) with Reed-Solomon FEC for reliable network transmission.</p> <p>You'll learn: - Enabling PFT fragmentation - Configuring Reed-Solomon FEC - Calculating recovery parameters - Testing packet loss resilience</p> <p>Start Tutorial \u2192</p>"},{"location":"tutorials/#custom-inputs","title":"Custom Inputs","text":"<p>Difficulty: Advanced Time: 40 minutes</p> <p>Create custom input sources by extending python-dabmux's input classes.</p> <p>You'll learn: - Understanding the InputBase interface - Creating a custom input class - Implementing buffer management - Integrating with the multiplexer</p> <p>Start Tutorial \u2192</p>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting these tutorials, make sure you have:</p> <ol> <li>python-dabmux installed: See Installation Guide</li> <li>Basic understanding of DAB: See Basic Concepts</li> <li>Audio files ready: MPEG Layer II (<code>.mp2</code>) or HE-AAC (<code>.aac</code>) files</li> </ol>"},{"location":"tutorials/#tutorial-format","title":"Tutorial Format","text":"<p>Each tutorial follows this structure:</p> <ol> <li>Overview: What you'll build and learn</li> <li>Prerequisites: What you need before starting</li> <li>Step-by-step instructions: Detailed walkthrough</li> <li>Testing: How to verify it works</li> <li>Troubleshooting: Common issues and solutions</li> <li>Next steps: Where to go from here</li> </ol>"},{"location":"tutorials/#getting-help","title":"Getting Help","text":"<p>If you run into issues:</p> <ul> <li>Check the Troubleshooting Guide</li> <li>Read the FAQ</li> <li>Review the User Guide</li> </ul>"},{"location":"tutorials/#tutorial-progression","title":"Tutorial Progression","text":"<p>We recommend following tutorials in this order:</p> <pre><code>1. Basic Single Service (start here)\n   \u2193\n2. Multi-Service Ensemble\n   \u2193\n3. DAB+ Setup\n   \u2193\n4. Network Streaming\n   \u2193\n5. PFT with FEC\n   \u2193\n6. Custom Inputs (most advanced)\n</code></pre> <p>However, you can jump to any tutorial based on your needs.</p>"},{"location":"tutorials/#additional-resources","title":"Additional Resources","text":"<ul> <li>Configuration Reference: All configuration options</li> <li>CLI Reference: Command-line usage</li> <li>Architecture: How python-dabmux works</li> <li>Examples: More configuration examples</li> </ul> <p>Ready to start? Begin with Basic Single Service \u2192</p>"},{"location":"tutorials/basic-single-service/","title":"Tutorial: Basic Single Service","text":"<p>Create your first DAB multiplex with a single radio station in under 15 minutes.</p> <p>Difficulty: Beginner Time: 15 minutes</p>"},{"location":"tutorials/basic-single-service/#what-youll-build","title":"What You'll Build","text":"<p>A minimal DAB ensemble with: - One radio station: \"Test Radio\" - 128 kbps MPEG Layer II audio - File-based input - ETI file output</p>"},{"location":"tutorials/basic-single-service/#prerequisites","title":"Prerequisites","text":"<ul> <li>python-dabmux installed (Installation Guide)</li> <li>Basic command-line knowledge</li> <li>An MPEG Layer II audio file (<code>.mp2</code>)</li> </ul>"},{"location":"tutorials/basic-single-service/#step-1-prepare-audio-file","title":"Step 1: Prepare Audio File","text":"<p>You need an MPEG Layer II audio file. If you don't have one, convert any audio file:</p> <pre><code># Install ffmpeg if needed\n# macOS: brew install ffmpeg\n# Linux: sudo apt install ffmpeg\n\n# Convert to MPEG Layer II\nffmpeg -i your_audio.wav -codec:a mp2 -b:a 128k -ar 48000 test_audio.mp2\n</code></pre> <p>Verify the file: <pre><code>ffprobe test_audio.mp2\n</code></pre></p> <p>Expected output should show: - Codec: mp2 (MPEG-1 Audio Layer II) - Bitrate: 128 kbps - Sample rate: 48000 Hz</p>"},{"location":"tutorials/basic-single-service/#step-2-create-configuration-file","title":"Step 2: Create Configuration File","text":"<p>Create a file named <code>single_service.yaml</code>:</p> <pre><code># Single Service DAB Configuration\n\nensemble:\n  id: '0xCE01'                    # Unique ensemble ID\n  ecc: '0xE1'                     # Extended Country Code (Germany)\n  transmission_mode: 'I'           # Mode I (standard)\n  label:\n    text: 'Test Ensemble'\n    short: 'Test'\n  lto_auto: true                  # Automatic local time offset\n\nsubchannels:\n  - uid: 'test_audio'             # Unique identifier\n    id: 0                         # Subchannel ID\n    type: 'audio'                 # DAB audio (MPEG Layer II)\n    bitrate: 128                  # Must match audio file\n    start_address: 0              # First subchannel starts at 0\n    protection:\n      level: 2                    # Moderate protection\n      shortform: true\n    input: 'file://test_audio.mp2'  # Path to your audio file\n\nservices:\n  - uid: 'test_radio'\n    id: '0x4001'                  # Service ID\n    label:\n      text: 'Test Radio'          # Station name (max 16 chars)\n      short: 'Test'               # Short name (max 8 chars)\n    pty: 1                        # Programme Type (1=News)\n    language: 9                   # Language code (9=English)\n\ncomponents:\n  - uid: 'test_component'\n    service_id: '0x4001'          # Links to service above\n    subchannel_id: 0              # Links to subchannel above\n    type: 0                       # Audio component\n</code></pre>"},{"location":"tutorials/basic-single-service/#step-3-test-configuration","title":"Step 3: Test Configuration","text":"<p>Before generating output, test that the configuration is valid:</p> <pre><code>python -m dabmux.cli -c single_service.yaml -o test.eti -n 1 -vvv\n</code></pre> <p>What this does: - <code>-c single_service.yaml</code>: Load configuration - <code>-o test.eti</code>: Output to file - <code>-n 1</code>: Generate just 1 frame (test) - <code>-vvv</code>: Verbose output for debugging</p> <p>Expected output: <pre><code>INFO: Loading configuration from single_service.yaml\nINFO: Created ensemble 'Test Ensemble' (0xCE01)\nINFO: Added service 'Test Radio' (0x4001)\nINFO: Added subchannel 0: audio, 128 kbps, protection level 2\nINFO: Starting multiplexer\nINFO: Generated 1 frame(s)\nINFO: Multiplexing complete\n</code></pre></p>"},{"location":"tutorials/basic-single-service/#step-4-generate-eti-frames","title":"Step 4: Generate ETI Frames","text":"<p>Now generate a meaningful amount of frames:</p> <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti -n 1000\n</code></pre> <p>Frame calculation: - Mode I: 96 ms per frame - 1000 frames = 96 seconds \u2248 1.6 minutes of audio</p> <p>Expected output: <pre><code>INFO: Loading configuration from single_service.yaml\nINFO: Starting multiplexer\nINFO: Generated 1000 frame(s)\nINFO: Output written to output.eti\n</code></pre></p>"},{"location":"tutorials/basic-single-service/#step-5-verify-output","title":"Step 5: Verify Output","text":"<p>Check the generated ETI file:</p> <pre><code># Check file size\nls -lh output.eti\n\n# Expected size: ~6 MB (6000 bytes per frame \u00d7 1000 frames)\n</code></pre> <p>Examine the file: <pre><code># View first 64 bytes (should show ETI sync pattern)\nhexdump -C output.eti | head -4\n</code></pre></p> <p>Expected output: <pre><code>00000000  00 07 3a b6 c8 14 00 00  00 00 05 40 e3 8f ff ff  |..:........@....|\n          \u2514\u2500SYNC\u2500\u2518 \u2514\u2500\u2500\u2500FC\u2500\u2500\u2518 \u2514\u2500\u2500\u2500STC\u2500\u2500\u2518 \u2514\u2500\u2500EOH\u2500\u2518\n</code></pre></p> <p>The first 4 bytes should be: <code>00 07 3A B6</code> (ETI sync pattern)</p>"},{"location":"tutorials/basic-single-service/#step-6-generate-more-frames","title":"Step 6: Generate More Frames","text":"<p>For longer content, generate more frames:</p> <pre><code># Generate 10 minutes of audio (Mode I)\n# 10 minutes = 600 seconds \u2248 6250 frames\npython -m dabmux.cli -c single_service.yaml -o output_10min.eti -n 6250\n</code></pre> <p>File size calculation: <pre><code>Frame size: ~6000 bytes\n6250 frames \u00d7 6000 bytes = 37.5 MB\n</code></pre></p>"},{"location":"tutorials/basic-single-service/#step-7-experiment-with-settings","title":"Step 7: Experiment with Settings","text":""},{"location":"tutorials/basic-single-service/#change-station-name","title":"Change Station Name","text":"<p>Edit <code>single_service.yaml</code>: <pre><code>services:\n  - uid: 'test_radio'\n    id: '0x4001'\n    label:\n      text: 'My Cool Radio'    # Changed!\n      short: 'MyCool'           # Changed!\n</code></pre></p> <p>Regenerate: <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti -n 100\n</code></pre></p>"},{"location":"tutorials/basic-single-service/#change-bitrate","title":"Change Bitrate","text":"<p>Edit subchannel bitrate: <pre><code>subchannels:\n  - uid: 'test_audio'\n    bitrate: 192                # Higher quality (was 128)\n</code></pre></p> <p>Important: Make sure your audio file matches the new bitrate, or convert it: <pre><code>ffmpeg -i test_audio.mp2 -codec:a mp2 -b:a 192k -ar 48000 test_audio_192.mp2\n</code></pre></p> <p>Update input path: <pre><code>    input: 'file://test_audio_192.mp2'\n</code></pre></p>"},{"location":"tutorials/basic-single-service/#change-protection-level","title":"Change Protection Level","text":"<p>Edit protection: <pre><code>subchannels:\n  - uid: 'test_audio'\n    protection:\n      level: 3                  # Stronger (was 2)\n</code></pre></p> <p>Higher protection = more robust but uses more capacity.</p>"},{"location":"tutorials/basic-single-service/#testing-different-scenarios","title":"Testing Different Scenarios","text":""},{"location":"tutorials/basic-single-service/#continuous-operation","title":"Continuous Operation","text":"<p>Loop the input file continuously: <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti --continuous\n</code></pre></p> <p>Press <code>Ctrl+C</code> to stop.</p>"},{"location":"tutorials/basic-single-service/#different-output-formats","title":"Different Output Formats","text":"<p>Raw ETI: <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti -f raw -n 1000\n</code></pre></p> <p>Framed ETI (default, easiest to parse): <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti -f framed -n 1000\n</code></pre></p> <p>Streamed ETI (with timestamps): <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti -f streamed --tist -n 1000\n</code></pre></p>"},{"location":"tutorials/basic-single-service/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/basic-single-service/#error-input-file-not-found","title":"Error: Input file not found","text":"<pre><code>ERROR: Input file not found: test_audio.mp2\n</code></pre> <p>Solution: - Check the file exists: <code>ls test_audio.mp2</code> - Use absolute path: <code>input: 'file:///full/path/to/test_audio.mp2'</code></p>"},{"location":"tutorials/basic-single-service/#error-invalid-mpeg-frame-header","title":"Error: Invalid MPEG frame header","text":"<pre><code>ERROR: Invalid MPEG frame header\n</code></pre> <p>Solution: - Verify file format: <code>ffprobe test_audio.mp2</code> - Re-encode: <code>ffmpeg -i source.wav -codec:a mp2 -b:a 128k test_audio.mp2</code></p>"},{"location":"tutorials/basic-single-service/#error-configuration-parse-error","title":"Error: Configuration parse error","text":"<pre><code>ERROR: YAML parse error\n</code></pre> <p>Solution: - Check indentation (use spaces, not tabs) - Verify hex values are quoted: <code>id: '0xCE01'</code> - Check colons have spaces after them</p>"},{"location":"tutorials/basic-single-service/#file-size-smaller-than-expected","title":"File size smaller than expected","text":"<p>Problem: Generated file is too small</p> <p>Solution: - Check if input audio file is long enough - Input file loops when it reaches the end - Use <code>--continuous</code> flag for infinite looping</p>"},{"location":"tutorials/basic-single-service/#understanding-what-happened","title":"Understanding What Happened","text":"<p>Let's review what python-dabmux did:</p> <ol> <li>Loaded configuration: Parsed <code>single_service.yaml</code></li> <li>Created ensemble: Set up \"Test Ensemble\" with ID 0xCE01</li> <li>Added service: Created \"Test Radio\" service</li> <li>Configured subchannel: Allocated 128 kbps audio stream</li> <li>Opened input: Connected to <code>test_audio.mp2</code></li> <li>Generated FIGs: Created metadata (ensemble info, service labels, etc.)</li> <li>Multiplexed frames: For each frame:</li> <li>Read audio data from input</li> <li>Generated FIGs</li> <li>Assembled ETI frame (headers, FIC, MST, CRC)</li> <li>Wrote to output file</li> <li>Closed files: Clean shutdown</li> </ol>"},{"location":"tutorials/basic-single-service/#next-steps","title":"Next Steps","text":"<p>Now that you have a working single-service multiplex:</p>"},{"location":"tutorials/basic-single-service/#add-more-services","title":"Add More Services","text":"<p>Continue to Multi-Service Ensemble Tutorial to learn how to add multiple radio stations.</p>"},{"location":"tutorials/basic-single-service/#try-dab","title":"Try DAB+","text":"<p>Continue to DAB+ Setup Tutorial for better quality at lower bitrates.</p>"},{"location":"tutorials/basic-single-service/#network-output","title":"Network Output","text":"<p>Continue to Network Streaming Tutorial to output EDI over the network.</p>"},{"location":"tutorials/basic-single-service/#learn-more","title":"Learn More","text":"<ul> <li>Configuration Reference: All configuration options</li> <li>CLI Reference: All command-line options</li> <li>Basic Concepts: DAB terminology</li> </ul>"},{"location":"tutorials/basic-single-service/#summary","title":"Summary","text":"<p>Congratulations! You've created your first DAB multiplex. You learned:</p> <ul> <li>\u2705 How to write a basic configuration file</li> <li>\u2705 Running python-dabmux from the command line</li> <li>\u2705 Generating ETI output files</li> <li>\u2705 Verifying the output</li> <li>\u2705 Experimenting with different settings</li> </ul> <p>This is the foundation for all DAB multiplexing with python-dabmux!</p>"},{"location":"tutorials/basic-single-service/#complete-configuration-reference","title":"Complete Configuration Reference","text":"<p>Here's the complete working configuration for reference:</p> <pre><code>ensemble:\n  id: '0xCE01'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Test Ensemble'\n    short: 'Test'\n  lto_auto: true\n\nsubchannels:\n  - uid: 'test_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://test_audio.mp2'\n\nservices:\n  - uid: 'test_radio'\n    id: '0x4001'\n    label:\n      text: 'Test Radio'\n      short: 'Test'\n    pty: 1\n    language: 9\n\ncomponents:\n  - uid: 'test_component'\n    service_id: '0x4001'\n    subchannel_id: 0\n    type: 0\n</code></pre> <p>Save this as <code>single_service.yaml</code> and you're ready to multiplex!</p>"},{"location":"tutorials/custom-inputs/","title":"Tutorial: Custom Inputs","text":"<p>Create custom input sources by extending python-dabmux's input classes.</p> <p>Difficulty: Advanced Time: 40 minutes</p>"},{"location":"tutorials/custom-inputs/#what-youll-build","title":"What You'll Build","text":"<p>A custom input class that: - Implements the InputBase interface - Generates synthetic audio data - Handles buffer management - Integrates with the multiplexer</p>"},{"location":"tutorials/custom-inputs/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python programming experience</li> <li>Completed Basic Single Service Tutorial</li> <li>Understanding of System Design</li> <li>Familiarity with python-dabmux codebase</li> </ul>"},{"location":"tutorials/custom-inputs/#why-create-custom-inputs","title":"Why Create Custom Inputs?","text":"<p>Use cases: - Integrate with custom audio sources - Generate test signals - Interface with hardware devices - Implement special buffering strategies - Add monitoring and statistics</p>"},{"location":"tutorials/custom-inputs/#step-1-understand-inputbase-interface","title":"Step 1: Understand InputBase Interface","text":""},{"location":"tutorials/custom-inputs/#read-the-inputbase-class","title":"Read the InputBase Class","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass InputBase(ABC):\n    \"\"\"Abstract base class for inputs.\"\"\"\n\n    @abstractmethod\n    def open(self) -&gt; None:\n        \"\"\"Open the input source.\"\"\"\n        pass\n\n    @abstractmethod\n    def read(self, size: int) -&gt; bytes:\n        \"\"\"\n        Read data from input.\n\n        Args:\n            size: Number of bytes to read\n\n        Returns:\n            bytes: Audio data (exactly size bytes)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def close(self) -&gt; None:\n        \"\"\"Close the input source.\"\"\"\n        pass\n\n    def get_stats(self) -&gt; dict:\n        \"\"\"Get input statistics (optional).\"\"\"\n        return {}\n</code></pre> <p>Required methods: - <code>open()</code>: Initialize input source - <code>read(size)</code>: Return exactly <code>size</code> bytes - <code>close()</code>: Clean up resources</p> <p>Optional methods: - <code>get_stats()</code>: Return statistics</p>"},{"location":"tutorials/custom-inputs/#step-2-create-sine-wave-generator","title":"Step 2: Create Sine Wave Generator","text":"<p>Create a custom input that generates a sine wave test signal.</p>"},{"location":"tutorials/custom-inputs/#create-the-class","title":"Create the Class","text":"<p>Create <code>custom_sine_input.py</code>:</p> <pre><code>import math\nimport struct\nfrom dabmux.input.base import InputBase\n\n\nclass SineWaveInput(InputBase):\n    \"\"\"\n    Custom input that generates a sine wave test signal.\n\n    Generates stereo 16-bit PCM at 48 kHz, then encodes to MPEG Layer II format.\n    \"\"\"\n\n    def __init__(self, frequency: float = 1000.0):\n        \"\"\"\n        Initialize sine wave generator.\n\n        Args:\n            frequency: Sine wave frequency in Hz (default: 1000 Hz)\n        \"\"\"\n        self.frequency = frequency\n        self.sample_rate = 48000  # DAB standard\n        self.phase = 0.0\n        self.bytes_read = 0\n\n    def open(self) -&gt; None:\n        \"\"\"Open the input (initialize state).\"\"\"\n        self.phase = 0.0\n        self.bytes_read = 0\n        print(f\"SineWaveInput: Opened with {self.frequency} Hz\")\n\n    def read(self, size: int) -&gt; bytes:\n        \"\"\"\n        Generate sine wave audio data.\n\n        Args:\n            size: Number of bytes to read\n\n        Returns:\n            bytes: Generated audio data\n        \"\"\"\n        # Calculate number of samples needed\n        # Each sample: 4 bytes (2 bytes/channel \u00d7 2 channels)\n        num_samples = size // 4\n\n        data = bytearray()\n\n        for _ in range(num_samples):\n            # Generate sine wave sample\n            sample_value = math.sin(2.0 * math.pi * self.frequency * self.phase / self.sample_rate)\n\n            # Convert to 16-bit integer (-32768 to 32767)\n            sample_int = int(sample_value * 32767.0)\n\n            # Clamp to 16-bit range\n            sample_int = max(-32768, min(32767, sample_int))\n\n            # Pack as stereo (same value for both channels)\n            # Little-endian signed 16-bit\n            data.extend(struct.pack('&lt;h', sample_int))  # Left channel\n            data.extend(struct.pack('&lt;h', sample_int))  # Right channel\n\n            self.phase += 1\n\n        self.bytes_read += len(data)\n\n        # Pad if needed\n        while len(data) &lt; size:\n            data.append(0)\n\n        return bytes(data[:size])\n\n    def close(self) -&gt; None:\n        \"\"\"Close the input.\"\"\"\n        print(f\"SineWaveInput: Closed (generated {self.bytes_read} bytes)\")\n\n    def get_stats(self) -&gt; dict:\n        \"\"\"Get input statistics.\"\"\"\n        return {\n            'frequency': self.frequency,\n            'bytes_generated': self.bytes_read,\n            'phase': self.phase\n        }\n</code></pre>"},{"location":"tutorials/custom-inputs/#register-the-custom-input","title":"Register the Custom Input","text":"<p>Modify python-dabmux to recognize your custom input URI:</p> <p>Edit <code>src/dabmux/input/__init__.py</code>:</p> <pre><code>from dabmux.input.base import InputBase\nfrom dabmux.input.file import FileInput\nfrom dabmux.input.udp import UDPInput\nfrom dabmux.input.tcp import TCPInput\nfrom custom_sine_input import SineWaveInput  # Add this\n\n\ndef create_input(uri: str) -&gt; InputBase:\n    \"\"\"\n    Create input from URI.\n\n    Args:\n        uri: Input URI (file://, udp://, tcp://, sine://)\n\n    Returns:\n        InputBase: Input instance\n    \"\"\"\n    if uri.startswith('file://'):\n        path = uri[7:]\n        return FileInput(path)\n    elif uri.startswith('udp://'):\n        # Parse udp://host:port\n        parts = uri[6:].split(':')\n        host = parts[0]\n        port = int(parts[1])\n        return UDPInput(host, port)\n    elif uri.startswith('tcp://'):\n        # Parse tcp://host:port\n        parts = uri[6:].split(':')\n        host = parts[0]\n        port = int(parts[1])\n        return TCPInput(host, port)\n    elif uri.startswith('sine://'):\n        # Parse sine://frequency\n        freq = float(uri[7:]) if len(uri) &gt; 7 else 1000.0\n        return SineWaveInput(frequency=freq)\n    else:\n        raise ValueError(f\"Unknown input URI: {uri}\")\n</code></pre>"},{"location":"tutorials/custom-inputs/#step-3-use-custom-input","title":"Step 3: Use Custom Input","text":""},{"location":"tutorials/custom-inputs/#configuration","title":"Configuration","text":"<p>Create <code>sine_test.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xCE40'\n  label:\n    text: 'Sine Test'\n\nsubchannels:\n  - uid: 'sine_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    input: 'sine://440'  # 440 Hz sine wave (A4 note)\n\nservices:\n  - uid: 'sine_service'\n    id: '0x9001'\n    label:\n      text: 'Test Tone'\n\ncomponents:\n  - uid: 'sine_comp'\n    service_id: '0x9001'\n    subchannel_id: 0\n</code></pre>"},{"location":"tutorials/custom-inputs/#run-multiplexer","title":"Run Multiplexer","text":"<pre><code>python -m dabmux.cli -c sine_test.yaml -o sine_test.eti -n 1000\n</code></pre> <p>The multiplexer will use your custom input to generate a test tone!</p>"},{"location":"tutorials/custom-inputs/#step-4-add-buffer-management","title":"Step 4: Add Buffer Management","text":"<p>Enhance with buffering:</p> <pre><code>from collections import deque\nfrom threading import Thread, Lock\n\n\nclass BufferedSineInput(SineWaveInput):\n    \"\"\"Sine wave input with buffering.\"\"\"\n\n    def __init__(self, frequency: float = 1000.0, buffer_size: int = 10):\n        super().__init__(frequency)\n        self.buffer_size = buffer_size\n        self.buffer = deque(maxlen=buffer_size)\n        self.lock = Lock()\n        self.running = False\n        self.thread = None\n\n    def open(self) -&gt; None:\n        \"\"\"Open input and start buffer thread.\"\"\"\n        super().open()\n        self.running = True\n        self.thread = Thread(target=self._fill_buffer)\n        self.thread.start()\n\n    def _fill_buffer(self) -&gt; None:\n        \"\"\"Background thread to fill buffer.\"\"\"\n        while self.running:\n            with self.lock:\n                if len(self.buffer) &lt; self.buffer_size:\n                    # Generate frame worth of data\n                    data = super().read(4096)\n                    self.buffer.append(data)\n\n    def read(self, size: int) -&gt; bytes:\n        \"\"\"Read from buffer.\"\"\"\n        with self.lock:\n            if not self.buffer:\n                # Buffer empty - generate directly\n                return super().read(size)\n\n            # Get from buffer\n            data = self.buffer.popleft()\n            return data[:size] + b'\\x00' * max(0, size - len(data))\n\n    def close(self) -&gt; None:\n        \"\"\"Stop buffer thread and close.\"\"\"\n        self.running = False\n        if self.thread:\n            self.thread.join()\n        super().close()\n\n    def get_stats(self) -&gt; dict:\n        \"\"\"Get statistics including buffer status.\"\"\"\n        stats = super().get_stats()\n        with self.lock:\n            stats['buffer_fill'] = len(self.buffer)\n            stats['buffer_size'] = self.buffer_size\n        return stats\n</code></pre>"},{"location":"tutorials/custom-inputs/#step-5-real-world-example-http-stream-input","title":"Step 5: Real-World Example - HTTP Stream Input","text":"<p>Create an input that fetches audio from an HTTP stream:</p> <pre><code>import requests\nfrom dabmux.input.base import InputBase\n\n\nclass HTTPStreamInput(InputBase):\n    \"\"\"Input that reads from HTTP audio stream.\"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n        self.response = None\n        self.iterator = None\n        self.buffer = b''\n\n    def open(self) -&gt; None:\n        \"\"\"Connect to HTTP stream.\"\"\"\n        self.response = requests.get(self.url, stream=True)\n        self.iterator = self.response.iter_content(chunk_size=4096)\n        print(f\"HTTPStreamInput: Connected to {self.url}\")\n\n    def read(self, size: int) -&gt; bytes:\n        \"\"\"Read from HTTP stream.\"\"\"\n        # Fill buffer until we have enough data\n        while len(self.buffer) &lt; size:\n            try:\n                chunk = next(self.iterator)\n                self.buffer += chunk\n            except StopIteration:\n                # Stream ended\n                break\n\n        # Return requested size\n        data = self.buffer[:size]\n        self.buffer = self.buffer[size:]\n\n        # Pad if needed\n        if len(data) &lt; size:\n            data += b'\\x00' * (size - len(data))\n\n        return data\n\n    def close(self) -&gt; None:\n        \"\"\"Close HTTP connection.\"\"\"\n        if self.response:\n            self.response.close()\n        print(\"HTTPStreamInput: Closed\")\n</code></pre> <p>Usage: <pre><code>input: 'http://stream.example.com/audio.mp2'\n</code></pre></p>"},{"location":"tutorials/custom-inputs/#step-6-testing-custom-inputs","title":"Step 6: Testing Custom Inputs","text":""},{"location":"tutorials/custom-inputs/#unit-tests","title":"Unit Tests","text":"<p>Create <code>test_custom_input.py</code>:</p> <pre><code>import unittest\nfrom custom_sine_input import SineWaveInput\n\n\nclass TestSineWaveInput(unittest.TestCase):\n    def test_open_close(self):\n        \"\"\"Test opening and closing input.\"\"\"\n        inp = SineWaveInput(frequency=1000.0)\n        inp.open()\n        inp.close()\n\n    def test_read_size(self):\n        \"\"\"Test reading returns correct size.\"\"\"\n        inp = SineWaveInput()\n        inp.open()\n\n        data = inp.read(4096)\n        self.assertEqual(len(data), 4096)\n\n        inp.close()\n\n    def test_continuous_read(self):\n        \"\"\"Test reading multiple times.\"\"\"\n        inp = SineWaveInput()\n        inp.open()\n\n        for _ in range(10):\n            data = inp.read(1000)\n            self.assertEqual(len(data), 1000)\n\n        inp.close()\n\n    def test_statistics(self):\n        \"\"\"Test statistics reporting.\"\"\"\n        inp = SineWaveInput()\n        inp.open()\n\n        inp.read(4096)\n        stats = inp.get_stats()\n\n        self.assertIn('frequency', stats)\n        self.assertIn('bytes_generated', stats)\n        self.assertGreater(stats['bytes_generated'], 0)\n\n        inp.close()\n\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <p>Run tests: <pre><code>python test_custom_input.py\n</code></pre></p>"},{"location":"tutorials/custom-inputs/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/custom-inputs/#always-return-exact-size","title":"Always Return Exact Size","text":"<pre><code>def read(self, size: int) -&gt; bytes:\n    data = self._generate_data()\n\n    # Ensure exact size\n    if len(data) &lt; size:\n        data += b'\\x00' * (size - len(data))  # Pad\n    elif len(data) &gt; size:\n        data = data[:size]  # Truncate\n\n    return data\n</code></pre>"},{"location":"tutorials/custom-inputs/#handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<pre><code>def read(self, size: int) -&gt; bytes:\n    try:\n        return self._read_internal(size)\n    except Exception as e:\n        print(f\"Input error: {e}\")\n        # Return silence instead of crashing\n        return b'\\x00' * size\n</code></pre>"},{"location":"tutorials/custom-inputs/#provide-meaningful-statistics","title":"Provide Meaningful Statistics","text":"<pre><code>def get_stats(self) -&gt; dict:\n    return {\n        'input_type': 'custom',\n        'bytes_read': self.total_bytes,\n        'underruns': self.underrun_count,\n        'last_error': self.last_error\n    }\n</code></pre>"},{"location":"tutorials/custom-inputs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/custom-inputs/#input-not-recognized","title":"Input not recognized","text":"<p>Error: <pre><code>ERROR: Unknown input URI: sine://440\n</code></pre></p> <p>Solution: Ensure you modified the input factory to register your custom input.</p>"},{"location":"tutorials/custom-inputs/#wrong-data-size-returned","title":"Wrong data size returned","text":"<p>Error: <pre><code>ERROR: Input returned wrong size\n</code></pre></p> <p>Solution: Always return exactly <code>size</code> bytes, pad with zeros if needed.</p>"},{"location":"tutorials/custom-inputs/#memory-leak","title":"Memory leak","text":"<p>Problem: Memory usage grows over time</p> <p>Solution: Clean up resources in <code>close()</code>, avoid circular references.</p>"},{"location":"tutorials/custom-inputs/#next-steps","title":"Next Steps","text":""},{"location":"tutorials/custom-inputs/#extend-further","title":"Extend Further","text":"<p>Ideas for custom inputs: - Database audio sources - Algorithmically generated music - Hardware audio interfaces - Cloud storage (S3, etc.) - Message queue inputs</p>"},{"location":"tutorials/custom-inputs/#contribute","title":"Contribute","text":"<p>Consider contributing your custom input to python-dabmux!</p> <p>See Contributing Guide.</p>"},{"location":"tutorials/custom-inputs/#summary","title":"Summary","text":"<p>You've learned to create custom inputs:</p> <ul> <li>\u2705 Understanding InputBase interface</li> <li>\u2705 Implementing required methods</li> <li>\u2705 Buffer management</li> <li>\u2705 Error handling</li> <li>\u2705 Testing and debugging</li> </ul> <p>Custom inputs extend python-dabmux for any audio source!</p>"},{"location":"tutorials/custom-inputs/#complete-example","title":"Complete Example","text":"<pre><code>from dabmux.input.base import InputBase\n\nclass MyCustomInput(InputBase):\n    def __init__(self, config: str):\n        self.config = config\n\n    def open(self) -&gt; None:\n        # Initialize your source\n        pass\n\n    def read(self, size: int) -&gt; bytes:\n        # Generate/fetch audio data\n        data = self._get_audio()\n\n        # Ensure exact size\n        if len(data) &lt; size:\n            data += b'\\x00' * (size - len(data))\n\n        return data[:size]\n\n    def close(self) -&gt; None:\n        # Clean up resources\n        pass\n\n    def get_stats(self) -&gt; dict:\n        return {\n            'input_type': 'custom',\n            'config': self.config\n        }\n</code></pre>"},{"location":"tutorials/dab-plus-setup/","title":"Tutorial: DAB+ Setup","text":"<p>Set up DAB+ (HE-AAC v2) services for more efficient broadcasting with better quality at lower bitrates.</p> <p>Difficulty: Intermediate Time: 20 minutes</p>"},{"location":"tutorials/dab-plus-setup/#what-youll-build","title":"What You'll Build","text":"<p>A DAB+ service that demonstrates: - HE-AAC v2 audio encoding - Optimal bitrate selection - Quality comparison with DAB - Capacity savings</p>"},{"location":"tutorials/dab-plus-setup/#why-use-dab","title":"Why Use DAB+?","text":"<p>DAB+ advantages: - Better quality at low bitrates: 48-72 kbps DAB+ \u2248 128 kbps DAB - More services: Fit more stations in same bandwidth - Modern codec: HE-AAC v2 is optimized for music and speech</p> <p>When to use DAB: - Very high bitrates (192+ kbps) where MPEG Layer II excels - Compatibility with older receivers (pre-2010)</p>"},{"location":"tutorials/dab-plus-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>python-dabmux installed</li> <li>ffmpeg with libfdk-aac support</li> <li>Understanding of Basic Concepts</li> </ul>"},{"location":"tutorials/dab-plus-setup/#step-1-install-ffmpeg-with-fdk-aac","title":"Step 1: Install FFmpeg with FDK-AAC","text":""},{"location":"tutorials/dab-plus-setup/#macos","title":"macOS","text":"<pre><code>brew install ffmpeg --with-fdk-aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt install ffmpeg libfdk-aac2\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#verify-installation","title":"Verify Installation","text":"<pre><code>ffmpeg -codecs | grep libfdk_aac\n</code></pre> <p>Should show: <code>libfdk_aac</code> in the output.</p>"},{"location":"tutorials/dab-plus-setup/#step-2-encode-audio-to-he-aac","title":"Step 2: Encode Audio to HE-AAC","text":"<p>Create DAB+ audio files at different bitrates:</p>"},{"location":"tutorials/dab-plus-setup/#music-content-72-kbps-recommended","title":"Music Content (72 kbps recommended)","text":"<pre><code>ffmpeg -i music.wav \\\n  -codec:a libfdk_aac \\\n  -profile:a aac_he_v2 \\\n  -b:a 72k \\\n  -ar 48000 \\\n  music_dabplus_72.aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#speechtalk-content-48-kbps-recommended","title":"Speech/Talk Content (48 kbps recommended)","text":"<pre><code>ffmpeg -i speech.wav \\\n  -codec:a libfdk_aac \\\n  -profile:a aac_he_v2 \\\n  -b:a 48k \\\n  -ar 48000 \\\n  speech_dabplus_48.aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#high-quality-music-96-kbps","title":"High-Quality Music (96 kbps)","text":"<pre><code>ffmpeg -i premium.wav \\\n  -codec:a libfdk_aac \\\n  -profile:a aac_he_v2 \\\n  -b:a 96k \\\n  -ar 48000 \\\n  premium_dabplus_96.aac\n</code></pre> <p>Profile options: - <code>aac_he_v2</code>: HE-AAC v2 (best for DAB+) - <code>aac_he</code>: HE-AAC v1 (also works) - <code>aac_low</code>: AAC-LC (less efficient)</p>"},{"location":"tutorials/dab-plus-setup/#step-3-create-dab-configuration","title":"Step 3: Create DAB+ Configuration","text":"<p>Create <code>dabplus_config.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xDA8F'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'DAB+ Demo'\n    short: 'DABplus'\n  lto_auto: true\n\nsubchannels:\n  # Music service - 72 kbps\n  - uid: 'music_dabplus'\n    id: 0\n    type: 'dabplus'           # DAB+ type\n    bitrate: 72\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://music_dabplus_72.aac'\n\n  # Speech service - 48 kbps\n  - uid: 'speech_dabplus'\n    id: 1\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 100\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://speech_dabplus_48.aac'\n\nservices:\n  - uid: 'music_service'\n    id: '0x6001'\n    label:\n      text: 'Music Plus'\n      short: 'Music+'\n    pty: 10\n    language: 9\n\n  - uid: 'speech_service'\n    id: '0x6002'\n    label:\n      text: 'Talk Plus'\n      short: 'Talk+'\n    pty: 1\n    language: 9\n\ncomponents:\n  - uid: 'music_comp'\n    service_id: '0x6001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'speech_comp'\n    service_id: '0x6002'\n    subchannel_id: 1\n    type: 0\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#step-4-test-dab-output","title":"Step 4: Test DAB+ Output","text":"<p>Generate ETI frames:</p> <pre><code>python -m dabmux.cli -c dabplus_config.yaml -o dabplus.eti -n 1000\n</code></pre> <p>Verify both services multiplex correctly.</p>"},{"location":"tutorials/dab-plus-setup/#step-5-compare-dab-vs-dab","title":"Step 5: Compare DAB vs DAB+","text":"<p>Create comparison configs to see the difference.</p>"},{"location":"tutorials/dab-plus-setup/#dab-configuration-mpeg-layer-ii","title":"DAB Configuration (MPEG Layer II)","text":"<pre><code>subchannels:\n  - uid: 'music_dab'\n    type: 'audio'             # DAB (MPEG)\n    bitrate: 128              # Need 128 kbps for good quality\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#dab-configuration-he-aac-v2","title":"DAB+ Configuration (HE-AAC v2)","text":"<pre><code>subchannels:\n  - uid: 'music_dabplus'\n    type: 'dabplus'           # DAB+\n    bitrate: 72               # Only 72 kbps for similar quality!\n</code></pre> <p>Capacity savings: 128 - 72 = 56 kbps saved per service!</p>"},{"location":"tutorials/dab-plus-setup/#bitrate-recommendations","title":"Bitrate Recommendations","text":""},{"location":"tutorials/dab-plus-setup/#music-content","title":"Music Content","text":"Quality DAB (MPEG Layer II) DAB+ (HE-AAC v2) Acceptable 96 kbps 48 kbps Good 128 kbps 64 kbps Very Good 160 kbps 72 kbps Excellent 192 kbps 80-96 kbps Premium 256 kbps 96-128 kbps"},{"location":"tutorials/dab-plus-setup/#speechtalk-content","title":"Speech/Talk Content","text":"Quality DAB DAB+ Acceptable 64 kbps 32 kbps Good 80 kbps 40 kbps Very Good 96 kbps 48 kbps Excellent 128 kbps 56-64 kbps <p>Recommendation: Use 48 kbps DAB+ for speech, 72 kbps DAB+ for music.</p>"},{"location":"tutorials/dab-plus-setup/#step-6-build-efficient-ensemble","title":"Step 6: Build Efficient Ensemble","text":"<p>Create an ensemble with 6 services using DAB+:</p> <pre><code>ensemble:\n  id: '0xDA8F'\n  label:\n    text: 'Efficient DAB+'\n\nsubchannels:\n  # 3 music services @ 72 kbps = 216 kbps\n  - {uid: music1, id: 0, type: dabplus, bitrate: 72, start_address: 0, input: 'file://music1.aac'}\n  - {uid: music2, id: 1, type: dabplus, bitrate: 72, start_address: 100, input: 'file://music2.aac'}\n  - {uid: music3, id: 2, type: dabplus, bitrate: 72, start_address: 200, input: 'file://music3.aac'}\n\n  # 3 talk services @ 48 kbps = 144 kbps\n  - {uid: talk1, id: 3, type: dabplus, bitrate: 48, start_address: 300, input: 'file://talk1.aac'}\n  - {uid: talk2, id: 4, type: dabplus, bitrate: 48, start_address: 400, input: 'file://talk2.aac'}\n  - {uid: talk3, id: 5, type: dabplus, bitrate: 48, start_address: 500, input: 'file://talk3.aac'}\n\n# Total: 360 kbps for 6 services\n# With DAB, would need ~720 kbps for similar quality!\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#encoding-best-practices","title":"Encoding Best Practices","text":""},{"location":"tutorials/dab-plus-setup/#sample-rate","title":"Sample Rate","text":"<p>Always use 48 kHz for DAB+:</p> <pre><code>ffmpeg -i input.wav -codec:a libfdk_aac -profile:a aac_he_v2 -b:a 72k -ar 48000 output.aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#stereo-vs-mono","title":"Stereo vs Mono","text":"<p>For speech, consider mono to save bitrate:</p> <pre><code># Stereo (default)\nffmpeg -i input.wav -codec:a libfdk_aac -b:a 48k output_stereo.aac\n\n# Mono (half the bitrate)\nffmpeg -i input.wav -codec:a libfdk_aac -b:a 24k -ac 1 output_mono.aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#vbr-vs-cbr","title":"VBR vs CBR","text":"<p>Use CBR (Constant Bitrate) for DAB:</p> <pre><code>ffmpeg -i input.wav -codec:a libfdk_aac -profile:a aac_he_v2 -b:a 72k output.aac\n</code></pre> <p>DAB requires constant bitrate for multiplexing.</p>"},{"location":"tutorials/dab-plus-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/dab-plus-setup/#ffmpeg-doesnt-have-libfdk-aac","title":"FFmpeg doesn't have libfdk-aac","text":"<p>Error: <pre><code>Unknown encoder 'libfdk_aac'\n</code></pre></p> <p>Solution: Install FFmpeg with FDK-AAC support or use alternative:</p> <pre><code># Alternative: use native AAC encoder (lower quality)\nffmpeg -i input.wav -codec:a aac -b:a 72k -profile:a aac_he_v2 output.aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#audio-quality-issues","title":"Audio quality issues","text":"<p>Problem: DAB+ audio sounds poor</p> <p>Solutions: 1. Increase bitrate (try 80 or 96 kbps) 2. Check source audio quality 3. Use HE-AAC v2 profile: <code>-profile:a aac_he_v2</code> 4. Ensure sample rate is 48 kHz</p>"},{"location":"tutorials/dab-plus-setup/#type-mismatch-error","title":"Type mismatch error","text":"<p>Error: <pre><code>ERROR: Expected DAB+ superframe, got MPEG frame\n</code></pre></p> <p>Solution: Check <code>type</code> in config matches audio format: - <code>.aac</code> files \u2192 <code>type: 'dabplus'</code> - <code>.mp2</code> files \u2192 <code>type: 'audio'</code></p>"},{"location":"tutorials/dab-plus-setup/#next-steps","title":"Next Steps","text":""},{"location":"tutorials/dab-plus-setup/#add-network-inputs","title":"Add Network Inputs","text":"<p>Continue to Network Streaming Tutorial to stream DAB+ over the network.</p>"},{"location":"tutorials/dab-plus-setup/#mix-dab-and-dab","title":"Mix DAB and DAB+","text":"<p>See Multi-Service Ensemble Tutorial for mixing both types.</p>"},{"location":"tutorials/dab-plus-setup/#deploy-to-production","title":"Deploy to Production","text":"<p>Read User Guide for production deployment best practices.</p>"},{"location":"tutorials/dab-plus-setup/#summary","title":"Summary","text":"<p>You've learned DAB+ setup including:</p> <ul> <li>\u2705 Encoding audio to HE-AAC v2</li> <li>\u2705 Configuring DAB+ services</li> <li>\u2705 Optimal bitrate selection</li> <li>\u2705 Capacity management</li> <li>\u2705 Quality comparison with DAB</li> </ul> <p>DAB+ enables more services with better quality at lower bitrates!</p>"},{"location":"tutorials/dab-plus-setup/#quick-reference","title":"Quick Reference","text":""},{"location":"tutorials/dab-plus-setup/#encoding-commands","title":"Encoding Commands","text":"<pre><code># Music (72 kbps)\nffmpeg -i music.wav -codec:a libfdk_aac -profile:a aac_he_v2 -b:a 72k -ar 48000 music.aac\n\n# Speech (48 kbps)\nffmpeg -i speech.wav -codec:a libfdk_aac -profile:a aac_he_v2 -b:a 48k -ar 48000 speech.aac\n\n# Premium (96 kbps)\nffmpeg -i premium.wav -codec:a libfdk_aac -profile:a aac_he_v2 -b:a 96k -ar 48000 premium.aac\n</code></pre>"},{"location":"tutorials/dab-plus-setup/#configuration-template","title":"Configuration Template","text":"<pre><code>subchannels:\n  - uid: 'dabplus_service'\n    type: 'dabplus'           # Key: use 'dabplus' not 'audio'\n    bitrate: 72               # Recommended for music\n    input: 'file://audio.aac' # HE-AAC file\n</code></pre>"},{"location":"tutorials/multi-service-ensemble/","title":"Tutorial: Multi-Service Ensemble","text":"<p>Build a complete DAB ensemble with multiple radio stations, mixing DAB and DAB+ services.</p> <p>Difficulty: Intermediate Time: 25 minutes</p>"},{"location":"tutorials/multi-service-ensemble/#what-youll-build","title":"What You'll Build","text":"<p>A DAB ensemble with: - 4 radio stations - Mix of DAB (MPEG Layer II) and DAB+ (HE-AAC) - Different bitrates optimized for content type - Proper capacity allocation</p>"},{"location":"tutorials/multi-service-ensemble/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Basic Single Service Tutorial</li> <li>Multiple audio files (or reuse one file for testing)</li> <li>Understanding of Basic Concepts</li> </ul>"},{"location":"tutorials/multi-service-ensemble/#step-1-plan-your-ensemble","title":"Step 1: Plan Your Ensemble","text":"<p>Let's design a realistic DAB ensemble:</p> Station Type Bitrate Content Protection Music FM DAB 192 kbps Music (high quality) Level 3 News 24 DAB+ 64 kbps Speech/News Level 2 Pop Hits DAB+ 80 kbps Music Level 2 Classical DAB+ 96 kbps Classical music Level 3 <p>Total capacity needed: ~432 kbps (Mode I has ~864 CUs available)</p>"},{"location":"tutorials/multi-service-ensemble/#step-2-prepare-audio-files","title":"Step 2: Prepare Audio Files","text":"<p>Create or prepare 4 audio files:</p> <pre><code># Music station: High-quality MPEG Layer II\nffmpeg -i music.wav -codec:a mp2 -b:a 192k -ar 48000 music_192.mp2\n\n# News station: HE-AAC for speech\nffmpeg -i news.wav -codec:a libfdk_aac -profile:a aac_he -b:a 64k -ar 48000 news_64.aac\n\n# Pop station: HE-AAC\nffmpeg -i pop.wav -codec:a libfdk_aac -profile:a aac_he -b:a 80k -ar 48000 pop_80.aac\n\n# Classical station: HE-AAC\nffmpeg -i classical.wav -codec:a libfdk_aac -profile:a aac_he -b:a 96k -ar 48000 classical_96.aac\n</code></pre> <p>Testing tip: For testing, you can use the same audio file for all services. Just copy it: <pre><code>cp music_192.mp2 station1.mp2\ncp music_192.mp2 station2.mp2\n# etc.\n</code></pre></p>"},{"location":"tutorials/multi-service-ensemble/#step-3-create-configuration","title":"Step 3: Create Configuration","text":"<p>Create <code>multi_service.yaml</code>:</p> <pre><code># Multi-Service DAB Ensemble Configuration\n\nensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Multi DAB'\n    short: 'MultiDAB'\n  lto_auto: true\n\n# Subchannels - the actual audio streams\nsubchannels:\n  # Subchannel 0: Music FM (high-quality DAB)\n  - uid: 'music_audio'\n    id: 0\n    type: 'audio'              # DAB (MPEG Layer II)\n    bitrate: 192\n    start_address: 0           # First subchannel\n    protection:\n      level: 3                 # Higher protection for premium content\n      shortform: true\n    input: 'file://music_192.mp2'\n\n  # Subchannel 1: News 24 (speech-optimized DAB+)\n  - uid: 'news_audio'\n    id: 1\n    type: 'dabplus'            # DAB+ (HE-AAC)\n    bitrate: 64\n    start_address: 200         # After music channel\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://news_64.aac'\n\n  # Subchannel 2: Pop Hits (DAB+)\n  - uid: 'pop_audio'\n    id: 2\n    type: 'dabplus'\n    bitrate: 80\n    start_address: 300\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://pop_80.aac'\n\n  # Subchannel 3: Classical (higher-quality DAB+)\n  - uid: 'classical_audio'\n    id: 3\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 400\n    protection:\n      level: 3\n      shortform: true\n    input: 'file://classical_96.aac'\n\n# Services - the radio stations listeners see\nservices:\n  # Service 1: Music FM\n  - uid: 'music_service'\n    id: '0x5001'\n    label:\n      text: 'Music FM'\n      short: 'MusicFM'\n    pty: 10                    # Pop Music\n    language: 9                # English\n\n  # Service 2: News 24\n  - uid: 'news_service'\n    id: '0x5002'\n    label:\n      text: 'News 24'\n      short: 'News24'\n    pty: 1                     # News\n    language: 9\n\n  # Service 3: Pop Hits\n  - uid: 'pop_service'\n    id: '0x5003'\n    label:\n      text: 'Pop Hits Radio'\n      short: 'PopHits'\n    pty: 10                    # Pop Music\n    language: 9\n\n  # Service 4: Classical\n  - uid: 'classical_service'\n    id: '0x5004'\n    label:\n      text: 'Classical FM'\n      short: 'Classic'\n    pty: 6                     # Classical Music\n    language: 9\n\n# Components - links between services and subchannels\ncomponents:\n  - uid: 'music_comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'news_comp'\n    service_id: '0x5002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'pop_comp'\n    service_id: '0x5003'\n    subchannel_id: 2\n    type: 0\n\n  - uid: 'classical_comp'\n    service_id: '0x5004'\n    subchannel_id: 3\n    type: 0\n</code></pre>"},{"location":"tutorials/multi-service-ensemble/#step-4-understand-start-addresses","title":"Step 4: Understand Start Addresses","text":"<p>The <code>start_address</code> field determines where each subchannel begins in the Main Service Transport (MST).</p> <p>How to calculate: 1. First subchannel always starts at 0 2. Each subsequent subchannel starts after the previous one 3. Calculate based on bitrate + protection overhead</p> <p>Simplified approach: Use multiples of 50 or 100 for spacing. python-dabmux will validate if they fit.</p> <p>Example: - Subchannel 0: start_address 0 - Subchannel 1: start_address 200 (after subchannel 0) - Subchannel 2: start_address 300 (after subchannel 1) - Subchannel 3: start_address 400 (after subchannel 2)</p>"},{"location":"tutorials/multi-service-ensemble/#step-5-test-configuration","title":"Step 5: Test Configuration","text":"<p>Test that all services are configured correctly:</p> <pre><code>python -m dabmux.cli -c multi_service.yaml -o test.eti -n 10 -vvv\n</code></pre> <p>Check for: <pre><code>INFO: Added service 'Music FM' (0x5001)\nINFO: Added service 'News 24' (0x5002)\nINFO: Added service 'Pop Hits Radio' (0x5003)\nINFO: Added service 'Classical FM' (0x5004)\nINFO: Added subchannel 0: audio, 192 kbps\nINFO: Added subchannel 1: dabplus, 64 kbps\nINFO: Added subchannel 2: dabplus, 80 kbps\nINFO: Added subchannel 3: dabplus, 96 kbps\n</code></pre></p>"},{"location":"tutorials/multi-service-ensemble/#step-6-generate-output","title":"Step 6: Generate Output","text":"<p>Generate a full multiplex:</p> <pre><code>python -m dabmux.cli -c multi_service.yaml -o multi_service.eti -n 5000\n</code></pre> <p>Expected: - 4 services multiplexed together - All services in one ETI stream - File size: ~30 MB (5000 frames \u00d7 ~6000 bytes)</p>"},{"location":"tutorials/multi-service-ensemble/#step-7-verify-services","title":"Step 7: Verify Services","text":"<p>Check that all services are present in the FIG data:</p> <pre><code># Generate a small sample\npython -m dabmux.cli -c multi_service.yaml -o sample.eti -n 100 -vvv\n</code></pre> <p>Look for FIG generation messages showing all services.</p>"},{"location":"tutorials/multi-service-ensemble/#understanding-programme-types-pty","title":"Understanding Programme Types (PTY)","text":"<p>The <code>pty</code> field categorizes stations:</p> PTY Category Use For 0 None Unspecified 1 News News stations 2 Current Affairs Talk/discussion 3 Information General information 4 Sport Sports content 5 Education Educational 6 Drama Drama/culture 6 Classical Music Classical 7 Rock Music Rock 8 Easy Listening Easy listening 9 Light Classical Light classical 10 Pop Music Pop 11 Jazz Music Jazz 12 Country Music Country <p>Choose the PTY that best matches your station's content.</p>"},{"location":"tutorials/multi-service-ensemble/#capacity-management","title":"Capacity Management","text":""},{"location":"tutorials/multi-service-ensemble/#checking-available-capacity","title":"Checking Available Capacity","text":"<p>Mode I provides 864 Capacity Units (CUs).</p> <p>Rough calculation: - 128 kbps DAB with level 2 protection \u2248 84 CUs - 192 kbps DAB with level 3 protection \u2248 150 CUs - 64 kbps DAB+ with level 2 protection \u2248 48 CUs - 80 kbps DAB+ with level 2 protection \u2248 60 CUs - 96 kbps DAB+ with level 3 protection \u2248 78 CUs</p> <p>Our ensemble: - Music FM: ~150 CUs - News 24: ~48 CUs - Pop Hits: ~60 CUs - Classical: ~78 CUs - Total: ~336 CUs (plenty of room!)</p>"},{"location":"tutorials/multi-service-ensemble/#if-you-exceed-capacity","title":"If You Exceed Capacity","text":"<p>Error: <pre><code>ERROR: Total subchannel capacity exceeds available CUs\n</code></pre></p> <p>Solutions: 1. Reduce bitrates: Lower some services to 48-64 kbps (DAB+) 2. Lower protection: Use level 1 or 2 instead of 3 3. Remove services: Fewer stations 4. Use DAB+ more: More efficient than DAB</p>"},{"location":"tutorials/multi-service-ensemble/#advanced-mixing-content-types","title":"Advanced: Mixing Content Types","text":""},{"location":"tutorials/multi-service-ensemble/#speech-optimized-service","title":"Speech-Optimized Service","text":"<p>For talk/news stations, use lower bitrates:</p> <pre><code>- uid: 'talk_audio'\n  type: 'dabplus'\n  bitrate: 48                  # Low bitrate, fine for speech\n  protection:\n    level: 2\n</code></pre>"},{"location":"tutorials/multi-service-ensemble/#high-quality-music-service","title":"High-Quality Music Service","text":"<p>For premium music content:</p> <pre><code>- uid: 'premium_audio'\n  type: 'audio'                # DAB for high quality\n  bitrate: 256                 # Very high quality\n  protection:\n    level: 3\n</code></pre>"},{"location":"tutorials/multi-service-ensemble/#balanced-ensemble","title":"Balanced Ensemble","text":"<p>Mix high and low bitrate services to maximize quality within capacity:</p> <ul> <li>1\u00d7 192 kbps DAB (premium music)</li> <li>2\u00d7 80 kbps DAB+ (regular music)</li> <li>3\u00d7 48 kbps DAB+ (news/talk)</li> </ul> <p>This gives 6 services within Mode I capacity.</p>"},{"location":"tutorials/multi-service-ensemble/#testing-scenarios","title":"Testing Scenarios","text":""},{"location":"tutorials/multi-service-ensemble/#continuous-operation","title":"Continuous Operation","text":"<p>Run the multiplex continuously:</p> <pre><code>python -m dabmux.cli -c multi_service.yaml -o output.eti --continuous\n</code></pre> <p>All 4 services will multiplex together continuously.</p>"},{"location":"tutorials/multi-service-ensemble/#with-timestamps","title":"With Timestamps","text":"<p>Add timestamps for synchronized transmission:</p> <pre><code>python -m dabmux.cli -c multi_service.yaml -o output.eti --tist -n 5000\n</code></pre>"},{"location":"tutorials/multi-service-ensemble/#different-services-per-file","title":"Different Services per File","text":"<p>Test with different audio files to verify each service is independent:</p> <pre><code># Create distinct test files\nffmpeg -i /dev/urandom -f s16le -ar 48000 -ac 2 -t 60 -codec:a mp2 -b:a 192k test1.mp2\nffmpeg -i /dev/urandom -f s16le -ar 48000 -ac 2 -t 60 -codec:a libfdk_aac -profile:a aac_he -b:a 64k test2.aac\n</code></pre>"},{"location":"tutorials/multi-service-ensemble/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/multi-service-ensemble/#error-duplicate-service-id","title":"Error: Duplicate service ID","text":"<pre><code>ERROR: Duplicate service ID: 0x5001\n</code></pre> <p>Solution: Ensure each service has a unique ID: <pre><code>services:\n  - id: '0x5001'  # Unique\n  - id: '0x5002'  # Unique\n  - id: '0x5003'  # Unique\n</code></pre></p>"},{"location":"tutorials/multi-service-ensemble/#error-component-references-unknown-subchannel","title":"Error: Component references unknown subchannel","text":"<pre><code>ERROR: Component references unknown subchannel_id: 5\n</code></pre> <p>Solution: Verify <code>subchannel_id</code> in components matches a subchannel <code>id</code>: <pre><code>subchannels:\n  - id: 0       # \u2190 This ID\ncomponents:\n  - subchannel_id: 0  # \u2190 Must match\n</code></pre></p>"},{"location":"tutorials/multi-service-ensemble/#one-service-is-silent","title":"One service is silent","text":"<p>Problem: One service produces no audio</p> <p>Possible causes: 1. Input file not found or wrong format 2. Mismatched bitrate (config vs. file) 3. Wrong audio type (audio vs. dabplus)</p> <p>Solution: - Verify input file: <code>ffprobe service.mp2</code> - Check type matches format (MPEG = audio, AAC = dabplus) - Ensure bitrate in config matches file</p>"},{"location":"tutorials/multi-service-ensemble/#next-steps","title":"Next Steps","text":""},{"location":"tutorials/multi-service-ensemble/#add-network-inputs","title":"Add Network Inputs","text":"<p>Continue to Network Streaming Tutorial to use UDP/TCP inputs instead of files.</p>"},{"location":"tutorials/multi-service-ensemble/#add-pft-for-network-output","title":"Add PFT for Network Output","text":"<p>Continue to PFT with FEC Tutorial to add error correction for network transmission.</p>"},{"location":"tutorials/multi-service-ensemble/#optimize-for-your-use-case","title":"Optimize for Your Use Case","text":"<p>Read the Configuration Reference to fine-tune: - Protection levels - Bitrate allocation - Label customization</p>"},{"location":"tutorials/multi-service-ensemble/#summary","title":"Summary","text":"<p>Congratulations! You've created a multi-service DAB ensemble. You learned:</p> <ul> <li>\u2705 Configuring multiple services in one ensemble</li> <li>\u2705 Mixing DAB and DAB+ services</li> <li>\u2705 Managing capacity allocation</li> <li>\u2705 Using appropriate bitrates for different content types</li> <li>\u2705 Understanding start addresses and subchannel organization</li> </ul>"},{"location":"tutorials/multi-service-ensemble/#complete-configuration","title":"Complete Configuration","text":"<p>Here's the complete configuration for reference:</p> <pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Multi DAB'\n    short: 'MultiDAB'\n  lto_auto: true\n\nsubchannels:\n  - {uid: music_audio, id: 0, type: audio, bitrate: 192, start_address: 0,\n     protection: {level: 3, shortform: true}, input: 'file://music_192.mp2'}\n  - {uid: news_audio, id: 1, type: dabplus, bitrate: 64, start_address: 200,\n     protection: {level: 2, shortform: true}, input: 'file://news_64.aac'}\n  - {uid: pop_audio, id: 2, type: dabplus, bitrate: 80, start_address: 300,\n     protection: {level: 2, shortform: true}, input: 'file://pop_80.aac'}\n  - {uid: classical_audio, id: 3, type: dabplus, bitrate: 96, start_address: 400,\n     protection: {level: 3, shortform: true}, input: 'file://classical_96.aac'}\n\nservices:\n  - {uid: music_service, id: '0x5001', label: {text: Music FM, short: MusicFM}, pty: 10, language: 9}\n  - {uid: news_service, id: '0x5002', label: {text: News 24, short: News24}, pty: 1, language: 9}\n  - {uid: pop_service, id: '0x5003', label: {text: Pop Hits Radio, short: PopHits}, pty: 10, language: 9}\n  - {uid: classical_service, id: '0x5004', label: {text: Classical FM, short: Classic}, pty: 6, language: 9}\n\ncomponents:\n  - {uid: music_comp, service_id: '0x5001', subchannel_id: 0, type: 0}\n  - {uid: news_comp, service_id: '0x5002', subchannel_id: 1, type: 0}\n  - {uid: pop_comp, service_id: '0x5003', subchannel_id: 2, type: 0}\n  - {uid: classical_comp, service_id: '0x5004', subchannel_id: 3, type: 0}\n</code></pre> <p>Save this as <code>multi_service.yaml</code> and multiplex 4 services together!</p>"},{"location":"tutorials/network-streaming/","title":"Tutorial: Network Streaming","text":"<p>Stream audio over the network using UDP and TCP inputs for live broadcasting.</p> <p>Difficulty: Intermediate Time: 30 minutes</p>"},{"location":"tutorials/network-streaming/#what-youll-build","title":"What You'll Build","text":"<p>A live streaming setup with: - UDP network input (multicast) - TCP network input (reliable) - Live audio encoding with ffmpeg - Network troubleshooting skills</p>"},{"location":"tutorials/network-streaming/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Basic Single Service Tutorial</li> <li>ffmpeg installed</li> <li>Basic network knowledge</li> </ul>"},{"location":"tutorials/network-streaming/#step-1-understanding-network-inputs","title":"Step 1: Understanding Network Inputs","text":""},{"location":"tutorials/network-streaming/#udp-user-datagram-protocol","title":"UDP (User Datagram Protocol)","text":"<ul> <li>Fast: Low latency</li> <li>Unreliable: Packets can be lost</li> <li>Multicast: One stream to many receivers</li> <li>Best for: Local network, real-time streaming</li> </ul>"},{"location":"tutorials/network-streaming/#tcp-transmission-control-protocol","title":"TCP (Transmission Control Protocol)","text":"<ul> <li>Reliable: Guaranteed delivery</li> <li>Slower: Higher latency</li> <li>Unicast: One-to-one connection</li> <li>Best for: Reliability is critical</li> </ul>"},{"location":"tutorials/network-streaming/#step-2-create-udp-streaming-setup","title":"Step 2: Create UDP Streaming Setup","text":""},{"location":"tutorials/network-streaming/#configure-udp-input","title":"Configure UDP Input","text":"<p>Create <code>udp_stream.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xCE20'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Live Stream'\n    short: 'Live'\n  lto_auto: true\n\nsubchannels:\n  - uid: 'live_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'udp://239.1.2.3:5001'  # UDP multicast address\n\nservices:\n  - uid: 'live_service'\n    id: '0x7001'\n    label:\n      text: 'Live Radio'\n      short: 'Live'\n    pty: 1\n    language: 9\n\ncomponents:\n  - uid: 'live_comp'\n    service_id: '0x7001'\n    subchannel_id: 0\n    type: 0\n</code></pre>"},{"location":"tutorials/network-streaming/#stream-audio-to-udp","title":"Stream Audio to UDP","text":"<p>In a separate terminal, start streaming:</p> <pre><code>ffmpeg -re -i music.wav \\\n  -codec:a mp2 -b:a 128k -ar 48000 \\\n  -f rtp rtp://239.1.2.3:5001\n</code></pre> <p>Flags explained: - <code>-re</code>: Real-time mode (simulate live streaming) - <code>-codec:a mp2</code>: MPEG Layer II codec - <code>-b:a 128k</code>: 128 kbps bitrate - <code>-ar 48000</code>: 48 kHz sample rate - <code>-f rtp</code>: RTP protocol for UDP - <code>rtp://239.1.2.3:5001</code>: Multicast destination</p>"},{"location":"tutorials/network-streaming/#run-multiplexer","title":"Run Multiplexer","text":"<pre><code>python -m dabmux.cli -c udp_stream.yaml -o live.eti --continuous\n</code></pre> <p>The multiplexer will receive UDP stream and multiplex it continuously.</p>"},{"location":"tutorials/network-streaming/#step-3-test-udp-multicast","title":"Step 3: Test UDP Multicast","text":""},{"location":"tutorials/network-streaming/#check-network-configuration","title":"Check Network Configuration","text":"<pre><code># Linux/macOS: Check multicast routing\nnetstat -rn | grep 239\n\n# Should show route for 239.x.x.x addresses\n</code></pre>"},{"location":"tutorials/network-streaming/#add-multicast-route-if-needed","title":"Add Multicast Route (if needed)","text":"<pre><code># Linux\nsudo route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0\n\n# macOS\nsudo route add -net 224.0.0.0/4 -interface en0\n</code></pre>"},{"location":"tutorials/network-streaming/#monitor-udp-traffic","title":"Monitor UDP Traffic","text":"<pre><code># Use tcpdump to see UDP packets\nsudo tcpdump -i any udp port 5001 -n\n\n# Should show packets flowing to 239.1.2.3:5001\n</code></pre>"},{"location":"tutorials/network-streaming/#step-4-create-tcp-streaming-setup","title":"Step 4: Create TCP Streaming Setup","text":""},{"location":"tutorials/network-streaming/#configure-tcp-input","title":"Configure TCP Input","text":"<p>Create <code>tcp_stream.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xCE21'\n  label:\n    text: 'TCP Stream'\n    short: 'TCP'\n\nsubchannels:\n  - uid: 'tcp_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'tcp://192.168.1.100:5002'  # TCP connection\n\nservices:\n  - uid: 'tcp_service'\n    id: '0x7002'\n    label:\n      text: 'TCP Radio'\n</code></pre>"},{"location":"tutorials/network-streaming/#start-tcp-server-netcat","title":"Start TCP Server (netcat)","text":"<p>Stream to TCP socket:</p> <pre><code># Method 1: Using netcat as TCP server\nffmpeg -re -i music.wav -codec:a mp2 -b:a 128k -ar 48000 -f mp2 - | \\\n  nc -l 5002\n</code></pre>"},{"location":"tutorials/network-streaming/#run-multiplexer-connects-to-tcp","title":"Run Multiplexer (connects to TCP)","text":"<pre><code>python -m dabmux.cli -c tcp_stream.yaml -o tcp_live.eti --continuous\n</code></pre> <p>python-dabmux connects to the TCP server and receives audio.</p>"},{"location":"tutorials/network-streaming/#step-5-live-encoding-pipeline","title":"Step 5: Live Encoding Pipeline","text":""},{"location":"tutorials/network-streaming/#complete-live-pipeline","title":"Complete Live Pipeline","text":"<pre><code># Terminal 1: Capture live audio and stream\nffmpeg -f alsa -i hw:0 \\\n  -codec:a mp2 -b:a 128k -ar 48000 \\\n  -f rtp rtp://239.1.2.3:5001\n\n# Terminal 2: Multiplex the stream\npython -m dabmux.cli -c udp_stream.yaml -o live.eti --continuous\n\n# Terminal 3: Monitor output\nwatch -n 1 ls -lh live.eti\n</code></pre> <p>On macOS (use different audio input): <pre><code>ffmpeg -f avfoundation -i \":0\" \\\n  -codec:a mp2 -b:a 128k -ar 48000 \\\n  -f rtp rtp://239.1.2.3:5001\n</code></pre></p>"},{"location":"tutorials/network-streaming/#step-6-multiple-network-inputs","title":"Step 6: Multiple Network Inputs","text":"<p>Mix file and network inputs:</p> <pre><code>subchannels:\n  # Network input\n  - uid: 'live1'\n    id: 0\n    input: 'udp://239.1.2.3:5001'\n\n  # File input\n  - uid: 'backup'\n    id: 1\n    input: 'file://backup.mp2'\n</code></pre>"},{"location":"tutorials/network-streaming/#network-input-best-practices","title":"Network Input Best Practices","text":""},{"location":"tutorials/network-streaming/#buffer-management","title":"Buffer Management","text":"<p>Network inputs have internal buffering. python-dabmux handles: - Underruns: When network is slow - Overruns: When network is fast - Jitter: Variable packet timing</p>"},{"location":"tutorials/network-streaming/#firewall-configuration","title":"Firewall Configuration","text":"<pre><code># Allow UDP port (Linux/ufw)\nsudo ufw allow 5001/udp\n\n# Allow TCP port\nsudo ufw allow 5002/tcp\n</code></pre>"},{"location":"tutorials/network-streaming/#bandwidth-calculation","title":"Bandwidth Calculation","text":"<p>For 128 kbps audio: - Network bandwidth needed: ~150 kbps (with overhead) - Packet rate: ~100-200 packets/second - Latency: &lt;100ms typical</p>"},{"location":"tutorials/network-streaming/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/network-streaming/#no-audio-from-udp-input","title":"No audio from UDP input","text":"<p>Check streaming is active: <pre><code>nc -u 239.1.2.3 5001\n# Should receive data\n</code></pre></p> <p>Check multicast routing: <pre><code>netstat -g  # Show multicast groups\n</code></pre></p> <p>Solution: Start ffmpeg streaming first, then multiplexer.</p>"},{"location":"tutorials/network-streaming/#tcp-connection-refused","title":"TCP connection refused","text":"<p>Error: <pre><code>ERROR: Connection refused: 192.168.1.100:5002\n</code></pre></p> <p>Solutions: 1. Start TCP server first (nc -l 5002) 2. Check IP address is correct 3. Check firewall allows port</p>"},{"location":"tutorials/network-streaming/#packet-loss","title":"Packet loss","text":"<p>Symptoms: Audio dropouts, underruns</p> <p>Solutions: 1. Use TCP instead of UDP 2. Reduce network congestion 3. Use wired instead of wireless 4. Increase encoding bitrate margin</p>"},{"location":"tutorials/network-streaming/#high-latency","title":"High latency","text":"<p>Problem: Delay between input and output</p> <p>Solutions: 1. Use UDP (lower latency than TCP) 2. Reduce buffer sizes 3. Use local network (not Internet)</p>"},{"location":"tutorials/network-streaming/#edi-network-output","title":"EDI Network Output","text":"<p>Combine network input with EDI output:</p> <pre><code># Receive UDP, output EDI to network\npython -m dabmux.cli \\\n  -c udp_stream.yaml \\\n  --edi udp://239.2.3.4:12000 \\\n  --continuous\n</code></pre> <p>Complete network-to-network pipeline!</p>"},{"location":"tutorials/network-streaming/#next-steps","title":"Next Steps","text":""},{"location":"tutorials/network-streaming/#add-pft-for-reliability","title":"Add PFT for Reliability","text":"<p>Continue to PFT with FEC Tutorial to add error correction.</p>"},{"location":"tutorials/network-streaming/#monitor-network-performance","title":"Monitor Network Performance","text":"<p>Use tools like: - <code>iftop</code>: Monitor bandwidth - <code>tcpdump</code>: Capture packets - <code>netstat</code>: Check connections</p>"},{"location":"tutorials/network-streaming/#summary","title":"Summary","text":"<p>You've learned network streaming:</p> <ul> <li>\u2705 UDP multicast inputs</li> <li>\u2705 TCP reliable inputs</li> <li>\u2705 Live audio encoding</li> <li>\u2705 Network troubleshooting</li> <li>\u2705 Firewall configuration</li> </ul> <p>Network inputs enable live broadcasting with python-dabmux!</p>"},{"location":"tutorials/network-streaming/#quick-commands","title":"Quick Commands","text":"<pre><code># Stream to UDP multicast\nffmpeg -re -i audio.wav -codec:a mp2 -b:a 128k -f rtp rtp://239.1.2.3:5001\n\n# Multiplex UDP input\npython -m dabmux.cli -c udp_config.yaml -o output.eti --continuous\n\n# Stream to TCP\nffmpeg -re -i audio.wav -codec:a mp2 -b:a 128k -f mp2 - | nc -l 5002\n\n# Multiplex TCP input\npython -m dabmux.cli -c tcp_config.yaml -o output.eti --continuous\n</code></pre>"},{"location":"tutorials/pft-with-fec/","title":"Tutorial: PFT with FEC","text":"<p>Use PFT (Protection, Fragmentation and Transport) with Reed-Solomon FEC for reliable network transmission.</p> <p>Difficulty: Advanced Time: 35 minutes</p>"},{"location":"tutorials/pft-with-fec/#what-youll-build","title":"What You'll Build","text":"<p>An EDI output setup with: - PFT fragmentation - Reed-Solomon Forward Error Correction - Resilience to packet loss - Network monitoring</p>"},{"location":"tutorials/pft-with-fec/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Network Streaming Tutorial</li> <li>Understanding of EDI Protocol</li> <li>Network tools (netcat, tcpdump)</li> </ul>"},{"location":"tutorials/pft-with-fec/#what-is-pft","title":"What is PFT?","text":"<p>PFT (Protection, Fragmentation and Transport) adds three capabilities to EDI:</p> <ol> <li>Fragmentation: Splits large packets to fit MTU</li> <li>Sequencing: Detects missing fragments</li> <li>FEC: Recovers lost fragments using Reed-Solomon</li> </ol>"},{"location":"tutorials/pft-with-fec/#step-1-basic-pft-setup","title":"Step 1: Basic PFT Setup","text":""},{"location":"tutorials/pft-with-fec/#configuration","title":"Configuration","text":"<p>Create <code>pft_config.yaml</code>:</p> <pre><code>ensemble:\n  id: '0xCE30'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'PFT Demo'\n    short: 'PFT'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x8001'\n    label:\n      text: 'PFT Radio'\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x8001'\n    subchannel_id: 0\n</code></pre>"},{"location":"tutorials/pft-with-fec/#run-with-pft-no-fec-yet","title":"Run with PFT (no FEC yet)","text":"<pre><code>python -m dabmux.cli \\\n  -c pft_config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --continuous\n</code></pre> <p>What happens: - ETI frames converted to EDI - Large packets fragmented to 1400 bytes - Fragments sent over UDP</p>"},{"location":"tutorials/pft-with-fec/#step-2-enable-reed-solomon-fec","title":"Step 2: Enable Reed-Solomon FEC","text":""},{"location":"tutorials/pft-with-fec/#run-with-fec","title":"Run with FEC","text":"<pre><code>python -m dabmux.cli \\\n  -c pft_config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 2 \\\n  --continuous\n</code></pre> <p>Flags: - <code>--pft</code>: Enable PFT fragmentation - <code>--pft-fec</code>: Enable Reed-Solomon FEC - <code>--pft-fec-m 2</code>: Can recover up to 2 lost fragments</p>"},{"location":"tutorials/pft-with-fec/#how-fec-works","title":"How FEC Works","text":"<p>Example: ETI frame fragmented into 5 data fragments + 2 parity fragments</p> <pre><code>Data fragments:    [1] [2] [3] [4] [5]\nParity fragments:                    [P1] [P2]\n\nTotal sent: 7 fragments\n\nCan lose any 2 and still reconstruct:\n- Lost [2] and [4]? Recover using [1][3][5][P1][P2]\n- Lost [3] and [P1]? Recover using [1][2][4][5][P2]\n</code></pre>"},{"location":"tutorials/pft-with-fec/#step-3-configure-fec-parameters","title":"Step 3: Configure FEC Parameters","text":""},{"location":"tutorials/pft-with-fec/#understanding-m-parameter","title":"Understanding M Parameter","text":"<p><code>--pft-fec-m M</code> sets recovery capability:</p> M Recovery Overhead Use Case 1 1 fragment ~14% Low packet loss 2 2 fragments ~29% Moderate packet loss 3 3 fragments ~43% High packet loss 4 4 fragments ~57% Very high packet loss <p>Trade-off: Higher M = better recovery but more bandwidth.</p>"},{"location":"tutorials/pft-with-fec/#fragment-size","title":"Fragment Size","text":"<pre><code># Default: 1400 bytes (fits standard MTU)\npython -m dabmux.cli --edi udp://239.1.2.3:12000 --pft --pft-fragment-size 1400\n\n# Smaller fragments (more conservative)\npython -m dabmux.cli --edi udp://239.1.2.3:12000 --pft --pft-fragment-size 1200\n\n# Larger fragments (jumbo frames)\npython -m dabmux.cli --edi udp://239.1.2.3:12000 --pft --pft-fragment-size 8000\n</code></pre> <p>Rule: Fragment size must be &lt; network MTU (typically 1500 bytes)</p>"},{"location":"tutorials/pft-with-fec/#step-4-test-packet-loss-recovery","title":"Step 4: Test Packet Loss Recovery","text":""},{"location":"tutorials/pft-with-fec/#simulate-packet-loss","title":"Simulate Packet Loss","text":"<p>Use <code>tc</code> (traffic control) to simulate packet loss:</p> <pre><code># Add 10% packet loss on interface eth0\nsudo tc qdisc add dev eth0 root netem loss 10%\n\n# Check it's applied\nsudo tc qdisc show dev eth0\n</code></pre>"},{"location":"tutorials/pft-with-fec/#run-with-different-fec-settings","title":"Run with Different FEC Settings","text":"<p>No FEC (baseline): <pre><code>python -m dabmux.cli -c pft_config.yaml --edi udp://239.1.2.3:12000 --pft -n 1000\n</code></pre></p> <p>With 10% loss, ~10% of fragments lost \u2192 some frames unrecoverable.</p> <p>With FEC m=2: <pre><code>python -m dabmux.cli -c pft_config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fec --pft-fec-m 2 -n 1000\n</code></pre></p> <p>With 10% loss, can recover up to 2 lost fragments per frame \u2192 much better!</p>"},{"location":"tutorials/pft-with-fec/#remove-packet-loss","title":"Remove Packet Loss","text":"<pre><code># Remove packet loss\nsudo tc qdisc del dev eth0 root\n</code></pre>"},{"location":"tutorials/pft-with-fec/#step-5-monitor-network-performance","title":"Step 5: Monitor Network Performance","text":""},{"location":"tutorials/pft-with-fec/#capture-pft-packets","title":"Capture PFT Packets","text":"<pre><code># Capture EDI/PFT traffic\nsudo tcpdump -i any udp port 12000 -w pft_capture.pcap\n\n# Analyze capture\ntcpdump -r pft_capture.pcap -n | head -20\n</code></pre>"},{"location":"tutorials/pft-with-fec/#check-fragment-count","title":"Check Fragment Count","text":"<p>Look for PF (PFT) sync bytes (0x5046):</p> <pre><code>tcpdump -r pft_capture.pcap -X | grep \"5046\"\n</code></pre>"},{"location":"tutorials/pft-with-fec/#bandwidth-calculation","title":"Bandwidth Calculation","text":"<p>Without PFT: - ETI frame: 6000 bytes - Overhead: ~2% (EDI headers) - Bandwidth: ~6120 bytes/frame</p> <p>With PFT (no FEC): - Fragmented into 5 fragments - Overhead: ~5% (PFT headers) - Bandwidth: ~6300 bytes/frame</p> <p>With PFT + FEC (m=2): - 5 data + 2 parity fragments - Total: 7 fragments - Overhead: ~40% - Bandwidth: ~8400 bytes/frame</p>"},{"location":"tutorials/pft-with-fec/#step-6-production-setup","title":"Step 6: Production Setup","text":""},{"location":"tutorials/pft-with-fec/#recommended-settings","title":"Recommended Settings","text":"<p>Low packet loss (&lt;1%): <pre><code>python -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 1 \\\n  --pft-fragment-size 1400 \\\n  --continuous\n</code></pre></p> <p>Moderate packet loss (1-5%): <pre><code>python -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 2 \\\n  --pft-fragment-size 1400 \\\n  --continuous\n</code></pre></p> <p>High packet loss (5-10%): <pre><code>python -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 3 \\\n  --pft-fragment-size 1200 \\\n  --continuous\n</code></pre></p>"},{"location":"tutorials/pft-with-fec/#network-optimization","title":"Network Optimization","text":"<p>Use dedicated network: - Separate VLAN for DAB traffic - QoS prioritization - Wired connections only</p> <p>Monitor performance: <pre><code># Check packet loss\nnetstat -su | grep \"packet receive errors\"\n\n# Monitor bandwidth\niftop -i eth0 -f \"udp port 12000\"\n</code></pre></p>"},{"location":"tutorials/pft-with-fec/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/pft-with-fec/#high-bandwidth-usage","title":"High bandwidth usage","text":"<p>Problem: PFT + FEC uses too much bandwidth</p> <p>Solutions: 1. Reduce M parameter (less FEC) 2. Use larger fragment size 3. Skip PFT if network is reliable</p>"},{"location":"tutorials/pft-with-fec/#fragments-not-reassembling","title":"Fragments not reassembling","text":"<p>Problem: Receiver can't reconstruct frames</p> <p>Causes: - More than M fragments lost - Sequence number gaps - Fragment timeout</p> <p>Solutions: 1. Increase M parameter 2. Improve network reliability 3. Check receiver buffer size</p>"},{"location":"tutorials/pft-with-fec/#mtu-issues","title":"MTU issues","text":"<p>Error: Fragments larger than MTU</p> <p>Solution: Reduce fragment size: <pre><code>--pft-fragment-size 1200  # Conservative\n</code></pre></p>"},{"location":"tutorials/pft-with-fec/#real-world-scenarios","title":"Real-World Scenarios","text":""},{"location":"tutorials/pft-with-fec/#local-network-lan","title":"Local Network (LAN)","text":"<pre><code># Reliable wired network - minimal PFT\n--pft --pft-fragment-size 1400\n# No FEC needed\n</code></pre>"},{"location":"tutorials/pft-with-fec/#wireless-network-wifi","title":"Wireless Network (WiFi)","text":"<pre><code># Some packet loss expected\n--pft --pft-fec --pft-fec-m 2 --pft-fragment-size 1200\n</code></pre>"},{"location":"tutorials/pft-with-fec/#wide-area-network-wan","title":"Wide Area Network (WAN)","text":"<pre><code># Higher latency and loss\n--pft --pft-fec --pft-fec-m 3 --pft-fragment-size 1200\n</code></pre>"},{"location":"tutorials/pft-with-fec/#internet-public","title":"Internet (Public)","text":"<pre><code># Unpredictable conditions\n--pft --pft-fec --pft-fec-m 4 --pft-fragment-size 1000\n</code></pre>"},{"location":"tutorials/pft-with-fec/#summary","title":"Summary","text":"<p>You've learned PFT with FEC:</p> <ul> <li>\u2705 Enabling PFT fragmentation</li> <li>\u2705 Configuring Reed-Solomon FEC</li> <li>\u2705 Calculating recovery parameters</li> <li>\u2705 Testing packet loss resilience</li> <li>\u2705 Production deployment</li> </ul> <p>PFT+FEC makes network transmission robust against packet loss!</p>"},{"location":"tutorials/pft-with-fec/#quick-reference","title":"Quick Reference","text":"<pre><code># Basic PFT (no FEC)\ndabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --continuous\n\n# PFT with FEC (recover 2 lost fragments)\ndabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fec --pft-fec-m 2 --continuous\n\n# Custom fragment size\ndabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fragment-size 1200 --continuous\n</code></pre>"},{"location":"user-guide/","title":"User Guide","text":"<p>Complete guide to using python-dabmux for DAB/DAB+ multiplexing.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>This user guide covers everything you need to operate python-dabmux effectively:</p> <ul> <li>CLI Reference: Complete command-line interface documentation</li> <li>Configuration: YAML configuration file reference</li> <li>Inputs: File and network input sources</li> <li>Outputs: ETI files and EDI network output</li> </ul>"},{"location":"user-guide/#quick-navigation","title":"Quick Navigation","text":""},{"location":"user-guide/#configuration","title":"Configuration","text":"<ul> <li>Configuration Overview</li> <li>Ensemble Parameters</li> <li>Services</li> <li>Subchannels</li> <li>Protection Levels</li> <li>Configuration Examples</li> </ul>"},{"location":"user-guide/#inputs","title":"Inputs","text":"<ul> <li>Input Overview</li> <li>File Inputs</li> <li>Network Inputs</li> <li>Audio Formats</li> </ul>"},{"location":"user-guide/#outputs","title":"Outputs","text":"<ul> <li>Output Overview</li> <li>ETI Files</li> <li>EDI Network</li> <li>PFT Fragmentation</li> </ul>"},{"location":"user-guide/#common-tasks","title":"Common Tasks","text":""},{"location":"user-guide/#creating-a-multiplex","title":"Creating a Multiplex","text":"<ol> <li>Write a configuration file</li> <li>Prepare audio inputs</li> <li>Run the multiplexer</li> <li>Verify the output</li> </ol>"},{"location":"user-guide/#streaming-over-network","title":"Streaming Over Network","text":"<ol> <li>Configure network inputs</li> <li>Enable EDI output</li> <li>Add PFT for reliability</li> <li>Run continuously</li> </ol>"},{"location":"user-guide/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Common Errors</li> <li>Input Issues</li> <li>Output Issues</li> <li>Network Issues</li> </ul>"},{"location":"user-guide/#see-also","title":"See Also","text":"<ul> <li>Getting Started: Installation and first multiplex</li> <li>Tutorials: Hands-on guides</li> <li>Architecture: System design</li> <li>API Reference: Python API documentation</li> </ul>"},{"location":"user-guide/cli-reference/","title":"CLI Reference","text":"<p>Complete command-line interface reference for python-dabmux.</p>"},{"location":"user-guide/cli-reference/#synopsis","title":"Synopsis","text":"<pre><code>python -m dabmux.cli [OPTIONS]\n</code></pre> <p>Or if installed globally:</p> <pre><code>dabmux [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli-reference/#required-arguments","title":"Required Arguments","text":""},{"location":"user-guide/cli-reference/#-c-config-file","title":"<code>-c, --config FILE</code>","text":"<p>Path to the configuration file (YAML format).</p> <p>Example: <pre><code>dabmux -c config.yaml -o output.eti\ndabmux --config /path/to/config.yaml -o output.eti\n</code></pre></p> <p>See also: Configuration Reference</p>"},{"location":"user-guide/cli-reference/#output-options","title":"Output Options","text":"<p>You must specify one output option (file or EDI network).</p>"},{"location":"user-guide/cli-reference/#-o-output-file","title":"<code>-o, --output FILE</code>","text":"<p>Write ETI frames to a file.</p> <p>Example: <pre><code>dabmux -c config.yaml -o output.eti\ndabmux -c config.yaml --output /path/to/output.eti\n</code></pre></p> <p>File formats: - Raw ETI (<code>.eti</code>) - Streamed ETI (with timestamps) - Framed ETI (aligned frames)</p> <p>See also: ETI Files</p>"},{"location":"user-guide/cli-reference/#-edi-url","title":"<code>--edi URL</code>","text":"<p>Send EDI output over the network (UDP or TCP).</p> <p>Format: <code>udp://host:port</code> or <code>tcp://host:port</code></p> <p>Example: <pre><code># UDP unicast\ndabmux -c config.yaml --edi udp://192.168.1.100:12000\n\n# UDP multicast\ndabmux -c config.yaml --edi udp://239.1.2.3:12000\n\n# TCP\ndabmux -c config.yaml --edi tcp://192.168.1.100:12000\n</code></pre></p> <p>See also: EDI Network</p>"},{"location":"user-guide/cli-reference/#eti-file-format-options","title":"ETI File Format Options","text":""},{"location":"user-guide/cli-reference/#-f-format-rawstreamedframed","title":"<code>-f, --format {raw,streamed,framed}</code>","text":"<p>ETI file output format. Only used with <code>-o/--output</code>.</p> <p>Default: <code>framed</code></p> <p>Options:</p> <ul> <li><code>raw</code>: Plain ETI frames with no additional structure</li> <li>Smallest file size</li> <li>No timing information</li> <li> <p>Compatible with most tools</p> </li> <li> <p><code>streamed</code>: ETI frames with timing information</p> </li> <li>Includes timestamps</li> <li> <p>Useful for synchronized playback</p> </li> <li> <p><code>framed</code>: Aligned ETI frames with delimiters</p> </li> <li>8-byte aligned</li> <li>Frame boundaries marked</li> <li>Easiest to parse</li> </ul> <p>Example: <pre><code># Raw ETI\ndabmux -c config.yaml -o output.eti -f raw\n\n# Streamed ETI (with timestamps)\ndabmux -c config.yaml -o output.eti -f streamed\n\n# Framed ETI (default)\ndabmux -c config.yaml -o output.eti -f framed\n</code></pre></p>"},{"location":"user-guide/cli-reference/#pft-options","title":"PFT Options","text":"<p>PFT (Protection, Fragmentation and Transport) options. Only used with <code>--edi</code>.</p>"},{"location":"user-guide/cli-reference/#-pft","title":"<code>--pft</code>","text":"<p>Enable PFT for EDI output.</p> <p>Benefits: - Fragments large packets to fit MTU - Adds sequence numbers - Enables optional FEC</p> <p>Example: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft\n</code></pre></p> <p>See also: PFT Fragmentation</p>"},{"location":"user-guide/cli-reference/#-pft-fec","title":"<code>--pft-fec</code>","text":"<p>Enable Forward Error Correction (FEC) for PFT.</p> <p>Requires: <code>--pft</code></p> <p>Benefits: - Recovers lost packets - Uses Reed-Solomon encoding - Increases bandwidth usage</p> <p>Example: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fec\n</code></pre></p> <p>See also: Reed-Solomon FEC</p>"},{"location":"user-guide/cli-reference/#-pft-fec-m-m","title":"<code>--pft-fec-m M</code>","text":"<p>Maximum number of recoverable fragments for PFT FEC.</p> <p>Requires: <code>--pft</code> and <code>--pft-fec</code></p> <p>Default: <code>2</code></p> <p>Range: 1-20 (higher values = more recovery capability but more bandwidth)</p> <p>Example: <pre><code># Can recover up to 5 lost fragments\ndabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fec --pft-fec-m 5\n</code></pre></p> <p>Trade-off: Higher M = better error recovery but higher bandwidth usage.</p>"},{"location":"user-guide/cli-reference/#-pft-fragment-size-size","title":"<code>--pft-fragment-size SIZE</code>","text":"<p>Maximum fragment size in bytes for PFT.</p> <p>Requires: <code>--pft</code></p> <p>Default: <code>1400</code></p> <p>Typical values: - <code>1400</code>: Safe for standard Ethernet (1500 MTU) - <code>1200</code>: Conservative for networks with overhead - <code>8000</code>: Jumbo frames (if supported)</p> <p>Example: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fragment-size 1200\n</code></pre></p> <p>Note: Must be smaller than network MTU to avoid IP fragmentation.</p>"},{"location":"user-guide/cli-reference/#frame-generation-options","title":"Frame Generation Options","text":""},{"location":"user-guide/cli-reference/#-n-num-frames-n","title":"<code>-n, --num-frames N</code>","text":"<p>Number of ETI frames to generate.</p> <p>Default: <code>1</code></p> <p>Example: <pre><code># Generate 100 frames\ndabmux -c config.yaml -o output.eti -n 100\n\n# Generate 10,000 frames (about 16 minutes of Mode I)\ndabmux -c config.yaml -o output.eti --num-frames 10000\n</code></pre></p> <p>Calculation: - Mode I: 96 ms per frame (625 frames \u2248 1 minute) - Mode II: 24 ms per frame (2500 frames \u2248 1 minute)</p>"},{"location":"user-guide/cli-reference/#-continuous","title":"<code>--continuous</code>","text":"<p>Generate frames continuously until interrupted (Ctrl+C).</p> <p>Behavior: - Loops input files when they reach the end - Runs indefinitely until stopped - Useful for live transmission</p> <p>Example: <pre><code># Run until stopped\ndabmux -c config.yaml -o output.eti --continuous\n\n# Stream EDI continuously\ndabmux -c config.yaml --edi udp://239.1.2.3:12000 --continuous\n</code></pre></p> <p>Stop: Press <code>Ctrl+C</code> to gracefully stop.</p>"},{"location":"user-guide/cli-reference/#timestamp-options","title":"Timestamp Options","text":""},{"location":"user-guide/cli-reference/#-tist","title":"<code>--tist</code>","text":"<p>Enable TIST (Time-Stamp) field in ETI frames.</p> <p>Use cases: - Synchronized multi-transmitter networks (SFN) - Timed playback - Precise frame timing</p> <p>Example: <pre><code>dabmux -c config.yaml -o output.eti --tist\n</code></pre></p> <p>See also: Timestamps &amp; Sync</p>"},{"location":"user-guide/cli-reference/#-tist-offset-ms","title":"<code>--tist-offset MS</code>","text":"<p>TIST offset in milliseconds.</p> <p>Requires: <code>--tist</code></p> <p>Default: <code>0.0</code></p> <p>Use cases: - Compensate for processing delays - Align multiple multiplexers - Add fixed delay</p> <p>Example: <pre><code># Add 100ms offset\ndabmux -c config.yaml -o output.eti --tist --tist-offset 100.0\n\n# Negative offset (advance)\ndabmux -c config.yaml -o output.eti --tist --tist-offset -50.0\n</code></pre></p>"},{"location":"user-guide/cli-reference/#logging-options","title":"Logging Options","text":""},{"location":"user-guide/cli-reference/#-v-verbose","title":"<code>-v, --verbose</code>","text":"<p>Increase verbosity level. Can be repeated.</p> <p>Levels: - No <code>-v</code>: Warnings and errors only - <code>-v</code>: Warnings, errors - <code>-vv</code>: Info, warnings, errors - <code>-vvv</code>: Debug, info, warnings, errors</p> <p>Example: <pre><code># Normal verbosity\ndabmux -c config.yaml -o output.eti\n\n# Info messages\ndabmux -c config.yaml -o output.eti -vv\n\n# Debug messages\ndabmux -c config.yaml -o output.eti -vvv\n</code></pre></p>"},{"location":"user-guide/cli-reference/#-q-quiet","title":"<code>-q, --quiet</code>","text":"<p>Quiet mode (errors only).</p> <p>Use case: When you only want to see errors, no progress or status messages.</p> <p>Example: <pre><code>dabmux -c config.yaml -o output.eti -q\n</code></pre></p> <p>Note: Mutually exclusive with <code>-v</code>.</p>"},{"location":"user-guide/cli-reference/#version-and-help","title":"Version and Help","text":""},{"location":"user-guide/cli-reference/#-version","title":"<code>--version</code>","text":"<p>Show version and exit.</p> <p>Example: <pre><code>dabmux --version\n</code></pre></p> <p>Output: <pre><code>python-dabmux 0.6.0\n</code></pre></p>"},{"location":"user-guide/cli-reference/#-h-help","title":"<code>-h, --help</code>","text":"<p>Show help message and exit.</p> <p>Example: <pre><code>dabmux --help\n</code></pre></p>"},{"location":"user-guide/cli-reference/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/cli-reference/#basic-single-service","title":"Basic Single Service","text":"<p>Generate 1000 frames from a single audio service:</p> <pre><code>dabmux -c basic_config.yaml -o output.eti -n 1000\n</code></pre>"},{"location":"user-guide/cli-reference/#multi-service-ensemble","title":"Multi-Service Ensemble","text":"<p>Generate a multi-service ensemble with debug logging:</p> <pre><code>dabmux -c multi_service.yaml -o output.eti -n 5000 -vvv\n</code></pre>"},{"location":"user-guide/cli-reference/#network-streaming-with-pft","title":"Network Streaming with PFT","text":"<p>Stream EDI over UDP multicast with PFT and FEC:</p> <pre><code>dabmux -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec \\\n  --pft-fec-m 3 \\\n  --continuous\n</code></pre>"},{"location":"user-guide/cli-reference/#live-transmission","title":"Live Transmission","text":"<p>Continuous operation with timestamps:</p> <pre><code>dabmux -c live_config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --tist \\\n  --continuous \\\n  -vv\n</code></pre>"},{"location":"user-guide/cli-reference/#timed-recording","title":"Timed Recording","text":"<p>Generate exactly 10 minutes of Mode I frames (6250 frames):</p> <pre><code>dabmux -c config.yaml \\\n  -o recording.eti \\\n  -n 6250 \\\n  -f framed \\\n  --tist\n</code></pre>"},{"location":"user-guide/cli-reference/#development-testing","title":"Development Testing","text":"<p>Quick test with raw ETI output:</p> <pre><code>dabmux -c test_config.yaml -o test.eti -f raw -n 10 -q\n</code></pre>"},{"location":"user-guide/cli-reference/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Configuration file not found <code>1</code> Configuration error (invalid YAML, validation failed) <code>1</code> Output error (can't write file, network unreachable) <code>1</code> Unexpected error"},{"location":"user-guide/cli-reference/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"user-guide/cli-reference/#file-output-workflow","title":"File Output Workflow","text":"<ol> <li>Create configuration: <code>config.yaml</code></li> <li>Test with a few frames: <pre><code>dabmux -c config.yaml -o test.eti -n 10\n</code></pre></li> <li>Generate full output: <pre><code>dabmux -c config.yaml -o output.eti -n 10000\n</code></pre></li> </ol>"},{"location":"user-guide/cli-reference/#network-streaming-workflow","title":"Network Streaming Workflow","text":"<ol> <li>Test configuration: <pre><code>dabmux -c config.yaml -o test.eti -n 1\n</code></pre></li> <li>Start streaming: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --continuous\n</code></pre></li> <li>Monitor logs: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --continuous -vv\n</code></pre></li> </ol>"},{"location":"user-guide/cli-reference/#debugging-workflow","title":"Debugging Workflow","text":"<ol> <li>Enable debug logging: <pre><code>dabmux -c config.yaml -o debug.eti -n 10 -vvv\n</code></pre></li> <li>Check frame generation: <pre><code>hexdump -C debug.eti | head\n</code></pre></li> <li>Verify configuration: <pre><code>dabmux -c config.yaml --help\n</code></pre></li> </ol>"},{"location":"user-guide/cli-reference/#environment-variables","title":"Environment Variables","text":"<p>python-dabmux respects standard Python environment variables:</p> <ul> <li><code>PYTHONPATH</code>: Additional module search paths</li> <li><code>PYTHONUNBUFFERED</code>: Unbuffered output (useful for logging)</li> </ul> <p>Example: <pre><code>PYTHONUNBUFFERED=1 dabmux -c config.yaml -o output.eti --continuous\n</code></pre></p>"},{"location":"user-guide/cli-reference/#configuration-file-format","title":"Configuration File Format","text":"<p>See Configuration Reference for complete YAML configuration format.</p>"},{"location":"user-guide/cli-reference/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Use raw format for large files: Smallest file size    <pre><code>dabmux -c config.yaml -o output.eti -f raw\n</code></pre></p> </li> <li> <p>Disable logging for production: Use <code>-q</code> for minimal overhead    <pre><code>dabmux -c config.yaml -o output.eti -q --continuous\n</code></pre></p> </li> <li> <p>Adjust PFT fragment size: Match your network MTU    <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000 --pft --pft-fragment-size 1400\n</code></pre></p> </li> <li> <p>Use TCP for reliable delivery: When packet loss is unacceptable    <pre><code>dabmux -c config.yaml --edi tcp://192.168.1.100:12000\n</code></pre></p> </li> </ol>"},{"location":"user-guide/cli-reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/cli-reference/#configuration-not-found","title":"Configuration Not Found","text":"<pre><code>ERROR: Configuration file not found: config.yaml\n</code></pre> <p>Solution: Check file path and current directory: <pre><code>ls -l config.yaml\ndabmux -c /absolute/path/to/config.yaml -o output.eti\n</code></pre></p>"},{"location":"user-guide/cli-reference/#invalid-edi-url","title":"Invalid EDI URL","text":"<pre><code>ERROR: Invalid EDI URL: 239.1.2.3:12000 (must start with udp:// or tcp://)\n</code></pre> <p>Solution: Add protocol prefix: <pre><code>dabmux -c config.yaml --edi udp://239.1.2.3:12000\n</code></pre></p>"},{"location":"user-guide/cli-reference/#permission-denied","title":"Permission Denied","text":"<pre><code>ERROR: Permission denied: output.eti\n</code></pre> <p>Solution: Check file permissions or write to a different location: <pre><code>chmod 644 output.eti  # Fix permissions\n# Or write elsewhere\ndabmux -c config.yaml -o /tmp/output.eti\n</code></pre></p>"},{"location":"user-guide/cli-reference/#network-unreachable","title":"Network Unreachable","text":"<pre><code>ERROR: Network unreachable: 239.1.2.3:12000\n</code></pre> <p>Solution: Check network configuration: <pre><code># Test connectivity\nping 239.1.2.3\n# Check multicast routes\nnetstat -rn | grep 239\n</code></pre></p>"},{"location":"user-guide/cli-reference/#see-also","title":"See Also","text":"<ul> <li>Configuration Reference: Complete YAML configuration</li> <li>ETI Files: ETI file format details</li> <li>EDI Network: EDI network output</li> <li>Troubleshooting: Common errors and solutions</li> <li>Examples: Configuration examples</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration Reference","text":"<p>Complete reference for python-dabmux YAML configuration files.</p>"},{"location":"user-guide/configuration/#overview","title":"Overview","text":"<p>python-dabmux uses YAML configuration files to define the structure of a DAB ensemble. The configuration includes:</p> <ul> <li>Ensemble: Top-level container with ID, country code, and transmission parameters</li> <li>Subchannels: Audio/data streams with bitrates and protection levels</li> <li>Services: Radio stations with labels and metadata</li> <li>Components: Links between services and subchannels</li> </ul>"},{"location":"user-guide/configuration/#configuration-structure","title":"Configuration Structure","text":"<pre><code>ensemble:\n  # Ensemble-level parameters\n\nsubchannels:\n  # List of audio/data streams\n\nservices:\n  # List of radio stations\n\ncomponents:\n  # Links between services and subchannels\n</code></pre>"},{"location":"user-guide/configuration/#quick-example","title":"Quick Example","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'My DAB'\n    short: 'DAB'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 2\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n      short: 'Radio1'\n    pty: 1\n    language: 9\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n    type: 0\n</code></pre>"},{"location":"user-guide/configuration/#section-reference","title":"Section Reference","text":""},{"location":"user-guide/configuration/#ensemble-parameters","title":"Ensemble Parameters","text":"<p>Top-level ensemble configuration including:</p> <ul> <li>Ensemble ID and Extended Country Code (ECC)</li> <li>Transmission mode (I, II, III, IV)</li> <li>Ensemble label</li> <li>Local Time Offset (LTO)</li> </ul> <p>Read more \u2192</p>"},{"location":"user-guide/configuration/#services","title":"Services","text":"<p>Service (radio station) configuration including:</p> <ul> <li>Service ID and labels</li> <li>Programme Type (PTY)</li> <li>Language code</li> </ul> <p>Read more \u2192</p>"},{"location":"user-guide/configuration/#subchannels","title":"Subchannels","text":"<p>Subchannel (data stream) configuration including:</p> <ul> <li>Subchannel type (DAB, DAB+, packet, data)</li> <li>Bitrate and start address</li> <li>Input source (file or network)</li> <li>Protection settings</li> </ul> <p>Read more \u2192</p>"},{"location":"user-guide/configuration/#protection-levels","title":"Protection Levels","text":"<p>Error protection configuration including:</p> <ul> <li>UEP (Unequal Error Protection) levels (0-4)</li> <li>Short form vs long form protection</li> <li>Trade-offs and recommendations</li> </ul> <p>Read more \u2192</p>"},{"location":"user-guide/configuration/#configuration-examples","title":"Configuration Examples","text":"<p>Complete working examples including:</p> <ul> <li>Single service configuration</li> <li>Multi-service ensemble</li> <li>DAB+ configuration</li> <li>Network input configuration</li> </ul> <p>Read more \u2192</p>"},{"location":"user-guide/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>The relationship between configuration elements:</p> <pre><code>Ensemble (0xCE15 \"My DAB\")\n  \u2502\n  \u251c\u2500\u25ba Service 1 (0x5001 \"Radio One\")\n  \u2502     \u2514\u2500\u25ba Component 1\n  \u2502           \u2514\u2500\u25ba Subchannel 0 (128 kbps, audio)\n  \u2502                 \u2514\u2500\u25ba Input: file://audio1.mp2\n  \u2502\n  \u251c\u2500\u25ba Service 2 (0x5002 \"Radio Two\")\n  \u2502     \u2514\u2500\u25ba Component 2\n  \u2502           \u2514\u2500\u25ba Subchannel 1 (128 kbps, audio)\n  \u2502                 \u2514\u2500\u25ba Input: udp://239.1.2.3:5001\n  \u2502\n  \u2514\u2500\u25ba Service 3 (0x5003 \"Radio Three\")\n        \u2514\u2500\u25ba Component 3\n              \u2514\u2500\u25ba Subchannel 2 (96 kbps, dabplus)\n                    \u2514\u2500\u25ba Input: file://audio3.aac\n</code></pre> <p>Key points:</p> <ol> <li>Ensemble contains all services</li> <li>Services are what listeners see</li> <li>Components link services to subchannels</li> <li>Subchannels carry the actual audio data</li> <li>Inputs provide data to subchannels</li> </ol>"},{"location":"user-guide/configuration/#yaml-syntax","title":"YAML Syntax","text":""},{"location":"user-guide/configuration/#basic-types","title":"Basic Types","text":"<pre><code># Strings (quotes optional unless they contain special characters)\ntext: 'Hello World'\ntext: Hello World\n\n# Numbers\nnumber: 42\nhex: '0xCE15'  # Hex values must be quoted\n\n# Booleans\nenabled: true\ndisabled: false\n\n# Lists\nitems:\n  - item1\n  - item2\n  - item3\n</code></pre>"},{"location":"user-guide/configuration/#indentation","title":"Indentation","text":"<p>YAML uses spaces for indentation (not tabs):</p> <pre><code>ensemble:\n  id: '0xCE15'          # 2 spaces\n  label:\n    text: 'My DAB'      # 4 spaces\n    short: 'DAB'        # 4 spaces\n</code></pre>"},{"location":"user-guide/configuration/#comments","title":"Comments","text":"<pre><code># This is a comment\nensemble:\n  id: '0xCE15'          # Inline comment\n  # Another comment\n  ecc: '0xE1'\n</code></pre>"},{"location":"user-guide/configuration/#validation","title":"Validation","text":"<p>python-dabmux validates configuration files and reports errors:</p>"},{"location":"user-guide/configuration/#missing-required-fields","title":"Missing Required Fields","text":"<pre><code>ERROR: Missing 'ensemble' section in configuration\n</code></pre> <p>Solution: Add <code>ensemble:</code> section</p>"},{"location":"user-guide/configuration/#invalid-hex-values","title":"Invalid Hex Values","text":"<pre><code>ERROR: Invalid ensemble ID: CE15\n</code></pre> <p>Solution: Add <code>0x</code> prefix: <code>id: '0xCE15'</code></p>"},{"location":"user-guide/configuration/#mismatched-ids","title":"Mismatched IDs","text":"<pre><code>ERROR: Component references unknown service_id: 0x5999\n</code></pre> <p>Solution: Ensure <code>service_id</code> in components matches a service <code>id</code></p>"},{"location":"user-guide/configuration/#invalid-bitrate","title":"Invalid Bitrate","text":"<pre><code>ERROR: Invalid bitrate: 150 (not a standard DAB bitrate)\n</code></pre> <p>Solution: Use standard bitrates: 32, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384</p>"},{"location":"user-guide/configuration/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/configuration/#single-service","title":"Single Service","text":"<p>Simplest configuration with one radio station:</p> <pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Single Service'\n    short: 'Single'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 2\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'My Station'\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n</code></pre>"},{"location":"user-guide/configuration/#multiple-services","title":"Multiple Services","text":"<p>Ensemble with multiple stations:</p> <pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'Multi Service'\n    short: 'Multi'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    bitrate: 128\n    input: 'file://audio1.mp2'\n  - uid: 'audio2'\n    id: 1\n    bitrate: 128\n    input: 'file://audio2.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'Station 1'\n  - uid: 'service2'\n    id: '0x5002'\n    label:\n      text: 'Station 2'\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n  - uid: 'comp2'\n    service_id: '0x5002'\n    subchannel_id: 1\n</code></pre>"},{"location":"user-guide/configuration/#network-input","title":"Network Input","text":"<p>Using UDP/TCP network inputs:</p> <pre><code>subchannels:\n  # UDP unicast\n  - uid: 'audio1'\n    id: 0\n    input: 'udp://192.168.1.100:5001'\n\n  # UDP multicast\n  - uid: 'audio2'\n    id: 1\n    input: 'udp://239.1.2.3:5002'\n\n  # TCP\n  - uid: 'audio3'\n    id: 2\n    input: 'tcp://192.168.1.100:5003'\n</code></pre>"},{"location":"user-guide/configuration/#dab-configuration","title":"DAB+ Configuration","text":"<p>Using DAB+ (HE-AAC) instead of MPEG Layer II:</p> <pre><code>subchannels:\n  - uid: 'dabplus1'\n    id: 0\n    type: 'dabplus'          # DAB+ type\n    bitrate: 72              # Lower bitrate possible\n    input: 'file://audio.aac'  # AAC input file\n</code></pre>"},{"location":"user-guide/configuration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/#use-meaningful-uids","title":"Use Meaningful UIDs","text":"<pre><code># Good\nservices:\n  - uid: 'bbc_radio1'\n    id: '0x5001'\n\n# Bad\nservices:\n  - uid: 'svc1'\n    id: '0x5001'\n</code></pre>"},{"location":"user-guide/configuration/#choose-appropriate-bitrates","title":"Choose Appropriate Bitrates","text":"<ul> <li>128 kbps: Standard for music (DAB MPEG Layer II)</li> <li>192 kbps: High-quality music (DAB)</li> <li>64-80 kbps: Speech/talk radio (DAB+)</li> <li>48-72 kbps: Music (DAB+)</li> </ul>"},{"location":"user-guide/configuration/#select-protection-levels","title":"Select Protection Levels","text":"<ul> <li>Level 2: Default, good for most conditions</li> <li>Level 3: Weak signal areas</li> <li>Level 4: Very weak signal, data services</li> </ul>"},{"location":"user-guide/configuration/#use-absolute-paths-for-production","title":"Use Absolute Paths for Production","text":"<pre><code># Development\ninput: 'file://audio.mp2'\n\n# Production\ninput: 'file:///var/dabmux/audio.mp2'\n</code></pre>"},{"location":"user-guide/configuration/#document-your-configuration","title":"Document Your Configuration","text":"<pre><code>ensemble:\n  # Production ensemble for City Radio\n  id: '0xCE15'\n  # Germany\n  ecc: '0xE1'\n  # Mode I (standard terrestrial)\n  transmission_mode: 'I'\n</code></pre>"},{"location":"user-guide/configuration/#loading-configuration","title":"Loading Configuration","text":""},{"location":"user-guide/configuration/#from-python","title":"From Python","text":"<pre><code>from dabmux.config import load_config\n\nensemble = load_config('config.yaml')\n</code></pre>"},{"location":"user-guide/configuration/#from-cli","title":"From CLI","text":"<pre><code>dabmux -c config.yaml -o output.eti\n</code></pre>"},{"location":"user-guide/configuration/#see-also","title":"See Also","text":"<ul> <li>Ensemble Parameters: Detailed ensemble configuration</li> <li>Services: Service configuration reference</li> <li>Subchannels: Subchannel configuration reference</li> <li>Protection Levels: Error protection details</li> <li>Examples: Complete working examples</li> <li>CLI Reference: Command-line options</li> <li>Basic Concepts: DAB terminology</li> </ul>"},{"location":"user-guide/configuration/ensemble/","title":"Ensemble Parameters","text":"<p>Complete reference for ensemble-level configuration parameters.</p>"},{"location":"user-guide/configuration/ensemble/#overview","title":"Overview","text":"<p>The <code>ensemble</code> section defines top-level parameters that apply to the entire DAB multiplex.</p> <p>Required fields: - <code>id</code>: Ensemble identifier - <code>label</code>: Ensemble name</p> <p>Optional fields: - <code>ecc</code>: Extended Country Code - <code>transmission_mode</code>: RF transmission mode - <code>lto_auto</code>: Automatic local time offset - <code>lto</code>: Manual local time offset</p>"},{"location":"user-guide/configuration/ensemble/#ensemble-id","title":"Ensemble ID","text":""},{"location":"user-guide/configuration/ensemble/#id","title":"<code>id</code>","text":"<p>Unique 16-bit identifier for the ensemble.</p> <p>Type: String (hex) or Integer Format: <code>'0xXXXX'</code> (hex string, quoted) Range: 0x0000 - 0xFFFF (0 - 65535) Required: Yes</p> <p>Example: <pre><code>ensemble:\n  id: '0xCE15'\n</code></pre></p> <p>Guidelines: - Use hex format with quotes: <code>'0xCE15'</code> - Must be unique in your broadcast area - Typically assigned by broadcast authority - Avoid 0x0000 (reserved)</p> <p>Common mistakes: <pre><code># Wrong - missing quotes\nid: 0xCE15\n\n# Wrong - missing 0x prefix\nid: 'CE15'\n\n# Correct\nid: '0xCE15'\n</code></pre></p>"},{"location":"user-guide/configuration/ensemble/#extended-country-code-ecc","title":"Extended Country Code (ECC)","text":""},{"location":"user-guide/configuration/ensemble/#ecc","title":"<code>ecc</code>","text":"<p>Identifies the country of broadcast.</p> <p>Type: String (hex) or Integer Format: <code>'0xXX'</code> (hex string, quoted) Range: 0x00 - 0xFF Default: 0xE1 (Germany) Required: No (but recommended)</p> <p>Common values:</p> ECC Country <code>'0xE0'</code> Germany (alternative) <code>'0xE1'</code> Germany <code>'0xE2'</code> United Kingdom <code>'0xE3'</code> Switzerland <code>'0xE4'</code> Denmark <code>'0xF0'</code> France <code>'0xF1'</code> Belgium <p>Example: <pre><code>ensemble:\n  ecc: '0xE1'  # Germany\n</code></pre></p> <p>Purpose: - Helps receivers identify broadcast country - Used for regional service restrictions - Required for proper EPG integration</p>"},{"location":"user-guide/configuration/ensemble/#transmission-mode","title":"Transmission Mode","text":""},{"location":"user-guide/configuration/ensemble/#transmission_mode","title":"<code>transmission_mode</code>","text":"<p>DAB transmission mode defining RF characteristics.</p> <p>Type: String or Integer Values: <code>'I'</code>, <code>'II'</code>, <code>'III'</code>, <code>'IV'</code> (or <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>) Default: <code>'I'</code> Required: No</p> <p>Modes:</p> Mode Bandwidth Frame Duration Capacity Use Case I 1.536 MHz 96 ms 864 CU Standard terrestrial (most common) II 384 kHz 24 ms 216 CU Local/indoor, cable III 192 kHz 24 ms 108 CU Cable/satellite IV 768 kHz 48 ms 432 CU Regional, mobile <p>Example: <pre><code>ensemble:\n  transmission_mode: 'I'  # Standard mode\n</code></pre></p> <p>Recommendations: - Mode I: Default for terrestrial broadcasting (99% of use cases) - Mode II: Indoor/local transmitters - Mode III: Cable distribution - Mode IV: Mobile/regional coverage</p> <p>Note: Mode determines frame timing and capacity. Most DAB broadcasts use Mode I.</p>"},{"location":"user-guide/configuration/ensemble/#ensemble-label","title":"Ensemble Label","text":""},{"location":"user-guide/configuration/ensemble/#label","title":"<code>label</code>","text":"<p>The name of the ensemble displayed to listeners.</p> <p>Type: Object with <code>text</code> and optional <code>short</code> fields Required: Yes</p>"},{"location":"user-guide/configuration/ensemble/#labeltext","title":"<code>label.text</code>","text":"<p>Full ensemble name.</p> <p>Type: String Max length: 16 characters Character set: EBU Latin (ASCII-compatible subset) Required: Yes</p> <p>Example: <pre><code>ensemble:\n  label:\n    text: 'BBC DAB'\n</code></pre></p> <p>Guidelines: - Keep it descriptive but concise - Avoid special characters - Use spaces for readability - Max 16 characters (strictly enforced)</p>"},{"location":"user-guide/configuration/ensemble/#labelshort","title":"<code>label.short</code>","text":"<p>Abbreviated ensemble name.</p> <p>Type: String Max length: 8 characters Required: No (auto-generated if omitted) Default: First 8 characters of <code>text</code></p> <p>Example: <pre><code>ensemble:\n  label:\n    text: 'My Radio Network'\n    short: 'MyRadio'  # 8 chars\n</code></pre></p> <p>Guidelines: - Used on small displays - Should be recognizable abbreviation - Remove vowels if needed to fit: \"MyRadio\" \u2192 \"MyRdio\"</p> <p>Label validation: <pre><code># Valid\nlabel:\n  text: 'Test Ensemble'    # 13 chars - OK\n  short: 'Test'            # 4 chars - OK\n\n# Invalid - too long\nlabel:\n  text: 'This is a very long name'  # 24 chars - ERROR\n  short: 'TooLongName'                # 11 chars - ERROR\n\n# Auto short label\nlabel:\n  text: 'Test Ensemble'    # short = 'Test Ens' (first 8 chars)\n</code></pre></p>"},{"location":"user-guide/configuration/ensemble/#local-time-offset","title":"Local Time Offset","text":""},{"location":"user-guide/configuration/ensemble/#lto_auto","title":"<code>lto_auto</code>","text":"<p>Automatically calculate local time offset from system timezone.</p> <p>Type: Boolean Values: <code>true</code>, <code>false</code> Default: <code>true</code> Required: No</p> <p>Example: <pre><code>ensemble:\n  lto_auto: true\n</code></pre></p> <p>Behavior: - <code>true</code>: Automatically detect timezone offset from system - <code>false</code>: Use manual <code>lto</code> value</p> <p>Recommended: Use <code>true</code> unless you have specific requirements.</p>"},{"location":"user-guide/configuration/ensemble/#lto","title":"<code>lto</code>","text":"<p>Manual local time offset in half-hour increments.</p> <p>Type: Integer Range: -24 to +24 (in half-hours) Unit: Half-hours relative to UTC Default: 0 Required: Only if <code>lto_auto: false</code></p> <p>Examples: <pre><code># UTC (no offset)\nlto_auto: false\nlto: 0\n\n# UTC+1 (Central European Time in winter)\nlto_auto: false\nlto: 2  # +1 hour = 2 half-hours\n\n# UTC+5:30 (India Standard Time)\nlto_auto: false\nlto: 11  # +5.5 hours = 11 half-hours\n\n# UTC-5 (US Eastern Time in winter)\nlto_auto: false\nlto: -10  # -5 hours = -10 half-hours\n</code></pre></p> <p>Calculation: <pre><code>LTO value = (hours \u00d7 2) + (minutes / 30)\n\nExamples:\nUTC+1:00  \u2192 1 \u00d7 2 + 0 = 2\nUTC+1:30  \u2192 1 \u00d7 2 + 1 = 3\nUTC-5:00  \u2192 -5 \u00d7 2 + 0 = -10\nUTC+5:30  \u2192 5 \u00d7 2 + 1 = 11\n</code></pre></p>"},{"location":"user-guide/configuration/ensemble/#complete-example","title":"Complete Example","text":""},{"location":"user-guide/configuration/ensemble/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'My DAB'\n</code></pre> <p>Uses defaults: - ECC: 0xE1 (Germany) - Transmission mode: I - LTO: Auto</p>"},{"location":"user-guide/configuration/ensemble/#full-configuration","title":"Full Configuration","text":"<pre><code>ensemble:\n  # Identification\n  id: '0xCE15'\n  ecc: '0xE2'  # United Kingdom\n\n  # RF parameters\n  transmission_mode: 'I'\n\n  # Labels\n  label:\n    text: 'BBC Radio DAB'\n    short: 'BBC DAB'\n\n  # Time\n  lto_auto: true\n</code></pre>"},{"location":"user-guide/configuration/ensemble/#manual-time-offset","title":"Manual Time Offset","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'Test Ensemble'\n\n  # Manual time offset (UTC+1)\n  lto_auto: false\n  lto: 2  # +1 hour\n</code></pre>"},{"location":"user-guide/configuration/ensemble/#validation-rules","title":"Validation Rules","text":"<p>python-dabmux validates ensemble configuration:</p> <ol> <li> <p>ID present and valid <pre><code>\u2713 id: '0xCE15'\n\u2717 id: (missing)\n\u2717 id: 0xFFFFFF (out of range)\n</code></pre></p> </li> <li> <p>Label length <pre><code>\u2713 text: 'Test' (4 chars)\n\u2713 text: 'Sixteen Char Txt' (16 chars)\n\u2717 text: 'This is too long!' (17 chars)\n</code></pre></p> </li> <li> <p>ECC format <pre><code>\u2713 ecc: '0xE1'\n\u2717 ecc: 'E1' (missing 0x)\n</code></pre></p> </li> <li> <p>Transmission mode <pre><code>\u2713 transmission_mode: 'I'\n\u2713 transmission_mode: 1\n\u2717 transmission_mode: 'V' (invalid)\n</code></pre></p> </li> <li> <p>LTO range <pre><code>\u2713 lto: 2\n\u2713 lto: -10\n\u2717 lto: 50 (out of range)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/configuration/ensemble/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/configuration/ensemble/#label-too-long-error","title":"Label too long error","text":"<p>Error: <pre><code>ERROR: Label text exceeds 16 characters\n</code></pre></p> <p>Solution: <pre><code># Shorten the label\nlabel:\n  text: 'My DAB Network'  # 14 chars - OK\n</code></pre></p>"},{"location":"user-guide/configuration/ensemble/#invalid-hex-format","title":"Invalid hex format","text":"<p>Error: <pre><code>ERROR: Invalid hex value: CE15\n</code></pre></p> <p>Solution: <pre><code># Add quotes and 0x prefix\nid: '0xCE15'  # Correct\n</code></pre></p>"},{"location":"user-guide/configuration/ensemble/#missing-required-field","title":"Missing required field","text":"<p>Error: <pre><code>ERROR: Missing required field: id\n</code></pre></p> <p>Solution: <pre><code>ensemble:\n  id: '0xCE15'  # Required\n  label:\n    text: 'My DAB'  # Required\n</code></pre></p>"},{"location":"user-guide/configuration/ensemble/#see-also","title":"See Also","text":"<ul> <li>Services: Service configuration</li> <li>Subchannels: Audio stream configuration</li> <li>Configuration Hierarchy: How elements relate</li> <li>Examples: Complete working configurations</li> </ul>"},{"location":"user-guide/configuration/examples/","title":"Configuration Examples","text":"<p>Complete working configuration examples for common scenarios.</p>"},{"location":"user-guide/configuration/examples/#overview","title":"Overview","text":"<p>This page provides ready-to-use configuration examples for various use cases. Each example is annotated and explains the key configuration decisions.</p> <p>Example categories: - Single Service (Minimal) - Multi-Service Ensemble - DAB+ Configuration - Network Streaming - Mixed DAB/DAB+ - High Protection - Maximum Capacity - Indoor/Local Transmitter - EDI Output</p>"},{"location":"user-guide/configuration/examples/#single-service-minimal","title":"Single Service (Minimal)","text":"<p>Use case: Simple single-station setup for testing or small deployments.</p> <p>File: <code>single_service.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'Test Ensemble'\n\nsubchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'service1'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0x5001'\n    subchannel_id: 0\n    type: 0\n</code></pre> <p>Key points: - Uses defaults: ECC=0xE1 (Germany), Mode I, auto LTO - Standard 128 kbps DAB audio - Protection level 2 (recommended default) - File input with relative path</p> <p>Run: <pre><code>python -m dabmux.cli -c single_service.yaml -o output.eti\n</code></pre></p> <p>Capacity usage: ~84 CU (out of 864 available in Mode I)</p>"},{"location":"user-guide/configuration/examples/#multi-service-ensemble","title":"Multi-Service Ensemble","text":"<p>Use case: Multiple radio stations in one ensemble with different bitrates and content types.</p> <p>File: <code>multi_service.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE15'\n  ecc: '0xE1'\n  transmission_mode: 'I'\n  label:\n    text: 'DAB Multiplex'\n    short: 'DABMux'\n  lto_auto: true\n\nsubchannels:\n  # High-quality music station (DAB)\n  - uid: 'music_hq'\n    id: 0\n    type: 'audio'\n    bitrate: 160\n    start_address: 0\n    protection:\n      level: 3\n      shortform: true\n    input: 'file://music.mp2'\n\n  # News/talk station (DAB+)\n  - uid: 'news'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    start_address: 150\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://news.aac'\n\n  # Pop music station (DAB+)\n  - uid: 'pop'\n    id: 2\n    type: 'dabplus'\n    bitrate: 80\n    start_address: 250\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://pop.aac'\n\n  # Classical music station (DAB+)\n  - uid: 'classical'\n    id: 3\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 350\n    protection:\n      level: 3\n      shortform: true\n    input: 'file://classical.aac'\n\nservices:\n  # Music station\n  - uid: 'music_service'\n    id: '0x5001'\n    label:\n      text: 'Classic Hits'\n      short: 'Hits'\n    pty: 10  # Pop Music\n    language: 9  # English\n\n  # News station\n  - uid: 'news_service'\n    id: '0x5002'\n    label:\n      text: 'News 24/7'\n      short: 'News24'\n    pty: 1  # News\n    language: 9  # English\n\n  # Pop station\n  - uid: 'pop_service'\n    id: '0x5003'\n    label:\n      text: 'Top 40 Radio'\n      short: 'Top40'\n    pty: 10  # Pop Music\n    language: 9  # English\n\n  # Classical station\n  - uid: 'classical_service'\n    id: '0x5004'\n    label:\n      text: 'Classical FM'\n      short: 'Classic'\n    pty: 14  # Serious Classical\n    language: 9  # English\n\ncomponents:\n  - uid: 'music_comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'news_comp'\n    service_id: '0x5002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'pop_comp'\n    service_id: '0x5003'\n    subchannel_id: 2\n    type: 0\n\n  - uid: 'classical_comp'\n    service_id: '0x5004'\n    subchannel_id: 3\n    type: 0\n</code></pre> <p>Key points: - 4 services with different content types - Mixed bitrates: 160, 64, 80, 96 kbps - Protection levels vary by importance - Explicit start_address spacing - Short labels for small displays</p> <p>Capacity calculation: - Music (160 kbps @ level 3): ~120 CU - News (64 kbps @ level 2): ~50 CU - Pop (80 kbps @ level 2): ~65 CU - Classical (96 kbps @ level 3): ~85 CU - Total: ~320 CU (out of 864 available)</p> <p>Run: <pre><code>python -m dabmux.cli -c multi_service.yaml -o multiplex.eti\n</code></pre></p>"},{"location":"user-guide/configuration/examples/#dab-configuration","title":"DAB+ Configuration","text":"<p>Use case: All services using HE-AAC v2 (DAB+) for maximum efficiency.</p> <p>File: <code>dabplus_only.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE20'\n  ecc: '0xE2'  # UK\n  label:\n    text: 'DAB+ Network'\n    short: 'DAB+Net'\n\nsubchannels:\n  # Speech/news - low bitrate\n  - uid: 'news'\n    id: 0\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 0\n    protection:\n      level: 2\n    input: 'file://news.aac'\n\n  # Music station 1\n  - uid: 'music1'\n    id: 1\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 100\n    protection:\n      level: 2\n    input: 'file://music1.aac'\n\n  # Music station 2\n  - uid: 'music2'\n    id: 2\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 200\n    protection:\n      level: 2\n    input: 'file://music2.aac'\n\n  # Premium music - high quality\n  - uid: 'premium'\n    id: 3\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 300\n    protection:\n      level: 3\n    input: 'file://premium.aac'\n\nservices:\n  - uid: 'news_svc'\n    id: '0x6001'\n    label:\n      text: 'News Radio'\n      short: 'News'\n    pty: 1\n    language: 9\n\n  - uid: 'music1_svc'\n    id: '0x6002'\n    label:\n      text: 'Pop Hits'\n      short: 'PopHits'\n    pty: 10\n    language: 9\n\n  - uid: 'music2_svc'\n    id: '0x6003'\n    label:\n      text: 'Rock Radio'\n      short: 'Rock'\n    pty: 11\n    language: 9\n\n  - uid: 'premium_svc'\n    id: '0x6004'\n    label:\n      text: 'Premium Music'\n      short: 'Premium'\n    pty: 10\n    language: 9\n\ncomponents:\n  - uid: 'news_comp'\n    service_id: '0x6001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'music1_comp'\n    service_id: '0x6002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'music2_comp'\n    service_id: '0x6003'\n    subchannel_id: 2\n    type: 0\n\n  - uid: 'premium_comp'\n    service_id: '0x6004'\n    subchannel_id: 3\n    type: 0\n</code></pre> <p>Key points: - All DAB+ (HE-AAC v2) for efficiency - 48 kbps for speech (excellent quality) - 72 kbps for standard music (good quality) - 96 kbps for premium music (excellent quality) - Fits 4 services with low capacity usage</p> <p>Capacity: ~250 CU total (plenty of room for more services)</p> <p>Encoding commands: <pre><code># Speech (48 kbps)\nffmpeg -i input.wav -c:a aac -b:a 48k -profile:a aac_he_v2 news.aac\n\n# Music (72 kbps)\nffmpeg -i input.wav -c:a aac -b:a 72k -profile:a aac_he_v2 music.aac\n\n# Premium (96 kbps)\nffmpeg -i input.wav -c:a aac -b:a 96k -profile:a aac_he_v2 premium.aac\n</code></pre></p>"},{"location":"user-guide/configuration/examples/#network-streaming","title":"Network Streaming","text":"<p>Use case: Live streaming from remote encoders via UDP/TCP.</p> <p>File: <code>network_streaming.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE30'\n  label:\n    text: 'Live Network'\n    short: 'LiveNet'\n\nsubchannels:\n  # UDP multicast input\n  - uid: 'live_music'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 3  # Higher protection for network\n    input: 'udp://239.1.2.3:5001'\n\n  # UDP unicast input\n  - uid: 'live_news'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    start_address: 100\n    protection:\n      level: 2\n    input: 'udp://192.168.1.100:5002'\n\n  # TCP input (reliable)\n  - uid: 'live_talk'\n    id: 2\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 200\n    protection:\n      level: 2\n    input: 'tcp://192.168.1.101:5003'\n\nservices:\n  - uid: 'music_svc'\n    id: '0x7001'\n    label:\n      text: 'Live Music'\n    pty: 10\n    language: 9\n\n  - uid: 'news_svc'\n    id: '0x7002'\n    label:\n      text: 'Live News'\n    pty: 1\n    language: 9\n\n  - uid: 'talk_svc'\n    id: '0x7003'\n    label:\n      text: 'Talk Radio'\n    pty: 9  # Varied Speech\n    language: 9\n\ncomponents:\n  - uid: 'music_comp'\n    service_id: '0x7001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'news_comp'\n    service_id: '0x7002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'talk_comp'\n    service_id: '0x7003'\n    subchannel_id: 2\n    type: 0\n</code></pre> <p>Key points: - UDP multicast for distribution - UDP unicast for point-to-point - TCP for guaranteed delivery - Higher protection compensates for network issues</p> <p>Network setup:</p> <p>Sender (encoder): <pre><code># Send to UDP multicast\nffmpeg -re -i input.wav -c:a mp2 -b:a 128k -f mp2 udp://239.1.2.3:5001\n\n# Send to UDP unicast\nffmpeg -re -i input.wav -c:a aac -b:a 64k udp://192.168.1.200:5002\n\n# Send to TCP\nffmpeg -re -i input.wav -c:a aac -b:a 48k -f mp2 tcp://192.168.1.200:5003\n</code></pre></p> <p>Receiver (multiplexer): <pre><code>python -m dabmux.cli -c network_streaming.yaml -o live.eti\n</code></pre></p> <p>Troubleshooting: - Firewall: Allow UDP/TCP ports - Multicast: Enable IGMP on routers - Buffer: Use --continuous mode for live streaming</p>"},{"location":"user-guide/configuration/examples/#mixed-dabdab","title":"Mixed DAB/DAB+","text":"<p>Use case: Legacy DAB receivers alongside newer DAB+ receivers.</p> <p>File: <code>mixed_dab_dabplus.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE40'\n  label:\n    text: 'Mixed Network'\n\nsubchannels:\n  # Legacy DAB for old receivers\n  - uid: 'dab_main'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n    input: 'file://main.mp2'\n\n  # DAB+ for new receivers (efficient)\n  - uid: 'dabplus_1'\n    id: 1\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 100\n    protection:\n      level: 2\n    input: 'file://station1.aac'\n\n  - uid: 'dabplus_2'\n    id: 2\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 200\n    protection:\n      level: 2\n    input: 'file://station2.aac'\n\nservices:\n  - uid: 'main_svc'\n    id: '0x8001'\n    label:\n      text: 'Main Station'\n      short: 'Main'\n    pty: 10\n    language: 9\n\n  - uid: 'station1_svc'\n    id: '0x8002'\n    label:\n      text: 'Station One'\n      short: 'Stn1'\n    pty: 10\n    language: 9\n\n  - uid: 'station2_svc'\n    id: '0x8003'\n    label:\n      text: 'Station Two'\n      short: 'Stn2'\n    pty: 1\n    language: 9\n\ncomponents:\n  - uid: 'main_comp'\n    service_id: '0x8001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'station1_comp'\n    service_id: '0x8002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'station2_comp'\n    service_id: '0x8003'\n    subchannel_id: 2\n    type: 0\n</code></pre> <p>Key points: - One DAB service for legacy compatibility - Multiple DAB+ services for efficiency - Balances compatibility vs. capacity</p> <p>Capacity comparison: - DAB 128 kbps @ level 2: ~84 CU - DAB+ 72 kbps @ level 2: ~60 CU each - Total: ~204 CU (leaves room for more)</p>"},{"location":"user-guide/configuration/examples/#high-protection-weak-signal","title":"High Protection (Weak Signal)","text":"<p>Use case: Coverage at edge of broadcast area or mobile reception.</p> <p>File: <code>high_protection.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE50'\n  label:\n    text: 'Rural Coverage'\n    short: 'Rural'\n\nsubchannels:\n  # Critical news service - maximum protection\n  - uid: 'emergency_news'\n    id: 0\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 0\n    protection:\n      level: 4  # Maximum protection\n      shortform: true\n    input: 'file://emergency.aac'\n\n  # Main music - strong protection\n  - uid: 'music'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    start_address: 100\n    protection:\n      level: 3  # Strong protection\n      shortform: true\n    input: 'file://music.aac'\n\nservices:\n  - uid: 'emergency_svc'\n    id: '0x9001'\n    label:\n      text: 'Emergency Info'\n      short: 'EmergInf'\n    pty: 31  # Alarm\n    language: 9\n\n  - uid: 'music_svc'\n    id: '0x9002'\n    label:\n      text: 'Radio Station'\n      short: 'Radio'\n    pty: 10\n    language: 9\n\ncomponents:\n  - uid: 'emergency_comp'\n    service_id: '0x9001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'music_comp'\n    service_id: '0x9002'\n    subchannel_id: 1\n    type: 0\n</code></pre> <p>Key points: - Protection level 4 for critical content - Protection level 3 for important content - Lower bitrates to compensate for protection overhead - Suitable for weak signal areas</p> <p>Signal strength guidelines: - &lt; 40 dB\u03bcV: Use level 4 - 40-60 dB\u03bcV: Use level 3 - 60-80 dB\u03bcV: Use level 2</p>"},{"location":"user-guide/configuration/examples/#maximum-capacity-strong-signal","title":"Maximum Capacity (Strong Signal)","text":"<p>Use case: Indoor transmitter or cable distribution with strong signal.</p> <p>File: <code>max_capacity.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE60'\n  label:\n    text: 'Indoor Network'\n\nsubchannels:\n  # Use level 1 protection for maximum capacity\n  - uid: 'svc1'\n    id: 0\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 0\n    protection:\n      level: 1  # Minimal protection\n    input: 'file://station1.aac'\n\n  - uid: 'svc2'\n    id: 1\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 80\n    protection:\n      level: 1\n    input: 'file://station2.aac'\n\n  - uid: 'svc3'\n    id: 2\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 160\n    protection:\n      level: 1\n    input: 'file://station3.aac'\n\n  - uid: 'svc4'\n    id: 3\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 240\n    protection:\n      level: 1\n    input: 'file://station4.aac'\n\n  - uid: 'svc5'\n    id: 4\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 320\n    protection:\n      level: 1\n    input: 'file://station5.aac'\n\n  - uid: 'svc6'\n    id: 5\n    type: 'dabplus'\n    bitrate: 96\n    start_address: 400\n    protection:\n      level: 1\n    input: 'file://station6.aac'\n\nservices:\n  - uid: 'svc1_service'\n    id: '0xA001'\n    label:\n      text: 'Station 1'\n    pty: 10\n    language: 9\n\n  - uid: 'svc2_service'\n    id: '0xA002'\n    label:\n      text: 'Station 2'\n    pty: 10\n    language: 9\n\n  - uid: 'svc3_service'\n    id: '0xA003'\n    label:\n      text: 'Station 3'\n    pty: 1\n    language: 9\n\n  - uid: 'svc4_service'\n    id: '0xA004'\n    label:\n      text: 'Station 4'\n    pty: 10\n    language: 9\n\n  - uid: 'svc5_service'\n    id: '0xA005'\n    label:\n      text: 'Station 5'\n    pty: 11\n    language: 9\n\n  - uid: 'svc6_service'\n    id: '0xA006'\n    label:\n      text: 'Station 6'\n    pty: 14\n    language: 9\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0xA001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'comp2'\n    service_id: '0xA002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'comp3'\n    service_id: '0xA003'\n    subchannel_id: 2\n    type: 0\n\n  - uid: 'comp4'\n    service_id: '0xA004'\n    subchannel_id: 3\n    type: 0\n\n  - uid: 'comp5'\n    service_id: '0xA005'\n    subchannel_id: 4\n    type: 0\n\n  - uid: 'comp6'\n    service_id: '0xA006'\n    subchannel_id: 5\n    type: 0\n</code></pre> <p>Key points: - Protection level 1 (minimal overhead) - 6 services at 96 kbps each - Maximum service count for strong signal - Total capacity: ~480 CU</p> <p>Use only when: - Indoor transmitter - Cable distribution - Very strong signal (&gt; 80 dB\u03bcV) - Controlled environment</p>"},{"location":"user-guide/configuration/examples/#indoorlocal-transmitter","title":"Indoor/Local Transmitter","text":"<p>Use case: Small coverage area with excellent signal strength.</p> <p>File: <code>indoor_transmitter.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE70'\n  transmission_mode: 'II'  # Mode II for local/indoor\n  label:\n    text: 'Indoor DAB'\n    short: 'Indoor'\n\nsubchannels:\n  # Mode II has 216 CU capacity\n  - uid: 'local1'\n    id: 0\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 0\n    protection:\n      level: 1  # Light protection OK indoors\n    input: 'file://local1.aac'\n\n  - uid: 'local2'\n    id: 1\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 60\n    protection:\n      level: 1\n    input: 'file://local2.aac'\n\n  - uid: 'local3'\n    id: 2\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 120\n    protection:\n      level: 1\n    input: 'file://local3.aac'\n\nservices:\n  - uid: 'local1_svc'\n    id: '0xB001'\n    label:\n      text: 'Local Music'\n    pty: 10\n    language: 9\n\n  - uid: 'local2_svc'\n    id: '0xB002'\n    label:\n      text: 'Local News'\n    pty: 1\n    language: 9\n\n  - uid: 'local3_svc'\n    id: '0xB003'\n    label:\n      text: 'Local Talk'\n    pty: 9\n    language: 9\n\ncomponents:\n  - uid: 'comp1'\n    service_id: '0xB001'\n    subchannel_id: 0\n    type: 0\n\n  - uid: 'comp2'\n    service_id: '0xB002'\n    subchannel_id: 1\n    type: 0\n\n  - uid: 'comp3'\n    service_id: '0xB003'\n    subchannel_id: 2\n    type: 0\n</code></pre> <p>Key points: - Mode II transmission (384 kHz bandwidth) - 216 CU total capacity (vs. 864 in Mode I) - Light protection suitable for strong indoor signal - 3 services fit comfortably</p> <p>Transmission modes: - Mode I (1536 kHz): 864 CU - Standard terrestrial - Mode II (384 kHz): 216 CU - Local/indoor - Mode III (192 kHz): 108 CU - Cable - Mode IV (768 kHz): 432 CU - Regional</p>"},{"location":"user-guide/configuration/examples/#edi-output-configuration","title":"EDI Output Configuration","text":"<p>Use case: Network distribution to transmitter via EDI protocol.</p> <p>File: <code>edi_output.yaml</code></p> <pre><code>ensemble:\n  id: '0xCE80'\n  label:\n    text: 'EDI Network'\n\nsubchannels:\n  - uid: 'main_audio'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n    input: 'file://audio.mp2'\n\nservices:\n  - uid: 'main_service'\n    id: '0xC001'\n    label:\n      text: 'Main Station'\n    pty: 10\n    language: 9\n\ncomponents:\n  - uid: 'main_comp'\n    service_id: '0xC001'\n    subchannel_id: 0\n    type: 0\n</code></pre> <p>Run with EDI output:</p> <pre><code># Basic EDI over UDP\npython -m dabmux.cli \\\n  -c edi_output.yaml \\\n  --edi udp://192.168.1.100:12000\n\n# EDI with PFT (fragmentation and FEC)\npython -m dabmux.cli \\\n  -c edi_output.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 2 \\\n  --pft-fec-m 3 \\\n  --pft-fragment-size 512\n\n# Save ETI file AND send EDI\npython -m dabmux.cli \\\n  -c edi_output.yaml \\\n  -o archive.eti \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft\n</code></pre> <p>PFT parameters: - <code>--pft</code>: Enable PFT fragmentation - <code>--pft-fec 2</code>: Reed-Solomon FEC depth (0-20) - <code>--pft-fec-m 3</code>: Maximum correctable fragments - <code>--pft-fragment-size 512</code>: Fragment size in bytes</p> <p>Network setup: - Multiplexer sends to: <code>udp://192.168.1.100:12000</code> - Modulator receives on port: <code>12000</code> - Firewall: Allow UDP traffic - MTU: Ensure sufficient for fragment size + overhead</p>"},{"location":"user-guide/configuration/examples/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/configuration/examples/#sequential-service-ids","title":"Sequential Service IDs","text":"<pre><code>services:\n  - id: '0x5001'  # First service\n  - id: '0x5002'  # Second service\n  - id: '0x5003'  # Third service\n</code></pre>"},{"location":"user-guide/configuration/examples/#descriptive-uids","title":"Descriptive UIDs","text":"<pre><code>subchannels:\n  - uid: 'bbc_radio1_audio'  # Good\n  - uid: 'news_24_7'          # Good\n  - uid: 'sub1'               # Avoid\n</code></pre>"},{"location":"user-guide/configuration/examples/#standard-bitrates","title":"Standard Bitrates","text":"<p>DAB (MPEG Layer II): - Speech: 64-96 kbps - Music: 128-160 kbps - Premium: 192 kbps</p> <p>DAB+ (HE-AAC v2): - Speech: 48-56 kbps - Music: 72-80 kbps - Premium: 96 kbps</p>"},{"location":"user-guide/configuration/examples/#protection-by-content-type","title":"Protection by Content Type","text":"<pre><code># Critical content\nprotection:\n  level: 4\n\n# Premium content\nprotection:\n  level: 3\n\n# Standard content\nprotection:\n  level: 2\n\n# Strong signal only\nprotection:\n  level: 1\n</code></pre>"},{"location":"user-guide/configuration/examples/#validation-checklist","title":"Validation Checklist","text":"<p>Before running your configuration:</p> <ul> <li> Unique IDs: All service IDs and subchannel IDs are unique</li> <li> Label length: Ensemble and service labels \u2264 16 chars</li> <li> Short labels: \u2264 8 chars (or omit for auto-generation)</li> <li> Hex format: All IDs use quoted hex: <code>'0xXXXX'</code></li> <li> Capacity: Total CU usage &lt; mode capacity (864 for Mode I)</li> <li> File paths: Input files exist and are correct format</li> <li> Type match: File format matches subchannel type</li> <li> Protection range: Protection level 0-4</li> <li> Component links: All services linked to subchannels</li> <li> PTY codes: Valid PTY codes (0-31)</li> <li> Language codes: Valid language codes</li> <li> Start addresses: No overlap between subchannels</li> </ul>"},{"location":"user-guide/configuration/examples/#testing-configurations","title":"Testing Configurations","text":""},{"location":"user-guide/configuration/examples/#validate-syntax","title":"Validate Syntax","text":"<pre><code># Check YAML syntax\npython -c \"import yaml; yaml.safe_load(open('config.yaml'))\"\n\n# Dry run (parse config only)\npython -m dabmux.cli -c config.yaml -o /dev/null -n 1\n</code></pre>"},{"location":"user-guide/configuration/examples/#test-output","title":"Test Output","text":"<pre><code># Generate 100 frames\npython -m dabmux.cli -c config.yaml -o test.eti -n 100\n\n# Check output size\nls -lh test.eti\n\n# Continuous generation\npython -m dabmux.cli -c config.yaml -o output.eti --continuous\n</code></pre>"},{"location":"user-guide/configuration/examples/#verify-capacity","title":"Verify Capacity","text":"<pre><code># The multiplexer will warn if capacity exceeded\n# Check logs for warnings:\n# \"WARNING: Total capacity exceeds available CUs\"\n</code></pre>"},{"location":"user-guide/configuration/examples/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/configuration/examples/#capacity-exceeded-error","title":"\"Capacity exceeded\" Error","text":"<p>Problem: Total subchannel capacity &gt; mode capacity</p> <p>Solution: 1. Reduce bitrates 2. Lower protection levels 3. Remove services 4. Switch to DAB+ (more efficient)</p>"},{"location":"user-guide/configuration/examples/#input-file-not-found","title":"\"Input file not found\"","text":"<p>Problem: File path incorrect</p> <p>Solution: <pre><code># Use absolute paths\ninput: 'file:///home/user/audio.mp2'\n\n# Or relative to working directory\ninput: 'file://./audio.mp2'\n</code></pre></p>"},{"location":"user-guide/configuration/examples/#type-mismatch-error","title":"\"Type mismatch\" Error","text":"<p>Problem: File format doesn't match subchannel type</p> <p>Solution: <pre><code># For .mp2 files\ntype: 'audio'\n\n# For .aac files\ntype: 'dabplus'\n</code></pre></p>"},{"location":"user-guide/configuration/examples/#services-not-appearing","title":"Services Not Appearing","text":"<p>Problem: Service not linked to subchannel</p> <p>Solution: <pre><code># Ensure component links service to subchannel\ncomponents:\n  - service_id: '0x5001'  # Must match service id\n    subchannel_id: 0      # Must match subchannel id\n</code></pre></p>"},{"location":"user-guide/configuration/examples/#see-also","title":"See Also","text":"<ul> <li>Ensemble Parameters: Ensemble configuration details</li> <li>Services: Service configuration details</li> <li>Subchannels: Subchannel configuration details</li> <li>Protection Levels: Protection level guide</li> <li>CLI Reference: Command-line options</li> <li>Tutorials: Step-by-step guides</li> </ul>"},{"location":"user-guide/configuration/protection/","title":"Protection Levels","text":"<p>Complete guide to DAB error protection configuration and UEP (Unequal Error Protection).</p>"},{"location":"user-guide/configuration/protection/#overview","title":"Overview","text":"<p>DAB uses UEP (Unequal Error Protection) to protect audio data from transmission errors. Protection adds redundancy but increases capacity usage.</p> <p>Key concepts: - Higher protection = more robust but more capacity used - Protection level: 0 (weakest) to 4 (strongest) - Two forms: Short form and Long form</p>"},{"location":"user-guide/configuration/protection/#protection-configuration","title":"Protection Configuration","text":"<pre><code>subchannels:\n  - protection:\n      level: 2          # Protection level (0-4)\n      shortform: true   # Use short form table\n</code></pre>"},{"location":"user-guide/configuration/protection/#protection-levels_1","title":"Protection Levels","text":""},{"location":"user-guide/configuration/protection/#level-0-weakest-protection","title":"Level 0 - Weakest Protection","text":"<p>Use when: - Very strong signal - Controlled environment - Maximum bitrate needed</p> <p>Characteristics: - Minimal overhead - Least robust - Highest useful bitrate</p> <p>Example: <pre><code>protection:\n  level: 0\n</code></pre></p> <p>Typical scenario: Indoor/cable distribution, very strong signal</p>"},{"location":"user-guide/configuration/protection/#level-1-weak-protection","title":"Level 1 - Weak Protection","text":"<p>Use when: - Strong signal - Good reception area - Some error tolerance acceptable</p> <p>Characteristics: - Low overhead - Basic error correction - High useful bitrate</p> <p>Example: <pre><code>protection:\n  level: 1\n</code></pre></p> <p>Typical scenario: Good coverage area, wired distribution</p>"},{"location":"user-guide/configuration/protection/#level-2-moderate-protection-default","title":"Level 2 - Moderate Protection (Default)","text":"<p>Use when: - Normal operating conditions - General broadcast - Standard signal strength</p> <p>Characteristics: - Balanced overhead/protection - Good error correction - Standard bitrate</p> <p>Example: <pre><code>protection:\n  level: 2  # Default and recommended\n</code></pre></p> <p>Typical scenario: Standard terrestrial broadcasting, most use cases</p> <p>Recommendation: Use level 2 for most services.</p>"},{"location":"user-guide/configuration/protection/#level-3-strong-protection","title":"Level 3 - Strong Protection","text":"<p>Use when: - Weak signal areas - Edge of coverage - Premium/important content</p> <p>Characteristics: - Higher overhead - Strong error correction - Lower useful bitrate</p> <p>Example: <pre><code>protection:\n  level: 3\n</code></pre></p> <p>Typical scenario: Weak signal areas, fringe coverage, mobile reception</p>"},{"location":"user-guide/configuration/protection/#level-4-strongest-protection","title":"Level 4 - Strongest Protection","text":"<p>Use when: - Very weak signals - Critical data services - Maximum robustness needed</p> <p>Characteristics: - Highest overhead - Maximum error correction - Lowest useful bitrate</p> <p>Example: <pre><code>protection:\n  level: 4\n</code></pre></p> <p>Typical scenario: Emergency broadcasts, data services, extreme conditions</p>"},{"location":"user-guide/configuration/protection/#short-form-vs-long-form","title":"Short Form vs Long Form","text":""},{"location":"user-guide/configuration/protection/#short-form-recommended","title":"Short Form (Recommended)","text":"<p>Use: <code>shortform: true</code></p> <p>Characteristics: - Simpler protection scheme - Standard protection tables - Widely supported - Easier to configure</p> <p>Example: <pre><code>protection:\n  level: 2\n  shortform: true  # Recommended\n</code></pre></p> <p>Recommendation: Use short form unless you have specific requirements.</p>"},{"location":"user-guide/configuration/protection/#long-form","title":"Long Form","text":"<p>Use: <code>shortform: false</code></p> <p>Characteristics: - More flexible protection - Custom protection tables - Advanced use cases - More complex</p> <p>Example: <pre><code>protection:\n  level: 2\n  shortform: false\n</code></pre></p> <p>Use cases: Specialized applications, custom protection profiles</p>"},{"location":"user-guide/configuration/protection/#capacity-impact","title":"Capacity Impact","text":"<p>Protection level affects Capacity Unit (CU) usage.</p>"},{"location":"user-guide/configuration/protection/#example-128-kbps-audio-mode-i","title":"Example: 128 kbps Audio (Mode I)","text":"Protection CUs Used Overhead Useful Data Level 0 ~70 Lowest Maximum Level 1 ~75 Low High Level 2 ~84 Medium Standard Level 3 ~95 High Lower Level 4 ~110 Highest Lowest <p>Trade-off: Higher protection = fewer services fit in ensemble</p>"},{"location":"user-guide/configuration/protection/#capacity-calculation-example","title":"Capacity Calculation Example","text":"<p>Mode I total capacity: 864 CU</p> <p>Scenario 1: Level 2 protection (84 CU per 128 kbps service) - Max services: 864 / 84 \u2248 10 services</p> <p>Scenario 2: Level 3 protection (95 CU per 128 kbps service) - Max services: 864 / 95 \u2248 9 services</p> <p>Impact: Higher protection = fewer services possible</p>"},{"location":"user-guide/configuration/protection/#choosing-protection-level","title":"Choosing Protection Level","text":""},{"location":"user-guide/configuration/protection/#decision-matrix","title":"Decision Matrix","text":"Scenario Recommended Level Reasoning Indoor/cable 0-1 Strong signal, controlled Urban coverage 2 Standard conditions Suburban 2-3 Variable signal Rural/edge 3-4 Weak signal Mobile reception 3 Variable conditions Data services 3-4 Less tolerance for errors Emergency 4 Maximum reliability"},{"location":"user-guide/configuration/protection/#signal-strength-guidelines","title":"Signal Strength Guidelines","text":"<p>Strong signal (&gt;80 dB\\u00b5V): - Level 1-2 - Indoor/local transmitters - Cable distribution</p> <p>Medium signal (60-80 dB\\u00b5V): - Level 2 (default) - Most broadcast scenarios - Standard coverage</p> <p>Weak signal (40-60 dB\\u00b5V): - Level 3 - Edge of coverage - Obstructed areas</p> <p>Very weak signal (&lt;40 dB\\u00b5V): - Level 4 - Fringe reception - Maximum reach</p>"},{"location":"user-guide/configuration/protection/#examples-by-content-type","title":"Examples by Content Type","text":""},{"location":"user-guide/configuration/protection/#music-service-high-quality","title":"Music Service (High Quality)","text":"<pre><code>subchannels:\n  - uid: 'music_premium'\n    type: 'audio'\n    bitrate: 192\n    protection:\n      level: 3  # Strong protection for premium content\n      shortform: true\n</code></pre> <p>Reasoning: High-quality music deserves robust protection.</p>"},{"location":"user-guide/configuration/protection/#news-service-speech","title":"News Service (Speech)","text":"<pre><code>subchannels:\n  - uid: 'news_service'\n    type: 'dabplus'\n    bitrate: 48\n    protection:\n      level: 2  # Standard protection\n      shortform: true\n</code></pre> <p>Reasoning: Speech is more tolerant of errors than music.</p>"},{"location":"user-guide/configuration/protection/#data-service","title":"Data Service","text":"<pre><code>subchannels:\n  - uid: 'data_service'\n    type: 'packet'\n    bitrate: 32\n    protection:\n      level: 4  # Maximum protection for data\n      shortform: true\n</code></pre> <p>Reasoning: Data requires error-free transmission.</p>"},{"location":"user-guide/configuration/protection/#indoor-transmitter","title":"Indoor Transmitter","text":"<pre><code>subchannels:\n  - uid: 'indoor_service'\n    type: 'audio'\n    bitrate: 128\n    protection:\n      level: 1  # Light protection, strong signal\n      shortform: true\n</code></pre> <p>Reasoning: Controlled environment, strong signal.</p>"},{"location":"user-guide/configuration/protection/#protection-and-bitrate-combinations","title":"Protection and Bitrate Combinations","text":""},{"location":"user-guide/configuration/protection/#recommended-combinations","title":"Recommended Combinations","text":"<p>DAB (MPEG Layer II):</p> Bitrate Normal Use Weak Signal 128 kbps Level 2 Level 3 160 kbps Level 2 Level 3 192 kbps Level 2-3 Level 3-4 <p>DAB+ (HE-AAC v2):</p> Bitrate Normal Use Weak Signal 48 kbps Level 2 Level 3 64 kbps Level 2 Level 3 72 kbps Level 2 Level 2-3 96 kbps Level 2-3 Level 3"},{"location":"user-guide/configuration/protection/#multi-service-configuration","title":"Multi-Service Configuration","text":"<p>Balance protection across services:</p> <pre><code>subchannels:\n  # Premium music - higher protection\n  - uid: 'music_premium'\n    bitrate: 192\n    protection:\n      level: 3\n      shortform: true\n\n  # Standard music - normal protection\n  - uid: 'music_standard'\n    bitrate: 128\n    protection:\n      level: 2\n      shortform: true\n\n  # News - standard protection\n  - uid: 'news'\n    bitrate: 64\n    protection:\n      level: 2\n      shortform: true\n\n  # Data - maximum protection\n  - uid: 'data'\n    bitrate: 32\n    protection:\n      level: 4\n      shortform: true\n</code></pre> <p>Strategy: - Premium content: Higher protection - Standard content: Level 2 - Data services: Maximum protection</p>"},{"location":"user-guide/configuration/protection/#testing-protection-levels","title":"Testing Protection Levels","text":""},{"location":"user-guide/configuration/protection/#simulate-weak-signal","title":"Simulate Weak Signal","text":"<p>Test different protection levels:</p> <pre><code># Level 2 (default)\npython -m dabmux.cli -c config_level2.yaml -o output.eti\n\n# Level 3 (stronger)\npython -m dabmux.cli -c config_level3.yaml -o output.eti\n</code></pre> <p>Compare output quality in different conditions.</p>"},{"location":"user-guide/configuration/protection/#monitor-error-rates","title":"Monitor Error Rates","text":"<p>In production, monitor: - Bit error rate (BER) - Frame error rate (FER) - Audio quality metrics</p> <p>Adjust protection based on observed errors.</p>"},{"location":"user-guide/configuration/protection/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/configuration/protection/#capacity-exceeded","title":"Capacity exceeded","text":"<p>Error: <pre><code>ERROR: Total capacity exceeds available CUs\n</code></pre></p> <p>Solution: Lower protection levels <pre><code># From level 3\nprotection:\n  level: 2  # Use level 2 instead\n</code></pre></p>"},{"location":"user-guide/configuration/protection/#excessive-errors","title":"Excessive errors","text":"<p>Problem: Audio dropouts, poor quality</p> <p>Solution: Increase protection <pre><code># From level 2\nprotection:\n  level: 3  # Increase to level 3\n</code></pre></p>"},{"location":"user-guide/configuration/protection/#wrong-form-selected","title":"Wrong form selected","text":"<p>Problem: Receiver doesn't decode properly</p> <p>Solution: Use short form (widely compatible) <pre><code>protection:\n  shortform: true  # Use short form\n</code></pre></p>"},{"location":"user-guide/configuration/protection/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/protection/#start-with-level-2","title":"Start with Level 2","text":"<pre><code>protection:\n  level: 2  # Default, suitable for most cases\n  shortform: true\n</code></pre>"},{"location":"user-guide/configuration/protection/#adjust-based-on-testing","title":"Adjust Based on Testing","text":"<ol> <li>Start with level 2</li> <li>Test in target area</li> <li>Increase if errors observed</li> <li>Decrease if capacity needed</li> </ol>"},{"location":"user-guide/configuration/protection/#use-short-form","title":"Use Short Form","text":"<pre><code>protection:\n  shortform: true  # Recommended\n</code></pre> <p>Short form is simpler and widely supported.</p>"},{"location":"user-guide/configuration/protection/#match-protection-to-content-importance","title":"Match Protection to Content Importance","text":"<pre><code># Critical service\nprotection:\n  level: 3-4\n\n# Standard service\nprotection:\n  level: 2\n\n# Low priority\nprotection:\n  level: 1-2\n</code></pre>"},{"location":"user-guide/configuration/protection/#summary","title":"Summary","text":"<p>Protection levels: - 0: Weakest (strong signal only) - 1: Weak (good signal) - 2: Moderate (default, recommended) - 3: Strong (weak signal) - 4: Strongest (maximum robustness)</p> <p>Key points: - Higher protection = more robust but less capacity - Level 2 suitable for most scenarios - Adjust based on signal strength and content importance - Use short form unless specific requirements</p> <p>Trade-off: <pre><code>More Protection \u2194 More Services\n    Level 4     \u2194    Level 0\n    Robust      \u2194    Capacity\n</code></pre></p> <p>Choose based on your priorities!</p>"},{"location":"user-guide/configuration/protection/#see-also","title":"See Also","text":"<ul> <li>Subchannels: Subchannel configuration</li> <li>Capacity Management: Understanding CU usage</li> <li>Examples: Complete configurations with protection</li> </ul>"},{"location":"user-guide/configuration/services/","title":"Service Configuration","text":"<p>Complete reference for service configuration parameters. Services are the radio stations that listeners see.</p>"},{"location":"user-guide/configuration/services/#overview","title":"Overview","text":"<p>Services represent individual radio stations or programs within the ensemble. Each service must be linked to a subchannel via a component.</p> <p>Required fields: - <code>uid</code>: Unique identifier - <code>id</code>: Service ID - <code>label</code>: Service name</p> <p>Optional fields: - <code>pty</code>: Programme Type - <code>language</code>: Language code</p>"},{"location":"user-guide/configuration/services/#service-structure","title":"Service Structure","text":"<pre><code>services:\n  - uid: 'unique_name'\n    id: '0xXXXX'\n    label:\n      text: 'Station Name'\n      short: 'Short'\n    pty: 10\n    language: 9\n</code></pre>"},{"location":"user-guide/configuration/services/#uid-unique-identifier","title":"UID (Unique Identifier)","text":""},{"location":"user-guide/configuration/services/#uid","title":"<code>uid</code>","text":"<p>Internal identifier for the service (not transmitted).</p> <p>Type: String Required: Yes Purpose: Reference this service in components</p> <p>Example: <pre><code>services:\n  - uid: 'bbc_radio1'\n    id: '0x5001'\n</code></pre></p> <p>Guidelines: - Use descriptive names - Must be unique within configuration - Only used internally (not visible to listeners) - Alphanumeric and underscores recommended</p> <p>Good UIDs: <pre><code>uid: 'bbc_radio1'\nuid: 'news_24_7'\nuid: 'classical_music'\n</code></pre></p> <p>Avoid: <pre><code>uid: 'svc1'  # Not descriptive\nuid: '0x5001'  # Confusing with service ID\n</code></pre></p>"},{"location":"user-guide/configuration/services/#service-id","title":"Service ID","text":""},{"location":"user-guide/configuration/services/#id","title":"<code>id</code>","text":"<p>Unique 16-bit identifier transmitted with the service.</p> <p>Type: String (hex) or Integer Format: <code>'0xXXXX'</code> (hex string, quoted) Range: 0x0000 - 0xFFFF Required: Yes</p> <p>Example: <pre><code>services:\n  - id: '0x5001'\n  - id: '0x5002'\n  - id: '0x5003'\n</code></pre></p> <p>Guidelines: - Must be unique within ensemble - Typically starts from 0x5001 - Use sequential IDs for organization - Must be quoted with 0x prefix</p> <p>ID allocation patterns: <pre><code># Sequential (recommended)\nservices:\n  - id: '0x5001'  # First service\n  - id: '0x5002'  # Second service\n  - id: '0x5003'  # Third service\n\n# By category\nservices:\n  - id: '0x6001'  # Music services\n  - id: '0x6002'\n  - id: '0x7001'  # News services\n  - id: '0x7002'\n</code></pre></p> <p>Reserved values: - 0x0000: Reserved - Avoid 0xFFFF</p>"},{"location":"user-guide/configuration/services/#service-label","title":"Service Label","text":""},{"location":"user-guide/configuration/services/#label","title":"<code>label</code>","text":"<p>The name of the service displayed to listeners.</p> <p>Type: Object with <code>text</code> and optional <code>short</code> Required: Yes</p>"},{"location":"user-guide/configuration/services/#labeltext","title":"<code>label.text</code>","text":"<p>Full service/station name.</p> <p>Type: String Max length: 16 characters Character set: EBU Latin Required: Yes</p> <p>Examples: <pre><code># Good labels\nlabel:\n  text: 'BBC Radio 1'     # 11 chars\n  text: 'Classic FM'      # 10 chars\n  text: 'News 24/7'       # 9 chars\n\n# Maximum length\nlabel:\n  text: 'Sixteen Char Svc' # 16 chars - OK\n  text: 'This Is Too Long' # 17 chars - ERROR\n</code></pre></p> <p>Guidelines: - Clear and recognizable - Avoid abbreviations unless necessary - Use proper capitalization - Include station branding</p>"},{"location":"user-guide/configuration/services/#labelshort","title":"<code>label.short</code>","text":"<p>Abbreviated service name for small displays.</p> <p>Type: String Max length: 8 characters Required: No (auto-generated if omitted) Default: First 8 characters of <code>text</code></p> <p>Examples: <pre><code># Manual short label\nlabel:\n  text: 'BBC Radio 1'\n  short: 'BBC R1'  # 6 chars\n\n# Auto-generated (omit short field)\nlabel:\n  text: 'BBC Radio 1'  # short = 'BBC Radi' (first 8)\n</code></pre></p> <p>Abbreviation strategies: <pre><code># Remove spaces\ntext: 'Pop Music Radio'\nshort: 'PopMusic'\n\n# Use initials\ntext: 'Classical Music FM'\nshort: 'CM FM'\n\n# Remove vowels\ntext: 'News Radio'\nshort: 'NwsRadio'\n</code></pre></p>"},{"location":"user-guide/configuration/services/#programme-type-pty","title":"Programme Type (PTY)","text":""},{"location":"user-guide/configuration/services/#pty","title":"<code>pty</code>","text":"<p>Categorizes the service content type.</p> <p>Type: Integer Range: 0 - 31 Default: 0 (None/Undefined) Required: No (but recommended)</p> <p>Standard PTY codes:</p> Code Category Description 0 None Unspecified/varied content 1 News News and current affairs 2 Current Affairs Analysis and discussion 3 Information General information 4 Sport Sports content 5 Education Educational programmes 6 Drama Drama and culture 7 Cultures Arts and culture 8 Science Science programming 9 Varied Speech Talk/variety 10 Pop Music Popular music 11 Rock Music Rock music 12 Easy Listening Easy listening/MOR 13 Light Classical Light classical 14 Serious Classical Classical music 15 Other Music Other musical styles 16 Weather Weather information 17 Finance Business/finance 18 Children's Children's programmes 19 Social Affairs Social issues 20 Religion Religious programming 21 Phone In Call-in shows 22 Travel Travel information 23 Leisure Leisure and hobby 24 Jazz Music Jazz 25 Country Music Country music 26 National Music National/folk music 27 Oldies Music Oldies/retro 28 Folk Music Folk music 29 Documentary Documentaries 30 Alarm Test Emergency test 31 Alarm Emergency broadcast <p>Examples: <pre><code># News station\nservices:\n  - label:\n      text: 'News 24/7'\n    pty: 1  # News\n\n# Music station\nservices:\n  - label:\n      text: 'Pop Hits Radio'\n    pty: 10  # Pop Music\n\n# Classical station\nservices:\n  - label:\n      text: 'Classical FM'\n    pty: 14  # Serious Classical\n\n# Talk radio\nservices:\n  - label:\n      text: 'Talk Radio'\n    pty: 9  # Varied Speech\n</code></pre></p> <p>Purpose: - Helps receivers filter/search stations - Used for \"genre search\" features - Displayed on receiver screens - Important for user experience</p> <p>Choosing PTY: - Select the primary content type - If mixed content, use 0 (None) - Be consistent across similar services</p>"},{"location":"user-guide/configuration/services/#language-code","title":"Language Code","text":""},{"location":"user-guide/configuration/services/#language","title":"<code>language</code>","text":"<p>Indicates the primary language of the service.</p> <p>Type: Integer Range: 0 - 255 Default: 0 (Unknown) Required: No (but recommended)</p> <p>Common language codes:</p> Code Language 0 Unknown/Not applicable 1 Albanian 2 Breton 3 Catalan 4 Croatian 5 Welsh 6 Czech 7 Danish 8 German 9 English 10 Spanish 11 Esperanto 12 Estonian 13 Basque 14 Faroese 15 French 16 Frisian 17 Irish 18 Gaelic 19 Galician 20 Icelandic 21 Italian 22 Lappish 23 Latin 24 Latvian 25 Luxembourgian 26 Lithuanian 27 Hungarian 28 Maltese 29 Dutch 30 Norwegian 31 Occitan 32 Polish 33 Portuguese 34 Romanian 35 Romansh 36 Serbian 37 Slovak 38 Slovene 39 Finnish 40 Swedish 41 Turkish 42 Flemish 43 Walloon <p>Examples: <pre><code># English service\nservices:\n  - label:\n      text: 'BBC Radio 1'\n    language: 9  # English\n\n# French service\nservices:\n  - label:\n      text: 'Radio France'\n    language: 15  # French\n\n# German service\nservices:\n  - label:\n      text: 'Deutschlandfunk'\n    language: 8  # German\n</code></pre></p> <p>Purpose: - Helps receivers filter by language - Used for \"language search\" features - Important for multilingual areas</p>"},{"location":"user-guide/configuration/services/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/configuration/services/#minimal-service","title":"Minimal Service","text":"<pre><code>services:\n  - uid: 'simple_service'\n    id: '0x5001'\n    label:\n      text: 'My Radio'\n</code></pre>"},{"location":"user-guide/configuration/services/#full-service-configuration","title":"Full Service Configuration","text":"<pre><code>services:\n  - uid: 'complete_service'\n    id: '0x5001'\n    label:\n      text: 'BBC Radio 1'\n      short: 'BBC R1'\n    pty: 10       # Pop Music\n    language: 9   # English\n</code></pre>"},{"location":"user-guide/configuration/services/#multiple-services","title":"Multiple Services","text":"<pre><code>services:\n  # News service\n  - uid: 'news_service'\n    id: '0x5001'\n    label:\n      text: 'News 24/7'\n      short: 'News24'\n    pty: 1        # News\n    language: 9   # English\n\n  # Music service\n  - uid: 'music_service'\n    id: '0x5002'\n    label:\n      text: 'Pop Hits Radio'\n      short: 'PopHits'\n    pty: 10       # Pop Music\n    language: 9   # English\n\n  # Classical service\n  - uid: 'classical_service'\n    id: '0x5003'\n    label:\n      text: 'Classical FM'\n      short: 'Classic'\n    pty: 14       # Serious Classical\n    language: 9   # English\n</code></pre>"},{"location":"user-guide/configuration/services/#linking-services-to-subchannels","title":"Linking Services to Subchannels","text":"<p>Services must be linked to subchannels via components:</p> <pre><code>services:\n  - uid: 'radio_one'\n    id: '0x5001'\n    label:\n      text: 'Radio One'\n\ncomponents:\n  - uid: 'radio_one_comp'\n    service_id: '0x5001'    # References service above\n    subchannel_id: 0        # References subchannel\n    type: 0                 # Audio component\n</code></pre> <p>See Components for details.</p>"},{"location":"user-guide/configuration/services/#validation-rules","title":"Validation Rules","text":"<ol> <li> <p>Unique UIDs <pre><code>\u2713 uid: 'service1'\n\u2713 uid: 'service2'\n\u2717 uid: 'service1' (duplicate)\n</code></pre></p> </li> <li> <p>Unique Service IDs <pre><code>\u2713 id: '0x5001'\n\u2713 id: '0x5002'\n\u2717 id: '0x5001' (duplicate)\n</code></pre></p> </li> <li> <p>Label length <pre><code>\u2713 text: 'BBC Radio' (9 chars)\n\u2717 text: 'Very Long Station Name' (23 chars)\n</code></pre></p> </li> <li> <p>PTY range <pre><code>\u2713 pty: 10\n\u2717 pty: 50 (out of range)\n</code></pre></p> </li> <li> <p>Language range <pre><code>\u2713 language: 9\n\u2717 language: 300 (out of range)\n</code></pre></p> </li> </ol>"},{"location":"user-guide/configuration/services/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/configuration/services/#duplicate-service-id","title":"Duplicate service ID","text":"<p>Error: <pre><code>ERROR: Duplicate service ID: 0x5001\n</code></pre></p> <p>Solution: <pre><code>services:\n  - id: '0x5001'  # First service\n  - id: '0x5002'  # Different ID\n</code></pre></p>"},{"location":"user-guide/configuration/services/#service-not-linked","title":"Service not linked","text":"<p>Warning: Service defined but no component links it</p> <p>Solution: <pre><code>services:\n  - uid: 'my_service'\n    id: '0x5001'\n\ncomponents:\n  - service_id: '0x5001'  # Link service\n    subchannel_id: 0\n</code></pre></p>"},{"location":"user-guide/configuration/services/#label-too-long","title":"Label too long","text":"<p>Error: <pre><code>ERROR: Service label exceeds 16 characters\n</code></pre></p> <p>Solution: <pre><code># Shorten the label\nlabel:\n  text: 'Short Name'  # 10 chars - OK\n</code></pre></p>"},{"location":"user-guide/configuration/services/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/services/#descriptive-uids","title":"Descriptive UIDs","text":"<pre><code># Good\nuid: 'bbc_radio1'\nuid: 'classical_fm'\nuid: 'news_24_7'\n\n# Avoid\nuid: 'svc1'\nuid: 'service_a'\n</code></pre>"},{"location":"user-guide/configuration/services/#sequential-ids","title":"Sequential IDs","text":"<pre><code># Organized by number\nservices:\n  - id: '0x5001'\n  - id: '0x5002'\n  - id: '0x5003'\n</code></pre>"},{"location":"user-guide/configuration/services/#always-set-pty-and-language","title":"Always Set PTY and Language","text":"<pre><code>services:\n  - label:\n      text: 'My Station'\n    pty: 10       # Always specify\n    language: 9   # Always specify\n</code></pre>"},{"location":"user-guide/configuration/services/#meaningful-short-labels","title":"Meaningful Short Labels","text":"<pre><code># Good abbreviations\ntext: 'BBC Radio 1'\nshort: 'BBC R1'\n\ntext: 'Classical Music FM'\nshort: 'ClassicFM'\n\n# Avoid\ntext: 'BBC Radio 1'\nshort: 'BBC Radi'  # Auto-truncated, not ideal\n</code></pre>"},{"location":"user-guide/configuration/services/#see-also","title":"See Also","text":"<ul> <li>Ensemble Parameters: Top-level configuration</li> <li>Subchannels: Audio stream configuration</li> <li>Configuration Hierarchy: How services link to subchannels</li> <li>Examples: Complete working configurations</li> </ul>"},{"location":"user-guide/configuration/subchannels/","title":"Subchannel Configuration","text":"<p>Complete reference for subchannel configuration. Subchannels are the actual audio/data streams that carry content.</p>"},{"location":"user-guide/configuration/subchannels/#overview","title":"Overview","text":"<p>Subchannels define the data streams that carry audio or data. Each subchannel must be linked to a service via a component.</p> <p>Required fields: - <code>uid</code>: Unique identifier - <code>id</code>: Subchannel ID - <code>type</code>: Stream type - <code>bitrate</code>: Data rate in kbps - <code>input</code>: Input source URI</p> <p>Optional fields: - <code>start_address</code>: Position in MST - <code>protection</code>: Error protection settings</p>"},{"location":"user-guide/configuration/subchannels/#subchannel-structure","title":"Subchannel Structure","text":"<pre><code>subchannels:\n  - uid: 'unique_name'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://audio.mp2'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#uid-unique-identifier","title":"UID (Unique Identifier)","text":""},{"location":"user-guide/configuration/subchannels/#uid","title":"<code>uid</code>","text":"<p>Internal identifier for the subchannel.</p> <p>Type: String Required: Yes Purpose: Reference in configuration, logging</p> <p>Example: <pre><code>subchannels:\n  - uid: 'music_stream'\n    id: 0\n</code></pre></p> <p>Guidelines: - Descriptive names - Unique within configuration - Internal only (not transmitted)</p>"},{"location":"user-guide/configuration/subchannels/#subchannel-id","title":"Subchannel ID","text":""},{"location":"user-guide/configuration/subchannels/#id","title":"<code>id</code>","text":"<p>Numeric identifier for the subchannel.</p> <p>Type: Integer Range: 0 - 63 Required: Yes</p> <p>Example: <pre><code>subchannels:\n  - id: 0  # First subchannel\n  - id: 1  # Second subchannel\n  - id: 2  # Third subchannel\n</code></pre></p> <p>Guidelines: - Must be unique - Sequential recommended (0, 1, 2, ...) - Referenced by components</p>"},{"location":"user-guide/configuration/subchannels/#subchannel-type","title":"Subchannel Type","text":""},{"location":"user-guide/configuration/subchannels/#type","title":"<code>type</code>","text":"<p>The format of audio/data in the subchannel.</p> <p>Type: String Values: <code>'audio'</code>, <code>'dabplus'</code>, <code>'packet'</code>, <code>'data'</code> Required: Yes</p>"},{"location":"user-guide/configuration/subchannels/#audio-dab-audio-mpeg-layer-ii","title":"<code>'audio'</code> - DAB Audio (MPEG Layer II)","text":"<p>Traditional DAB using MPEG-1 Audio Layer II.</p> <p>Use for: <code>.mp2</code> files Bitrates: 32 - 384 kbps (typical: 128-192 kbps)</p> <pre><code>subchannels:\n  - uid: 'dab_audio'\n    type: 'audio'\n    bitrate: 128\n    input: 'file://audio.mp2'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#dabplus-dab-audio-he-aac-v2","title":"<code>'dabplus'</code> - DAB+ Audio (HE-AAC v2)","text":"<p>Modern DAB+ using HE-AAC v2 codec.</p> <p>Use for: <code>.aac</code> files Bitrates: 32 - 192 kbps (typical: 48-96 kbps)</p> <pre><code>subchannels:\n  - uid: 'dabplus_audio'\n    type: 'dabplus'\n    bitrate: 72\n    input: 'file://audio.aac'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#packet-packet-mode-data","title":"<code>'packet'</code> - Packet Mode Data","text":"<p>Packet mode for data services.</p> <p>Use for: Data services, PAD Bitrates: Variable</p> <pre><code>subchannels:\n  - uid: 'data_service'\n    type: 'packet'\n    bitrate: 32\n    input: 'file://data.bin'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#data-stream-mode-data","title":"<code>'data'</code> - Stream Mode Data","text":"<p>Stream mode for continuous data.</p> <pre><code>subchannels:\n  - uid: 'stream_data'\n    type: 'data'\n    bitrate: 64\n    input: 'file://stream.bin'\n</code></pre> <p>Type selection guide:</p> Content File Format Type MPEG Layer II audio <code>.mp2</code> <code>'audio'</code> HE-AAC audio <code>.aac</code> <code>'dabplus'</code> Packet data <code>.bin</code>, packets <code>'packet'</code> Stream data <code>.bin</code>, stream <code>'data'</code>"},{"location":"user-guide/configuration/subchannels/#bitrate","title":"Bitrate","text":""},{"location":"user-guide/configuration/subchannels/#bitrate_1","title":"<code>bitrate</code>","text":"<p>Data rate in kilobits per second.</p> <p>Type: Integer Unit: kbps Required: Yes</p>"},{"location":"user-guide/configuration/subchannels/#standard-dab-bitrates","title":"Standard DAB Bitrates","text":"<p>For <code>type: 'audio'</code> (MPEG Layer II):</p> Bitrate Quality Use Case 32 kbps Low Mono speech minimum 48 kbps Fair Mono speech 64 kbps Good Mono speech/music 80 kbps Good Stereo speech 96 kbps Good Stereo music 112 kbps Very Good Stereo music 128 kbps Excellent Standard music 160 kbps Excellent High-quality music 192 kbps Premium Premium music 224 kbps Premium Very high quality 256 kbps Premium Exceptional quality <p>Recommended: 128 kbps for music, 64-96 kbps for speech</p>"},{"location":"user-guide/configuration/subchannels/#standard-dab-bitrates_1","title":"Standard DAB+ Bitrates","text":"<p>For <code>type: 'dabplus'</code> (HE-AAC v2):</p> Bitrate Quality Use Case 32 kbps Fair Mono speech 40 kbps Good Mono speech 48 kbps Very Good Stereo speech 56 kbps Very Good Stereo speech/music 64 kbps Excellent Stereo music 72 kbps Excellent Standard music 80 kbps Premium High-quality music 96 kbps Premium Premium music <p>Recommended: 72 kbps for music, 48 kbps for speech</p>"},{"location":"user-guide/configuration/subchannels/#examples","title":"Examples","text":"<pre><code># DAB music station\n- type: 'audio'\n  bitrate: 128\n\n# DAB+ music station (similar quality, lower bitrate)\n- type: 'dabplus'\n  bitrate: 72\n\n# DAB+ speech/news station\n- type: 'dabplus'\n  bitrate: 48\n\n# Premium DAB music\n- type: 'audio'\n  bitrate: 192\n</code></pre> <p>Guidelines: - Higher bitrate = better quality but more capacity used - DAB+ is more efficient: 72 kbps DAB+ \u2248 128 kbps DAB - Match bitrate to content: speech needs less than music - Must match audio file bitrate</p>"},{"location":"user-guide/configuration/subchannels/#start-address","title":"Start Address","text":""},{"location":"user-guide/configuration/subchannels/#start_address","title":"<code>start_address</code>","text":"<p>Position in Main Service Transport (MST) in Capacity Units.</p> <p>Type: Integer Unit: Capacity Units (CU) Range: 0 - 863 (Mode I) Default: Auto-calculated Required: No (recommended to specify)</p> <p>Example: <pre><code>subchannels:\n  - id: 0\n    start_address: 0    # First subchannel\n  - id: 1\n    start_address: 100  # After subchannel 0\n  - id: 2\n    start_address: 200  # After subchannel 1\n</code></pre></p> <p>Calculation: - First subchannel: <code>start_address: 0</code> - Subsequent: Start after previous subchannel - Spacing depends on bitrate + protection overhead</p> <p>Simplified approach: Use multiples of 50 or 100 for spacing.</p> <p>Mode I capacity: 864 CU total</p>"},{"location":"user-guide/configuration/subchannels/#protection","title":"Protection","text":""},{"location":"user-guide/configuration/subchannels/#protection_1","title":"<code>protection</code>","text":"<p>Error protection configuration.</p> <p>Type: Object with <code>level</code> and <code>shortform</code> Required: No Default: <code>{level: 2, shortform: true}</code></p>"},{"location":"user-guide/configuration/subchannels/#protectionlevel","title":"<code>protection.level</code>","text":"<p>Protection level (0-4).</p> <p>Type: Integer Range: 0 - 4 Default: 2</p> Level Protection Overhead Use Case 0 Weakest Lowest Strong signal only 1 Weak Low Good signal 2 Moderate Medium Normal conditions (default) 3 Strong High Weak signal 4 Strongest Highest Very weak signal <p>Example: <pre><code>protection:\n  level: 2  # Moderate (recommended)\n</code></pre></p>"},{"location":"user-guide/configuration/subchannels/#protectionshortform","title":"<code>protection.shortform</code>","text":"<p>Use short form protection table.</p> <p>Type: Boolean Values: <code>true</code>, <code>false</code> Default: <code>true</code></p> <pre><code>protection:\n  level: 2\n  shortform: true  # Use short form table\n</code></pre> <p>Recommendation: Use <code>shortform: true</code> (simpler, widely supported)</p> <p>See Protection Levels for detailed explanation.</p>"},{"location":"user-guide/configuration/subchannels/#input","title":"Input","text":""},{"location":"user-guide/configuration/subchannels/#input_1","title":"<code>input</code>","text":"<p>Source of audio/data for the subchannel.</p> <p>Type: String (URI) Format: <code>protocol://path</code> Required: Yes</p>"},{"location":"user-guide/configuration/subchannels/#file-inputs","title":"File Inputs","text":"<p>Format: <code>file://path</code></p> <pre><code># Relative path\ninput: 'file://audio.mp2'\n\n# Absolute path (Linux/macOS)\ninput: 'file:///home/user/audio.mp2'\n\n# Absolute path (Windows)\ninput: 'file://C:/Users/user/audio.mp2'\n</code></pre> <p>Guidelines: - Use absolute paths for production - Relative paths from current directory - Must match subchannel type (.mp2 for audio, .aac for dabplus)</p>"},{"location":"user-guide/configuration/subchannels/#udp-network-inputs","title":"UDP Network Inputs","text":"<p>Format: <code>udp://host:port</code></p> <pre><code># UDP unicast\ninput: 'udp://192.168.1.100:5001'\n\n# UDP multicast\ninput: 'udp://239.1.2.3:5001'\n</code></pre> <p>Use for: Live streaming, network sources</p>"},{"location":"user-guide/configuration/subchannels/#tcp-network-inputs","title":"TCP Network Inputs","text":"<p>Format: <code>tcp://host:port</code></p> <pre><code>input: 'tcp://192.168.1.100:5002'\n</code></pre> <p>Use for: Reliable streaming, lower packet loss tolerance</p>"},{"location":"user-guide/configuration/subchannels/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/configuration/subchannels/#dab-music-service","title":"DAB Music Service","text":"<pre><code>subchannels:\n  - uid: 'music_dab'\n    id: 0\n    type: 'audio'\n    bitrate: 192\n    start_address: 0\n    protection:\n      level: 3\n      shortform: true\n    input: 'file://music.mp2'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#dab-music-service_1","title":"DAB+ Music Service","text":"<pre><code>subchannels:\n  - uid: 'music_dabplus'\n    id: 0\n    type: 'dabplus'\n    bitrate: 72\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://music.aac'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#dab-speech-service","title":"DAB+ Speech Service","text":"<pre><code>subchannels:\n  - uid: 'news_dabplus'\n    id: 0\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'file://news.aac'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#network-input","title":"Network Input","text":"<pre><code>subchannels:\n  - uid: 'live_stream'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 2\n      shortform: true\n    input: 'udp://239.1.2.3:5001'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#multiple-subchannels","title":"Multiple Subchannels","text":"<pre><code>subchannels:\n  # Subchannel 0: High-quality music (DAB)\n  - uid: 'music_hq'\n    id: 0\n    type: 'audio'\n    bitrate: 192\n    start_address: 0\n    protection:\n      level: 3\n    input: 'file://music.mp2'\n\n  # Subchannel 1: News (DAB+)\n  - uid: 'news'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    start_address: 200\n    protection:\n      level: 2\n    input: 'file://news.aac'\n\n  # Subchannel 2: Pop music (DAB+)\n  - uid: 'pop'\n    id: 2\n    type: 'dabplus'\n    bitrate: 80\n    start_address: 300\n    protection:\n      level: 2\n    input: 'file://pop.aac'\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#validation-rules","title":"Validation Rules","text":"<ol> <li> <p>Unique IDs <pre><code>\u2713 id: 0\n\u2713 id: 1\n\u2717 id: 0 (duplicate)\n</code></pre></p> </li> <li> <p>Valid bitrate <pre><code>\u2713 bitrate: 128\n\u2717 bitrate: 150 (not standard)\n</code></pre></p> </li> <li> <p>Type matches input <pre><code>\u2713 type: audio, input: file://audio.mp2\n\u2717 type: audio, input: file://audio.aac (mismatch)\n</code></pre></p> </li> <li> <p>Protection level range <pre><code>\u2713 protection: {level: 2}\n\u2717 protection: {level: 5}\n</code></pre></p> </li> <li> <p>Capacity limits</p> </li> <li>Total CUs must fit in mode capacity (864 for Mode I)</li> </ol>"},{"location":"user-guide/configuration/subchannels/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/configuration/subchannels/#type-mismatch","title":"Type mismatch","text":"<p>Error: <pre><code>ERROR: Expected DAB+ superframe, got MPEG frame\n</code></pre></p> <p>Solution: Match type to file format <pre><code># For .mp2 files\ntype: 'audio'\n\n# For .aac files\ntype: 'dabplus'\n</code></pre></p>"},{"location":"user-guide/configuration/subchannels/#input-not-found","title":"Input not found","text":"<p>Error: <pre><code>ERROR: Input file not found: audio.mp2\n</code></pre></p> <p>Solution: Check path and use <code>file://</code> prefix <pre><code>input: 'file://audio.mp2'\n</code></pre></p>"},{"location":"user-guide/configuration/subchannels/#capacity-exceeded","title":"Capacity exceeded","text":"<p>Error: <pre><code>ERROR: Total capacity exceeds available CUs\n</code></pre></p> <p>Solutions: 1. Reduce bitrates 2. Lower protection levels 3. Remove subchannels 4. Use DAB+ (more efficient)</p>"},{"location":"user-guide/configuration/subchannels/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/subchannels/#use-dab-for-efficiency","title":"Use DAB+ for Efficiency","text":"<pre><code># DAB+: 72 kbps for music\n- type: 'dabplus'\n  bitrate: 72\n\n# Equivalent to DAB: 128 kbps\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#organize-by-id","title":"Organize by ID","text":"<pre><code>subchannels:\n  - id: 0  # First\n  - id: 1  # Second\n  - id: 2  # Third\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#descriptive-uids","title":"Descriptive UIDs","text":"<pre><code>uid: 'music_stream'    # Good\nuid: 'news_64kbps'     # Good\nuid: 'sub1'            # Avoid\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#standard-spacing","title":"Standard Spacing","text":"<pre><code>start_address: 0     # First\nstart_address: 100   # Second\nstart_address: 200   # Third\n</code></pre>"},{"location":"user-guide/configuration/subchannels/#see-also","title":"See Also","text":"<ul> <li>Protection Levels: Detailed protection explanation</li> <li>Services: Linking subchannels to services</li> <li>Configuration Hierarchy: How subchannels fit in</li> <li>Examples: Complete working configurations</li> </ul>"},{"location":"user-guide/inputs/","title":"Input Sources","text":"<p>Overview of input sources for audio and data streams in python-dabmux.</p>"},{"location":"user-guide/inputs/#what-are-inputs","title":"What Are Inputs?","text":"<p>Inputs are the sources of audio or data that feed into subchannels. Each subchannel must have exactly one input source specified via the <code>input</code> URI parameter.</p> <p>Input URI format: <pre><code>protocol://path_or_address\n</code></pre></p>"},{"location":"user-guide/inputs/#available-input-types","title":"Available Input Types","text":"<p>python-dabmux supports three input types:</p> Type Protocol Use Case Example File <code>file://</code> Pre-recorded audio files <code>file://audio.mp2</code> UDP <code>udp://</code> Network streaming (multicast/unicast) <code>udp://239.1.2.3:5001</code> TCP <code>tcp://</code> Network streaming (reliable) <code>tcp://192.168.1.100:5002</code>"},{"location":"user-guide/inputs/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/inputs/#file-input","title":"File Input","text":"<pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file://audio.mp2'\n</code></pre>"},{"location":"user-guide/inputs/#udp-input","title":"UDP Input","text":"<pre><code>subchannels:\n  - uid: 'live_stream'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'udp://239.1.2.3:5001'\n</code></pre>"},{"location":"user-guide/inputs/#tcp-input","title":"TCP Input","text":"<pre><code>subchannels:\n  - uid: 'reliable_stream'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'tcp://192.168.1.100:5002'\n</code></pre>"},{"location":"user-guide/inputs/#input-type-selection","title":"Input Type Selection","text":""},{"location":"user-guide/inputs/#file-inputs","title":"File Inputs","text":"<p>Use when: - Testing with pre-recorded content - Scheduled programming - Looped audio playout - Development and debugging</p> <p>Advantages: - Simple and reliable - No network dependencies - Repeatable testing - Easy to manage</p> <p>Limitations: - Static content only - No live streaming - Must prepare files in advance</p> <p>See File Inputs for details.</p>"},{"location":"user-guide/inputs/#udp-inputs","title":"UDP Inputs","text":"<p>Use when: - Live streaming over IP - Multicast distribution - Low-latency required - Multiple receivers</p> <p>Advantages: - Low latency - Multicast support (one-to-many) - Standard streaming protocol - Network efficiency</p> <p>Limitations: - Packet loss possible - No delivery guarantee - Requires network configuration</p> <p>See Network Inputs for details.</p>"},{"location":"user-guide/inputs/#tcp-inputs","title":"TCP Inputs","text":"<p>Use when: - Reliable delivery required - Point-to-point streaming - Network has packet loss - Quality over latency</p> <p>Advantages: - Guaranteed delivery - No packet loss - Error correction built-in - Simple configuration</p> <p>Limitations: - Higher latency than UDP - No multicast support - Single sender/receiver only</p> <p>See Network Inputs for details.</p>"},{"location":"user-guide/inputs/#audio-format-requirements","title":"Audio Format Requirements","text":""},{"location":"user-guide/inputs/#dab-mpeg-layer-ii","title":"DAB (MPEG Layer II)","text":"<p>Subchannel type: <code>'audio'</code></p> <p>File format: MPEG-1 Audio Layer II (<code>.mp2</code>)</p> <p>Encoding: <pre><code>ffmpeg -i input.wav -c:a mp2 -b:a 128k output.mp2\n</code></pre></p> <p>Requirements: - Sample rate: 48 kHz (DAB standard) - Channels: Stereo or mono - Bitrate: Must match subchannel bitrate</p>"},{"location":"user-guide/inputs/#dab-he-aac-v2","title":"DAB+ (HE-AAC v2)","text":"<p>Subchannel type: <code>'dabplus'</code></p> <p>File format: HE-AAC v2 (<code>.aac</code>)</p> <p>Encoding: <pre><code>ffmpeg -i input.wav -c:a aac -b:a 72k -profile:a aac_he_v2 output.aac\n</code></pre></p> <p>Requirements: - Sample rate: 48 kHz (DAB standard) - Profile: HE-AAC v2 - Bitrate: Must match subchannel bitrate</p> <p>See Audio Formats for complete encoding guide.</p>"},{"location":"user-guide/inputs/#input-buffer-management","title":"Input Buffer Management","text":"<p>python-dabmux automatically manages input buffers:</p> <ol> <li>Frame timing: Reads audio data based on ETI frame timing</li> <li>Buffering: Internal buffers smooth out timing variations</li> <li>Underrun handling: Inserts silence if input stalls</li> <li>Overrun prevention: Drops excess data if input too fast</li> </ol> <p>Buffer behavior: - File inputs: Read at frame rate - Network inputs: Buffered for jitter tolerance - Continuous mode: Loops file inputs automatically</p>"},{"location":"user-guide/inputs/#input-configuration-examples","title":"Input Configuration Examples","text":""},{"location":"user-guide/inputs/#multiple-file-inputs","title":"Multiple File Inputs","text":"<pre><code>subchannels:\n  - uid: 'music'\n    id: 0\n    type: 'audio'\n    input: 'file://music.mp2'\n\n  - uid: 'news'\n    id: 1\n    type: 'dabplus'\n    input: 'file://news.aac'\n</code></pre>"},{"location":"user-guide/inputs/#mixed-network-and-file","title":"Mixed Network and File","text":"<pre><code>subchannels:\n  # Live network stream\n  - uid: 'live'\n    id: 0\n    type: 'audio'\n    input: 'udp://239.1.2.3:5001'\n\n  # Pre-recorded backup\n  - uid: 'backup'\n    id: 1\n    type: 'audio'\n    input: 'file://backup.mp2'\n</code></pre>"},{"location":"user-guide/inputs/#multicast-distribution","title":"Multicast Distribution","text":"<pre><code>subchannels:\n  # Encoder sends to multicast group\n  - uid: 'multicast_1'\n    id: 0\n    type: 'audio'\n    input: 'udp://239.1.2.3:5001'\n\n  - uid: 'multicast_2'\n    id: 1\n    type: 'audio'\n    input: 'udp://239.1.2.4:5002'\n</code></pre>"},{"location":"user-guide/inputs/#continuous-mode","title":"Continuous Mode","text":"<p>For live streaming or looped playout, use <code>--continuous</code>:</p> <pre><code>python -m dabmux.cli -c config.yaml -o output.eti --continuous\n</code></pre> <p>Behavior: - File inputs: Loop automatically when reaching end - Network inputs: Continue reading indefinitely - Runs until interrupted (Ctrl+C)</p>"},{"location":"user-guide/inputs/#input-validation","title":"Input Validation","text":"<p>python-dabmux validates inputs:</p> <ol> <li>URI format: Checks protocol and format</li> <li>File existence: Verifies file inputs exist</li> <li>Audio format: Validates format matches type</li> <li>Bitrate match: Ensures file bitrate matches configuration</li> <li>Sample rate: Verifies 48 kHz</li> </ol> <p>Common validation errors:</p> <pre><code>ERROR: Input file not found: audio.mp2\nERROR: Expected MPEG frame, got invalid data\nERROR: Bitrate mismatch: expected 128 kbps, got 192 kbps\n</code></pre>"},{"location":"user-guide/inputs/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/inputs/#file-inputs_1","title":"File Inputs","text":"<ul> <li>I/O: Minimal overhead, disk speed not critical</li> <li>CPU: Negligible</li> <li>Memory: Small buffer per input</li> </ul>"},{"location":"user-guide/inputs/#network-inputs","title":"Network Inputs","text":"<ul> <li>Network: Bitrate \u00d7 1.1 (10% overhead)</li> <li>Latency: UDP: 1-10ms, TCP: 10-50ms</li> <li>Jitter tolerance: ~100ms buffer</li> <li>CPU: Minimal for receiving</li> </ul>"},{"location":"user-guide/inputs/#multiple-inputs","title":"Multiple Inputs","text":"<ul> <li>Scaling: Linear with number of inputs</li> <li>Typical: 10+ inputs easily supported</li> <li>Bottleneck: Usually ETI generation, not inputs</li> </ul>"},{"location":"user-guide/inputs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/inputs/#file-input-issues","title":"File Input Issues","text":"<p>File not found: <pre><code>ERROR: Input file not found: audio.mp2\n</code></pre> Solution: Check path, use absolute paths</p> <p>Wrong format: <pre><code>ERROR: Expected MPEG frame, got AAC\n</code></pre> Solution: Match file format to subchannel type</p> <p>See Input Issues for more.</p>"},{"location":"user-guide/inputs/#network-input-issues","title":"Network Input Issues","text":"<p>No data received: <pre><code>WARNING: Input timeout, inserting silence\n</code></pre> Solution: Check network connectivity, firewall</p> <p>Packet loss: <pre><code>WARNING: Input underrun detected\n</code></pre> Solution: Increase buffer, use TCP, or higher protection</p> <p>See Network Issues for more.</p>"},{"location":"user-guide/inputs/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/inputs/#file-inputs_2","title":"File Inputs","text":"<ol> <li>Absolute paths: Use absolute paths in production</li> <li>Pre-validate: Test files before deployment</li> <li>Backup: Keep backup files for failover</li> <li>Naming: Use descriptive filenames</li> </ol>"},{"location":"user-guide/inputs/#network-inputs_1","title":"Network Inputs","text":"<ol> <li>Dedicated network: Use separate network for streaming</li> <li>Multicast: Prefer multicast for one-to-many</li> <li>Monitoring: Monitor input statistics</li> <li>Redundancy: Have backup inputs configured</li> </ol>"},{"location":"user-guide/inputs/#general","title":"General","text":"<ol> <li>Match bitrates: Ensure file/stream bitrate matches config</li> <li>48 kHz: Always use 48 kHz sample rate</li> <li>Test first: Test with short files before production</li> <li>Monitor logs: Watch for warnings and errors</li> </ol>"},{"location":"user-guide/inputs/#input-statistics","title":"Input Statistics","text":"<p>Enable verbose mode to see input statistics:</p> <pre><code>python -m dabmux.cli -c config.yaml -o output.eti -v\n</code></pre> <p>Statistics shown: - Bytes read per input - Buffer fill levels - Underrun/overrun counts - Network packet statistics</p>"},{"location":"user-guide/inputs/#see-also","title":"See Also","text":"<ul> <li>File Inputs: Detailed file input documentation</li> <li>Network Inputs: UDP/TCP streaming guide</li> <li>Audio Formats: Complete encoding reference</li> <li>Subchannels: Subchannel configuration</li> <li>Tutorials: Step-by-step guides</li> </ul>"},{"location":"user-guide/inputs/audio-formats/","title":"Audio Formats","text":"<p>Complete guide to encoding audio for DAB and DAB+ broadcasting.</p>"},{"location":"user-guide/inputs/audio-formats/#overview","title":"Overview","text":"<p>DAB supports two audio codecs: - MPEG Layer II (traditional DAB) - HE-AAC v2 (DAB+, more efficient)</p> <p>Both require 48 kHz sample rate per DAB standard.</p>"},{"location":"user-guide/inputs/audio-formats/#dab-mpeg-layer-ii","title":"DAB (MPEG Layer II)","text":""},{"location":"user-guide/inputs/audio-formats/#overview_1","title":"Overview","text":"<p>Codec: MPEG-1 Audio Layer II (MP2) Standard: ISO/IEC 11172-3 File extension: <code>.mp2</code> Subchannel type: <code>'audio'</code></p> <p>Characteristics: - Mature, widely supported codec - Good quality at 128+ kbps - Lower efficiency than AAC - Compatible with all DAB receivers</p>"},{"location":"user-guide/inputs/audio-formats/#recommended-bitrates","title":"Recommended Bitrates","text":"Bitrate Quality Use Case 32 kbps Low Mono speech minimum 48 kbps Fair Mono speech 64 kbps Good Mono speech/music 80 kbps Good Stereo speech 96 kbps Good Stereo music 112 kbps Very Good Stereo music 128 kbps Excellent Standard music (recommended) 160 kbps Excellent High-quality music 192 kbps Premium Premium music 224 kbps Premium Very high quality 256 kbps Premium Maximum quality <p>General guidelines: - Music: 128-192 kbps - Speech: 64-96 kbps - Premium: 192+ kbps</p>"},{"location":"user-guide/inputs/audio-formats/#encoding-with-ffmpeg","title":"Encoding with ffmpeg","text":""},{"location":"user-guide/inputs/audio-formats/#basic-encoding","title":"Basic Encoding","text":"<pre><code># Standard quality (128 kbps stereo)\nffmpeg -i input.wav -c:a mp2 -ar 48000 -b:a 128k output.mp2\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#encoding-options","title":"Encoding Options","text":"<p>From WAV file: <pre><code>ffmpeg -i input.wav \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 128k \\\n  output.mp2\n</code></pre></p> <p>From FLAC: <pre><code>ffmpeg -i input.flac \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 192k \\\n  output.mp2\n</code></pre></p> <p>From MP3: <pre><code># Transcoding (quality loss)\nffmpeg -i input.mp3 \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 128k \\\n  output.mp2\n</code></pre></p> <p>Mono speech: <pre><code>ffmpeg -i speech.wav \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -ac 1 \\\n  -b:a 64k \\\n  output.mp2\n</code></pre></p> <p>High quality music: <pre><code>ffmpeg -i music.wav \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 192k \\\n  -q:a 0 \\\n  output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#quality-settings","title":"Quality Settings","text":"<p>Quality scale (-q:a): - <code>-q:a 0</code>: Best quality - <code>-q:a 5</code>: Medium quality - <code>-q:a 9</code>: Lowest quality</p> <pre><code># Maximum quality\nffmpeg -i input.wav \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 192k \\\n  -q:a 0 \\\n  output.mp2\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#batch-encoding","title":"Batch Encoding","text":"<pre><code>#!/bin/bash\n# Encode all WAV files to MPEG Layer II\n\nfor wav in *.wav; do\n    base=$(basename \"$wav\" .wav)\n    ffmpeg -i \"$wav\" \\\n      -c:a mp2 \\\n      -ar 48000 \\\n      -b:a 128k \\\n      \"${base}.mp2\"\ndone\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#dab-he-aac-v2","title":"DAB+ (HE-AAC v2)","text":""},{"location":"user-guide/inputs/audio-formats/#overview_2","title":"Overview","text":"<p>Codec: High-Efficiency Advanced Audio Coding version 2 Standard: ISO/IEC 14496-3 File extension: <code>.aac</code> Subchannel type: <code>'dabplus'</code></p> <p>Characteristics: - Modern, efficient codec - Excellent quality at low bitrates - ~2\u00d7 more efficient than MP2 - Requires DAB+ capable receiver</p>"},{"location":"user-guide/inputs/audio-formats/#recommended-bitrates_1","title":"Recommended Bitrates","text":"Bitrate Quality Use Case 32 kbps Fair Mono speech 40 kbps Good Mono speech 48 kbps Very Good Stereo speech 56 kbps Very Good Stereo speech/music 64 kbps Excellent Stereo music 72 kbps Excellent Standard music (recommended) 80 kbps Premium High-quality music 96 kbps Premium Premium music <p>Efficiency comparison: - 48 kbps HE-AAC \u2248 96 kbps MP2 (speech) - 72 kbps HE-AAC \u2248 128 kbps MP2 (music) - 96 kbps HE-AAC \u2248 160 kbps MP2 (music)</p> <p>General guidelines: - Music: 72-96 kbps - Speech: 48-56 kbps - Premium: 96+ kbps</p>"},{"location":"user-guide/inputs/audio-formats/#encoding-with-ffmpeg_1","title":"Encoding with ffmpeg","text":""},{"location":"user-guide/inputs/audio-formats/#basic-encoding_1","title":"Basic Encoding","text":"<pre><code># Standard quality (72 kbps stereo music)\nffmpeg -i input.wav \\\n  -c:a aac \\\n  -ar 48000 \\\n  -b:a 72k \\\n  -profile:a aac_he_v2 \\\n  output.aac\n</code></pre> <p>Important: Always specify <code>-profile:a aac_he_v2</code> for DAB+</p>"},{"location":"user-guide/inputs/audio-formats/#encoding-options_1","title":"Encoding Options","text":"<p>Speech (48 kbps): <pre><code>ffmpeg -i speech.wav \\\n  -c:a aac \\\n  -ar 48000 \\\n  -b:a 48k \\\n  -profile:a aac_he_v2 \\\n  output.aac\n</code></pre></p> <p>Standard music (72 kbps): <pre><code>ffmpeg -i music.wav \\\n  -c:a aac \\\n  -ar 48000 \\\n  -b:a 72k \\\n  -profile:a aac_he_v2 \\\n  output.aac\n</code></pre></p> <p>Premium music (96 kbps): <pre><code>ffmpeg -i music.wav \\\n  -c:a aac \\\n  -ar 48000 \\\n  -b:a 96k \\\n  -profile:a aac_he_v2 \\\n  output.aac\n</code></pre></p> <p>From various sources: <pre><code># From FLAC\nffmpeg -i input.flac \\\n  -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 \\\n  output.aac\n\n# From MP3 (transcoding)\nffmpeg -i input.mp3 \\\n  -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 \\\n  output.aac\n\n# From ALSA (live capture)\nffmpeg -f alsa -i hw:0 \\\n  -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 \\\n  output.aac\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#batch-encoding_1","title":"Batch Encoding","text":"<pre><code>#!/bin/bash\n# Encode all WAV files to HE-AAC\n\nfor wav in *.wav; do\n    base=$(basename \"$wav\" .wav)\n    ffmpeg -i \"$wav\" \\\n      -c:a aac \\\n      -ar 48000 \\\n      -b:a 72k \\\n      -profile:a aac_he_v2 \\\n      \"${base}.aac\"\ndone\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#audio-processing","title":"Audio Processing","text":""},{"location":"user-guide/inputs/audio-formats/#normalization","title":"Normalization","text":"<p>Loudness normalization (EBU R128 standard): <pre><code>ffmpeg -i input.wav \\\n  -af loudnorm=I=-16:LRA=11:TP=-1.5 \\\n  normalized.wav\n</code></pre></p> <p>Parameters: - <code>I=-16</code>: Target integrated loudness (LUFS) - <code>LRA=11</code>: Loudness range - <code>TP=-1.5</code>: True peak limit</p> <p>Two-pass normalization (more accurate): <pre><code># Pass 1: Measure\nffmpeg -i input.wav \\\n  -af loudnorm=I=-16:LRA=11:TP=-1.5:print_format=json \\\n  -f null -\n\n# Use measured values in pass 2\nffmpeg -i input.wav \\\n  -af loudnorm=I=-16:LRA=11:TP=-1.5:measured_I=-20:measured_LRA=10:measured_TP=-2 \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#resampling","title":"Resampling","text":"<p>Convert sample rate to 48 kHz: <pre><code># High-quality resampling\nffmpeg -i input_44100.wav \\\n  -af aresample=resampler=soxr:osr=48000 \\\n  -ar 48000 \\\n  output_48000.wav\n</code></pre></p> <p>Convert and encode in one step: <pre><code>ffmpeg -i input_44100.wav \\\n  -af aresample=resampler=soxr:osr=48000 \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#channel-mixing","title":"Channel Mixing","text":"<p>Stereo to mono: <pre><code>ffmpeg -i stereo.wav \\\n  -ac 1 \\\n  -c:a mp2 -ar 48000 -b:a 64k \\\n  mono.mp2\n</code></pre></p> <p>Mono to stereo (duplicate): <pre><code>ffmpeg -i mono.wav \\\n  -ac 2 \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  stereo.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#fade-inout","title":"Fade In/Out","text":"<p>Prevent clicks at loop points: <pre><code>ffmpeg -i input.wav \\\n  -af \"afade=t=in:st=0:d=0.1,afade=t=out:st=59.9:d=0.1\" \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  output.mp2\n</code></pre></p> <p>Parameters: - <code>t=in</code>: Fade in - <code>st=0</code>: Start time (seconds) - <code>d=0.1</code>: Duration (seconds)</p>"},{"location":"user-guide/inputs/audio-formats/#compressionlimiting","title":"Compression/Limiting","text":"<p>Dynamic range compression: <pre><code>ffmpeg -i input.wav \\\n  -af \"compand=attacks=0.3:decays=0.8:points=-80/-80|-45/-15|-27/-9|0/-7|20/-7\" \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  output.mp2\n</code></pre></p> <p>Simple limiter: <pre><code>ffmpeg -i input.wav \\\n  -af \"alimiter=limit=0.95:level=false\" \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#quality-comparison","title":"Quality Comparison","text":""},{"location":"user-guide/inputs/audio-formats/#dab-vs-dab","title":"DAB vs DAB+","text":"<p>At equivalent perceived quality:</p> Content DAB (MP2) DAB+ (HE-AAC) Savings Speech 96 kbps 48 kbps 50% Music 128 kbps 72 kbps 44% Premium 192 kbps 96 kbps 50% <p>Capacity comparison (Mode I: 864 CU):</p> Scenario DAB Services DAB+ Services 128/72 kbps music ~10 services ~12 services With protection level 2 10 \u00d7 84 CU 12 \u00d7 60 CU Total capacity used ~840 CU ~720 CU"},{"location":"user-guide/inputs/audio-formats/#listening-tests","title":"Listening Tests","text":"<p>Critical listening quality (music): - 128 kbps MP2: Good, minor artifacts on complex passages - 192 kbps MP2: Excellent, transparent for most listeners - 72 kbps HE-AAC: Very good, comparable to 128 kbps MP2 - 96 kbps HE-AAC: Excellent, comparable to 160+ kbps MP2</p> <p>Speech quality: - 64 kbps MP2: Good - 48 kbps HE-AAC: Excellent (better than 64 kbps MP2) - 96 kbps MP2: Excellent - 56 kbps HE-AAC: Excellent (comparable to 96 kbps MP2)</p>"},{"location":"user-guide/inputs/audio-formats/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"user-guide/inputs/audio-formats/#verify-encoding","title":"Verify Encoding","text":"<p>Check file format: <pre><code>ffprobe -hide_banner output.mp2\n</code></pre></p> <p>Expected output (DAB): <pre><code>Stream #0:0: Audio: mp2, 48000 Hz, stereo, s16p, 128 kb/s\n</code></pre></p> <p>Expected output (DAB+): <pre><code>Stream #0:0: Audio: aac (HE-AACv2), 48000 Hz, stereo, fltp, 72 kb/s\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#validate-parameters","title":"Validate Parameters","text":"<p>Check sample rate: <pre><code>ffprobe -v error -select_streams a:0 \\\n  -show_entries stream=sample_rate \\\n  -of default=noprint_wrappers=1:nokey=1 \\\n  output.mp2\n</code></pre></p> <p>Should output: <code>48000</code></p> <p>Check bitrate: <pre><code>ffprobe -v error -select_streams a:0 \\\n  -show_entries stream=bit_rate \\\n  -of default=noprint_wrappers=1:nokey=1 \\\n  output.mp2\n</code></pre></p> <p>Should output bitrate in bits/s (e.g., <code>128000</code> for 128 kbps)</p> <p>Check duration: <pre><code>ffprobe -v error -show_entries format=duration \\\n  -of default=noprint_wrappers=1:nokey=1 \\\n  output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#test-playback","title":"Test Playback","text":"<p>Play file: <pre><code>ffplay output.mp2\n# or\nffplay output.aac\n</code></pre></p> <p>Analyze audio: <pre><code># Show audio waveform\nffplay -f lavfi \"amovie=output.mp2,asplit[a][b];[a]avectorscope[out0];[b]showwaves[out1]\"\n\n# Show spectrum\nffplay -f lavfi \"amovie=output.mp2,asplit[a][b];[a]showspectrum[out0];[b]showwaves[out1]\"\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/inputs/audio-formats/#wrong-sample-rate","title":"Wrong Sample Rate","text":"<p>Error: <pre><code>ERROR: Expected 48000 Hz, got 44100 Hz\n</code></pre></p> <p>Solution: <pre><code># Resample to 48 kHz\nffmpeg -i input_44100.wav \\\n  -ar 48000 \\\n  -c:a mp2 -b:a 128k \\\n  output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#wrong-codec","title":"Wrong Codec","text":"<p>Error: <pre><code>ERROR: Expected MPEG frame, got AAC superframe\n</code></pre></p> <p>Solution: Check subchannel type matches file format - <code>.mp2</code> files \u2192 <code>type: 'audio'</code> - <code>.aac</code> files \u2192 <code>type: 'dabplus'</code></p>"},{"location":"user-guide/inputs/audio-formats/#bitrate-mismatch","title":"Bitrate Mismatch","text":"<p>Error: <pre><code>ERROR: File bitrate 192 kbps doesn't match configured 128 kbps\n</code></pre></p> <p>Solution: Re-encode at correct bitrate or update configuration</p>"},{"location":"user-guide/inputs/audio-formats/#profile-not-supported","title":"Profile Not Supported","text":"<p>Error: <pre><code>ERROR: AAC profile not HE-AAC v2\n</code></pre></p> <p>Solution: Ensure <code>-profile:a aac_he_v2</code>: <pre><code>ffmpeg -i input.wav \\\n  -c:a aac -ar 48000 -b:a 72k \\\n  -profile:a aac_he_v2 \\\n  output.aac\n</code></pre></p>"},{"location":"user-guide/inputs/audio-formats/#audio-quality-issues","title":"Audio Quality Issues","text":"<p>Problem: Poor audio quality despite high bitrate</p> <p>Diagnosis: <pre><code># Check encoding parameters\nffprobe -hide_banner file.mp2\n\n# Visualize spectrum\nffplay -f lavfi \"amovie=file.mp2,showspectrum\"\n</code></pre></p> <p>Solutions: 1. Use higher bitrate 2. Check source quality (don't transcode lossy) 3. Use proper encoder settings (-q:a 0 for MP2) 4. Ensure 48 kHz sample rate 5. Apply normalization</p>"},{"location":"user-guide/inputs/audio-formats/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/inputs/audio-formats/#source-material","title":"Source Material","text":"<ol> <li>Start with lossless: Use WAV, FLAC, or high-quality source</li> <li>Avoid transcoding: Don't encode from MP3/AAC (quality loss)</li> <li>Match levels: Normalize before encoding</li> <li>48 kHz native: Use 48 kHz sources when possible</li> </ol>"},{"location":"user-guide/inputs/audio-formats/#encoding-settings","title":"Encoding Settings","text":"<ol> <li>DAB music: 128-192 kbps MP2</li> <li>DAB+ music: 72-96 kbps HE-AAC v2</li> <li>Speech: 48-64 kbps (DAB+ preferred)</li> <li>Always 48 kHz: Required by DAB standard</li> <li>Quality flag: Use <code>-q:a 0</code> for MP2</li> </ol>"},{"location":"user-guide/inputs/audio-formats/#testing","title":"Testing","text":"<ol> <li>Validate format: Use ffprobe</li> <li>Test playback: Listen before deployment</li> <li>Check levels: Ensure proper loudness</li> <li>Monitor quality: Watch for artifacts</li> <li>Compare codecs: Test both DAB and DAB+</li> </ol>"},{"location":"user-guide/inputs/audio-formats/#production","title":"Production","text":"<ol> <li>Batch processing: Automate encoding workflows</li> <li>Archive originals: Keep lossless source files</li> <li>Version control: Track encoding settings used</li> <li>Documentation: Document bitrate choices</li> <li>Monitoring: Log encoding statistics</li> </ol>"},{"location":"user-guide/inputs/audio-formats/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/inputs/audio-formats/#music-station-dab","title":"Music Station (DAB)","text":"<pre><code># High-quality music encoding workflow\n# 1. Normalize\nffmpeg -i source.wav \\\n  -af loudnorm=I=-16:LRA=11:TP=-1.5 \\\n  normalized.wav\n\n# 2. Encode to MPEG Layer II\nffmpeg -i normalized.wav \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 192k \\\n  -q:a 0 \\\n  music_192k.mp2\n\n# 3. Verify\nffprobe -hide_banner music_192k.mp2\n\n# 4. Test\nffplay music_192k.mp2\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#music-station-dab_1","title":"Music Station (DAB+)","text":"<pre><code># Efficient music encoding workflow\n# 1. Normalize\nffmpeg -i source.wav \\\n  -af loudnorm=I=-16:LRA=11:TP=-1.5 \\\n  normalized.wav\n\n# 2. Encode to HE-AAC v2\nffmpeg -i normalized.wav \\\n  -c:a aac \\\n  -ar 48000 \\\n  -b:a 72k \\\n  -profile:a aac_he_v2 \\\n  music_72k.aac\n\n# 3. Verify\nffprobe -hide_banner music_72k.aac\n\n# 4. Test\nffplay music_72k.aac\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#speechnews-station","title":"Speech/News Station","text":"<pre><code># Speech-optimized encoding\nffmpeg -i speech.wav \\\n  -af \"loudnorm=I=-16:LRA=11:TP=-1.5,highpass=f=80,lowpass=f=8000\" \\\n  -c:a aac \\\n  -ar 48000 \\\n  -b:a 48k \\\n  -profile:a aac_he_v2 \\\n  speech_48k.aac\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#live-streaming","title":"Live Streaming","text":"<pre><code># Capture from sound card and encode\nffmpeg -f alsa -i hw:0 \\\n  -af \"loudnorm=I=-16:LRA=11:TP=-1.5\" \\\n  -c:a mp2 \\\n  -ar 48000 \\\n  -b:a 128k \\\n  -f mp2 \\\n  udp://239.1.2.3:5001\n</code></pre>"},{"location":"user-guide/inputs/audio-formats/#see-also","title":"See Also","text":"<ul> <li>Input Sources Overview: All input types</li> <li>File Inputs: File-based input guide</li> <li>Network Inputs: Live streaming guide</li> <li>Subchannels: Subchannel configuration</li> <li>DAB+ Tutorial: Step-by-step DAB+ setup</li> </ul>"},{"location":"user-guide/inputs/file-inputs/","title":"File Inputs","text":"<p>Complete guide to using file-based inputs for audio and data streams.</p>"},{"location":"user-guide/inputs/file-inputs/#overview","title":"Overview","text":"<p>File inputs read pre-recorded audio or data from files on disk. They're the simplest input type and ideal for testing, scheduled programming, and looped playout.</p> <p>URI format: <pre><code>file://path/to/file.ext\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#basic-configuration","title":"Basic Configuration","text":""},{"location":"user-guide/inputs/file-inputs/#relative-path","title":"Relative Path","text":"<pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file://audio.mp2'\n</code></pre> <p>Relative to current working directory where dabmux is run.</p>"},{"location":"user-guide/inputs/file-inputs/#absolute-path-linuxmacos","title":"Absolute Path (Linux/macOS)","text":"<pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file:///home/user/dab/audio.mp2'\n</code></pre> <p>Note the three slashes: <code>file:///</code> (protocol + absolute path)</p>"},{"location":"user-guide/inputs/file-inputs/#absolute-path-windows","title":"Absolute Path (Windows)","text":"<pre><code>subchannels:\n  - uid: 'audio1'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file://C:/Users/user/dab/audio.mp2'\n</code></pre> <p>Use forward slashes even on Windows.</p>"},{"location":"user-guide/inputs/file-inputs/#supported-file-formats","title":"Supported File Formats","text":""},{"location":"user-guide/inputs/file-inputs/#mpeg-layer-ii-files-mp2","title":"MPEG Layer II Files (.mp2)","text":"<p>For: DAB audio subchannels</p> <p>Subchannel configuration: <pre><code>type: 'audio'\ninput: 'file://audio.mp2'\n</code></pre></p> <p>Requirements: - Format: MPEG-1 Audio Layer II - Sample rate: 48000 Hz - Bitrate: Must match subchannel bitrate - Channels: Stereo (2 channels) or mono</p> <p>Creating MPEG files: <pre><code># Stereo at 128 kbps\nffmpeg -i input.wav -c:a mp2 -ar 48000 -b:a 128k output.mp2\n\n# Mono at 64 kbps\nffmpeg -i input.wav -c:a mp2 -ar 48000 -ac 1 -b:a 64k output.mp2\n\n# Specific quality\nffmpeg -i input.wav -c:a mp2 -ar 48000 -b:a 160k -q:a 0 output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#he-aac-files-aac","title":"HE-AAC Files (.aac)","text":"<p>For: DAB+ audio subchannels</p> <p>Subchannel configuration: <pre><code>type: 'dabplus'\ninput: 'file://audio.aac'\n</code></pre></p> <p>Requirements: - Format: HE-AAC v2 - Sample rate: 48000 Hz - Bitrate: Must match subchannel bitrate - Profile: aac_he_v2</p> <p>Creating AAC files: <pre><code># Standard quality (72 kbps)\nffmpeg -i input.wav -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 output.aac\n\n# Speech (48 kbps)\nffmpeg -i input.wav -c:a aac -ar 48000 -b:a 48k -profile:a aac_he_v2 output.aac\n\n# Premium (96 kbps)\nffmpeg -i input.wav -c:a aac -ar 48000 -b:a 96k -profile:a aac_he_v2 output.aac\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#raw-binary-data-bin","title":"Raw Binary Data (.bin)","text":"<p>For: Data subchannels</p> <p>Subchannel configuration: <pre><code>type: 'packet'  # or 'data'\ninput: 'file://data.bin'\n</code></pre></p> <p>Requirements: - Raw binary format - Bitrate must be specified - Data rate must match subchannel bitrate</p>"},{"location":"user-guide/inputs/file-inputs/#file-validation","title":"File Validation","text":"<p>python-dabmux validates file inputs:</p>"},{"location":"user-guide/inputs/file-inputs/#format-validation","title":"Format Validation","text":"<pre><code># Test configuration with validation\npython -m dabmux.cli -c config.yaml -o /dev/null -n 1\n</code></pre> <p>Checks performed: 1. File exists and readable 2. Format matches subchannel type (.mp2 for audio, .aac for dabplus) 3. Audio sample rate is 48 kHz 4. Bitrate matches configuration 5. File contains valid frames</p>"},{"location":"user-guide/inputs/file-inputs/#common-validation-errors","title":"Common Validation Errors","text":"<p>File not found: <pre><code>ERROR: Input file not found: audio.mp2\n</code></pre> Solution: Check path, verify file exists</p> <p>Format mismatch: <pre><code>ERROR: Expected MPEG frame, got AAC superframe\n</code></pre> Solution: Match file format to subchannel type</p> <p>Sample rate mismatch: <pre><code>ERROR: Expected 48000 Hz, got 44100 Hz\n</code></pre> Solution: Re-encode at 48 kHz: <pre><code>ffmpeg -i input.mp2 -ar 48000 output.mp2\n</code></pre></p> <p>Bitrate mismatch: <pre><code>ERROR: File bitrate 192 kbps doesn't match configured 128 kbps\n</code></pre> Solution: Re-encode at correct bitrate or update configuration</p>"},{"location":"user-guide/inputs/file-inputs/#looping-and-continuous-playout","title":"Looping and Continuous Playout","text":""},{"location":"user-guide/inputs/file-inputs/#single-run-default","title":"Single Run (Default)","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti -n 1000\n</code></pre> <p>Generates 1000 frames then stops. File is read once.</p>"},{"location":"user-guide/inputs/file-inputs/#continuous-mode","title":"Continuous Mode","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti --continuous\n</code></pre> <p>Behavior: - Reads file from start to end - Automatically loops when reaching EOF - Continues until interrupted (Ctrl+C) - No gaps between loops</p> <p>Use cases: - Test signal playout - Scheduled programming loops - Background music - Emergency announcements</p>"},{"location":"user-guide/inputs/file-inputs/#limited-duration","title":"Limited Duration","text":"<pre><code># Generate 5 minutes (3750 frames at 96ms each)\npython -m dabmux.cli -c config.yaml -o output.eti -n 3750\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#multiple-file-inputs","title":"Multiple File Inputs","text":""},{"location":"user-guide/inputs/file-inputs/#different-file-types","title":"Different File Types","text":"<pre><code>subchannels:\n  # DAB music\n  - uid: 'music_dab'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file://music.mp2'\n\n  # DAB+ news\n  - uid: 'news_dabplus'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    input: 'file://news.aac'\n\n  # DAB+ talk\n  - uid: 'talk_dabplus'\n    id: 2\n    type: 'dabplus'\n    bitrate: 48\n    input: 'file://talk.aac'\n</code></pre> <p>All files loop independently in continuous mode.</p>"},{"location":"user-guide/inputs/file-inputs/#organized-directory-structure","title":"Organized Directory Structure","text":"<pre><code>audio/\n  \u251c\u2500\u2500 music/\n  \u2502   \u251c\u2500\u2500 station1.mp2\n  \u2502   \u2514\u2500\u2500 station2.aac\n  \u251c\u2500\u2500 news/\n  \u2502   \u2514\u2500\u2500 news24.aac\n  \u2514\u2500\u2500 talk/\n      \u2514\u2500\u2500 talk.aac\n</code></pre> <p>Configuration: <pre><code>subchannels:\n  - uid: 'station1'\n    input: 'file://audio/music/station1.mp2'\n\n  - uid: 'station2'\n    input: 'file://audio/music/station2.aac'\n\n  - uid: 'news'\n    input: 'file://audio/news/news24.aac'\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#file-management-best-practices","title":"File Management Best Practices","text":""},{"location":"user-guide/inputs/file-inputs/#production-setup","title":"Production Setup","text":"<ol> <li> <p>Absolute paths: Always use absolute paths    <pre><code>input: 'file:///opt/dab/audio/station1.mp2'\n</code></pre></p> </li> <li> <p>Dedicated directory: Keep all audio files in one location    <pre><code>/opt/dab/audio/\n  \u251c\u2500\u2500 station1.mp2\n  \u251c\u2500\u2500 station2.aac\n  \u2514\u2500\u2500 backup.mp2\n</code></pre></p> </li> <li> <p>Backup files: Have backup/failover files ready    <pre><code># Primary\ninput: 'file:///opt/dab/audio/live.mp2'\n\n# Backup (separate subchannel/service)\ninput: 'file:///opt/dab/audio/backup.mp2'\n</code></pre></p> </li> <li> <p>File permissions: Ensure dabmux process can read files    <pre><code>chmod 644 /opt/dab/audio/*.mp2\nchown dabmux:dabmux /opt/dab/audio/*\n</code></pre></p> </li> </ol>"},{"location":"user-guide/inputs/file-inputs/#testing-setup","title":"Testing Setup","text":"<ol> <li> <p>Relative paths OK: Fine for development    <pre><code>input: 'file://test_audio.mp2'\n</code></pre></p> </li> <li> <p>Test files: Keep separate test directory    <pre><code>tests/audio/\n  \u251c\u2500\u2500 test_128k.mp2\n  \u251c\u2500\u2500 test_64k.aac\n  \u2514\u2500\u2500 test_48k.aac\n</code></pre></p> </li> <li> <p>Short files: Use short test files (30-60 seconds)    <pre><code># Create 30-second test file\nffmpeg -i input.wav -t 30 -c:a mp2 -b:a 128k test.mp2\n</code></pre></p> </li> </ol>"},{"location":"user-guide/inputs/file-inputs/#file-preparation-workflow","title":"File Preparation Workflow","text":""},{"location":"user-guide/inputs/file-inputs/#from-wav-source","title":"From WAV Source","text":"<pre><code># Step 1: Normalize audio\nffmpeg -i source.wav -af loudnorm normalized.wav\n\n# Step 2: Encode to DAB format (MPEG Layer II)\nffmpeg -i normalized.wav -c:a mp2 -ar 48000 -b:a 128k output.mp2\n\n# Step 3: Verify encoding\nffprobe output.mp2\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#batch-processing","title":"Batch Processing","text":"<pre><code>#!/bin/bash\n# Batch encode all WAV files to MPEG Layer II\n\nfor wav in *.wav; do\n    base=$(basename \"$wav\" .wav)\n    ffmpeg -i \"$wav\" -c:a mp2 -ar 48000 -b:a 128k \"${base}.mp2\"\ndone\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#quality-check","title":"Quality Check","text":"<pre><code># Check file format\nffprobe -hide_banner audio.mp2\n\n# Should show:\n#   Audio: mp2, 48000 Hz, stereo, s16p, 128 kb/s\n\n# Check duration\nffprobe -v error -show_entries format=duration \\\n  -of default=noprint_wrappers=1:nokey=1 audio.mp2\n\n# Playback test\nffplay audio.mp2\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#performance-and-optimization","title":"Performance and Optimization","text":""},{"location":"user-guide/inputs/file-inputs/#file-io-performance","title":"File I/O Performance","text":"<ul> <li>Disk speed: Not critical, even slow disks work fine</li> <li>SSD vs HDD: Both suitable, SSD offers lower latency</li> <li>Network storage: NFS/SMB works but add latency</li> <li>Caching: OS file cache handles repeated reads efficiently</li> </ul>"},{"location":"user-guide/inputs/file-inputs/#memory-usage","title":"Memory Usage","text":"<ul> <li>Buffer per input: ~100-500 KB</li> <li>Multiple files: Linear scaling</li> <li>Example: 10 file inputs \u2248 5 MB total</li> </ul>"},{"location":"user-guide/inputs/file-inputs/#cpu-usage","title":"CPU Usage","text":"<ul> <li>File reading: Negligible CPU usage</li> <li>Decoding: None (raw MPEG/AAC frames used directly)</li> <li>Bottleneck: Usually ETI frame generation, not file I/O</li> </ul>"},{"location":"user-guide/inputs/file-inputs/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/inputs/file-inputs/#automatic-failover","title":"Automatic Failover","text":"<p>Use external script to switch files on failure:</p> <pre><code>#!/bin/bash\n# Simple failover script\n\nPRIMARY=\"/opt/dab/audio/live.mp2\"\nBACKUP=\"/opt/dab/audio/backup.mp2\"\n\n# Monitor primary file\nwhile true; do\n    if [ ! -f \"$PRIMARY\" ]; then\n        echo \"Primary missing, using backup\"\n        ln -sf \"$BACKUP\" \"$PRIMARY\"\n    fi\n    sleep 10\ndone\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#dynamic-file-updates","title":"Dynamic File Updates","text":"<pre><code># Update audio file without stopping multiplexer\n# 1. Write new file to temporary location\nffmpeg -i new_source.wav -c:a mp2 -b:a 128k /tmp/new.mp2\n\n# 2. Atomically replace old file\nmv /tmp/new.mp2 /opt/dab/audio/live.mp2\n\n# Multiplexer will start reading new file on next loop\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#scheduled-programming","title":"Scheduled Programming","text":"<p>Use cron to switch content:</p> <pre><code># crontab -e\n\n# Morning show (6 AM)\n0 6 * * * ln -sf /opt/dab/audio/morning.mp2 /opt/dab/audio/current.mp2\n\n# Afternoon show (2 PM)\n0 14 * * * ln -sf /opt/dab/audio/afternoon.mp2 /opt/dab/audio/current.mp2\n\n# Evening show (7 PM)\n0 19 * * * ln -sf /opt/dab/audio/evening.mp2 /opt/dab/audio/current.mp2\n</code></pre> <p>Configuration: <pre><code>input: 'file:///opt/dab/audio/current.mp2'  # Symlink\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/inputs/file-inputs/#file-wont-play","title":"File Won't Play","text":"<p>Problem: File exists but multiplexer rejects it</p> <p>Diagnosis: <pre><code># Check file format\nffprobe -hide_banner audio.mp2\n\n# Expected for DAB:\n# Stream #0:0: Audio: mp2, 48000 Hz, stereo, s16p, 128 kb/s\n\n# Expected for DAB+:\n# Stream #0:0: Audio: aac (HE-AACv2), 48000 Hz, stereo, fltp, 72 kb/s\n</code></pre></p> <p>Solution: Re-encode with correct parameters</p>"},{"location":"user-guide/inputs/file-inputs/#clickspops-at-loop-point","title":"Clicks/Pops at Loop Point","text":"<p>Problem: Audible artifact when file loops</p> <p>Cause: File doesn't start/end at zero crossing</p> <p>Solution: Add fade in/out: <pre><code>ffmpeg -i input.wav \\\n  -af \"afade=t=in:st=0:d=0.1,afade=t=out:st=59.9:d=0.1\" \\\n  -c:a mp2 -b:a 128k output.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#file-updates-not-detected","title":"File Updates Not Detected","text":"<p>Problem: Changed file but old version still playing</p> <p>Cause: File changed mid-read; multiplexer has file handle open</p> <p>Solution: 1. Use atomic move (mv) instead of overwriting 2. Restart multiplexer after file change 3. Use continuous mode with symlink switching</p>"},{"location":"user-guide/inputs/file-inputs/#permission-denied","title":"Permission Denied","text":"<p>Problem: <pre><code>ERROR: Cannot open file: Permission denied\n</code></pre></p> <p>Solution: <pre><code># Check file permissions\nls -l audio.mp2\n\n# Fix permissions\nchmod 644 audio.mp2\n\n# If running as service, check user permissions\nsudo -u dabmux ls -l audio.mp2\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#examples","title":"Examples","text":""},{"location":"user-guide/inputs/file-inputs/#single-file-loop","title":"Single File Loop","text":"<pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'Test Loop'\n\nsubchannels:\n  - uid: 'loop'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'file://loop.mp2'\n\nservices:\n  - uid: 'service'\n    id: '0x5001'\n    label:\n      text: 'Test Signal'\n\ncomponents:\n  - uid: 'comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n</code></pre> <p>Run: <pre><code>python -m dabmux.cli -c config.yaml -o test.eti --continuous\n</code></pre></p>"},{"location":"user-guide/inputs/file-inputs/#multi-file-production","title":"Multi-File Production","text":"<pre><code>ensemble:\n  id: '0xCE20'\n  label:\n    text: 'Production'\n\nsubchannels:\n  - uid: 'main'\n    id: 0\n    type: 'audio'\n    bitrate: 160\n    input: 'file:///opt/dab/audio/main_160k.mp2'\n\n  - uid: 'news'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    input: 'file:///opt/dab/audio/news_64k.aac'\n\n  - uid: 'music'\n    id: 2\n    type: 'dabplus'\n    bitrate: 80\n    input: 'file:///opt/dab/audio/music_80k.aac'\n\nservices:\n  - uid: 'main_svc'\n    id: '0x5001'\n    label:\n      text: 'Main Station'\n\n  - uid: 'news_svc'\n    id: '0x5002'\n    label:\n      text: 'News 24/7'\n\n  - uid: 'music_svc'\n    id: '0x5003'\n    label:\n      text: 'Music Radio'\n\ncomponents:\n  - uid: 'main_comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n\n  - uid: 'news_comp'\n    service_id: '0x5002'\n    subchannel_id: 1\n\n  - uid: 'music_comp'\n    service_id: '0x5003'\n    subchannel_id: 2\n</code></pre>"},{"location":"user-guide/inputs/file-inputs/#see-also","title":"See Also","text":"<ul> <li>Input Sources Overview: All input types</li> <li>Network Inputs: UDP/TCP streaming</li> <li>Audio Formats: Complete encoding guide</li> <li>Configuration Examples: More examples</li> <li>Troubleshooting: Solving input problems</li> </ul>"},{"location":"user-guide/inputs/network-inputs/","title":"Network Inputs","text":"<p>Complete guide to UDP and TCP network inputs for live streaming.</p>"},{"location":"user-guide/inputs/network-inputs/#overview","title":"Overview","text":"<p>Network inputs receive audio streams over IP networks via UDP or TCP protocols. They enable live broadcasting, remote encoders, and distributed architectures.</p> <p>Protocols supported: - UDP: Low-latency, multicast-capable, connectionless - TCP: Reliable, guaranteed delivery, connection-oriented</p>"},{"location":"user-guide/inputs/network-inputs/#udp-inputs","title":"UDP Inputs","text":""},{"location":"user-guide/inputs/network-inputs/#basic-configuration","title":"Basic Configuration","text":"<p>URI format: <pre><code>udp://host:port\n</code></pre></p> <p>Configuration: <pre><code>subchannels:\n  - uid: 'udp_stream'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'udp://239.1.2.3:5001'\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#udp-unicast","title":"UDP Unicast","text":"<p>Point-to-point streaming between one sender and one receiver.</p> <p>Receiver configuration: <pre><code>input: 'udp://0.0.0.0:5001'  # Listen on all interfaces\n# or\ninput: 'udp://192.168.1.100:5001'  # Specific interface\n</code></pre></p> <p>Sender (encoder): <pre><code># Send MPEG Layer II audio\nffmpeg -re -i input.wav \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  -f mp2 udp://192.168.1.100:5001\n\n# Send HE-AAC audio (DAB+)\nffmpeg -re -i input.wav \\\n  -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 \\\n  -f adts udp://192.168.1.100:5001\n</code></pre></p> <p>Use cases: - Single encoder to single multiplexer - Simple streaming setups - Local network streaming</p>"},{"location":"user-guide/inputs/network-inputs/#udp-multicast","title":"UDP Multicast","text":"<p>One-to-many streaming from one sender to multiple receivers.</p> <p>Receiver configuration: <pre><code>input: 'udp://239.1.2.3:5001'  # Multicast group\n</code></pre></p> <p>Multicast address ranges: - 239.0.0.0 - 239.255.255.255: Organization-local scope - 239.1.2.0 - 239.1.2.255: Recommended for DAB streaming</p> <p>Sender (encoder): <pre><code># Send to multicast group\nffmpeg -re -i input.wav \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  -f mp2 udp://239.1.2.3:5001?ttl=2\n</code></pre></p> <p>TTL (Time To Live): - <code>1</code>: Same subnet only - <code>2</code>: Same building/site - <code>32</code>: Same organization - <code>64</code>: Same region - <code>128</code>: Same continent - <code>255</code>: Global</p> <p>Use cases: - One encoder feeding multiple multiplexers - Redundant receiver systems - Distribution networks - Large-scale deployments</p>"},{"location":"user-guide/inputs/network-inputs/#udp-advantages","title":"UDP Advantages","text":"<p>\u2705 Low latency: 1-10ms typical \u2705 Multicast support: One-to-many distribution \u2705 Network efficient: No connection overhead \u2705 Simple protocol: Easy to implement and debug</p>"},{"location":"user-guide/inputs/network-inputs/#udp-limitations","title":"UDP Limitations","text":"<p>\u274c No delivery guarantee: Packets can be lost \u274c No error correction: Lost packets = audio gaps \u274c Sensitive to network issues: Jitter, congestion affect quality \u274c Firewall complexity: Often blocked by default</p>"},{"location":"user-guide/inputs/network-inputs/#tcp-inputs","title":"TCP Inputs","text":""},{"location":"user-guide/inputs/network-inputs/#basic-configuration_1","title":"Basic Configuration","text":"<p>URI format: <pre><code>tcp://host:port\n</code></pre></p> <p>Configuration: <pre><code>subchannels:\n  - uid: 'tcp_stream'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    input: 'tcp://192.168.1.100:5002'\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#tcp-streaming","title":"TCP Streaming","text":"<p>Connection-oriented with guaranteed delivery.</p> <p>Receiver configuration: <pre><code>input: 'tcp://0.0.0.0:5002'  # Listen on all interfaces\n# or\ninput: 'tcp://192.168.1.100:5002'  # Specific interface\n</code></pre></p> <p>Sender (encoder): <pre><code># Send MPEG Layer II audio\nffmpeg -re -i input.wav \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  -f mp2 tcp://192.168.1.100:5002\n\n# Send HE-AAC audio (DAB+)\nffmpeg -re -i input.wav \\\n  -c:a aac -ar 48000 -b:a 72k -profile:a aac_he_v2 \\\n  -f adts tcp://192.168.1.100:5002\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#tcp-advantages","title":"TCP Advantages","text":"<p>\u2705 Guaranteed delivery: No packet loss \u2705 Error correction: Automatic retransmission \u2705 Congestion control: Adapts to network conditions \u2705 Firewall friendly: Easier to configure than UDP multicast</p>"},{"location":"user-guide/inputs/network-inputs/#tcp-limitations","title":"TCP Limitations","text":"<p>\u274c Higher latency: 10-50ms typical (vs 1-10ms for UDP) \u274c No multicast: Point-to-point only \u274c Head-of-line blocking: One slow packet delays all \u274c Connection overhead: Requires connection management</p>"},{"location":"user-guide/inputs/network-inputs/#network-setup","title":"Network Setup","text":""},{"location":"user-guide/inputs/network-inputs/#firewall-configuration","title":"Firewall Configuration","text":""},{"location":"user-guide/inputs/network-inputs/#linux-iptables","title":"Linux (iptables)","text":"<p>Allow UDP: <pre><code># Allow incoming UDP on port 5001\nsudo iptables -A INPUT -p udp --dport 5001 -j ACCEPT\n\n# Allow outgoing UDP\nsudo iptables -A OUTPUT -p udp --sport 5001 -j ACCEPT\n</code></pre></p> <p>Allow TCP: <pre><code># Allow incoming TCP on port 5002\nsudo iptables -A INPUT -p tcp --dport 5002 -j ACCEPT\n\n# Allow outgoing TCP\nsudo iptables -A OUTPUT -p tcp --sport 5002 -j ACCEPT\n</code></pre></p> <p>Allow multicast: <pre><code># Allow IGMP (multicast group management)\nsudo iptables -A INPUT -p igmp -j ACCEPT\n\n# Allow multicast traffic\nsudo iptables -A INPUT -d 239.0.0.0/8 -j ACCEPT\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#linux-firewalld","title":"Linux (firewalld)","text":"<pre><code># Add UDP port\nsudo firewall-cmd --add-port=5001/udp --permanent\n\n# Add TCP port\nsudo firewall-cmd --add-port=5002/tcp --permanent\n\n# Reload\nsudo firewall-cmd --reload\n</code></pre>"},{"location":"user-guide/inputs/network-inputs/#windows","title":"Windows","text":"<pre><code># Allow UDP\nnetsh advfirewall firewall add rule name=\"DAB UDP\" ^\n  protocol=UDP dir=in localport=5001 action=allow\n\n# Allow TCP\nnetsh advfirewall firewall add rule name=\"DAB TCP\" ^\n  protocol=TCP dir=in localport=5002 action=allow\n</code></pre>"},{"location":"user-guide/inputs/network-inputs/#router-configuration","title":"Router Configuration","text":"<p>Port forwarding (if multiplexer behind NAT): 1. Access router admin interface 2. Navigate to Port Forwarding 3. Forward external UDP 5001 \u2192 internal 192.168.1.100:5001 4. Forward external TCP 5002 \u2192 internal 192.168.1.100:5002</p> <p>Multicast routing: <pre><code># Enable multicast routing on Linux\nsudo route add -net 239.0.0.0 netmask 255.0.0.0 dev eth0\n\n# View multicast routes\nnetstat -g\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#network-interface-selection","title":"Network Interface Selection","text":"<p>Bind to specific interface:</p> <p>python-dabmux automatically selects best interface, but you can specify:</p> <pre><code># Listen on specific IP\ninput: 'udp://192.168.1.100:5001'\n\n# Listen on all interfaces\ninput: 'udp://0.0.0.0:5001'\n</code></pre>"},{"location":"user-guide/inputs/network-inputs/#bandwidth-requirements","title":"Bandwidth Requirements","text":""},{"location":"user-guide/inputs/network-inputs/#calculate-bandwidth","title":"Calculate Bandwidth","text":"<p>Formula: <pre><code>Required bandwidth = Bitrate \u00d7 1.1\n</code></pre></p> <p>The 1.1 multiplier accounts for: - Protocol overhead (UDP/TCP headers) - IP overhead - Ethernet overhead - ~10% safety margin</p>"},{"location":"user-guide/inputs/network-inputs/#examples","title":"Examples","text":"Audio Bitrate Protocol Required Bandwidth 48 kbps UDP ~53 kbps 64 kbps TCP ~70 kbps 128 kbps UDP ~141 kbps 192 kbps TCP ~211 kbps"},{"location":"user-guide/inputs/network-inputs/#multiple-streams","title":"Multiple Streams","text":"<pre><code># 3 streams example\nsubchannels:\n  - input: 'udp://239.1.2.3:5001'  # 128 kbps\n  - input: 'udp://239.1.2.4:5002'  # 64 kbps\n  - input: 'tcp://192.168.1.100:5003'  # 72 kbps\n\n# Total bandwidth: (128 + 64 + 72) \u00d7 1.1 = 290 kbps\n</code></pre>"},{"location":"user-guide/inputs/network-inputs/#network-capacity-planning","title":"Network Capacity Planning","text":"<p>100 Mbps network: Can handle ~700 audio streams at 128 kbps 1 Gbps network: Can handle ~7000 audio streams at 128 kbps</p> <p>In practice, limited by CPU and I/O before network saturation.</p>"},{"location":"user-guide/inputs/network-inputs/#buffering-and-jitter","title":"Buffering and Jitter","text":""},{"location":"user-guide/inputs/network-inputs/#buffer-configuration","title":"Buffer Configuration","text":"<p>python-dabmux uses automatic buffering:</p> <ul> <li>UDP: ~100ms buffer (compensates for jitter)</li> <li>TCP: ~50ms buffer (less jitter due to reliable delivery)</li> </ul>"},{"location":"user-guide/inputs/network-inputs/#jitter-tolerance","title":"Jitter Tolerance","text":"<p>Jitter: Variation in packet arrival times</p> <p>UDP tolerates: - \u2264 50ms jitter: Excellent - 50-100ms jitter: Good (may hear occasional glitches) - &gt; 100ms jitter: Poor (frequent glitches)</p> <p>TCP handles jitter better due to automatic retransmission.</p>"},{"location":"user-guide/inputs/network-inputs/#underrun-handling","title":"Underrun Handling","text":"<p>If network input stalls: 1. Buffer drains 2. Multiplexer logs warning: <code>WARNING: Input underrun</code> 3. Silence inserted to maintain ETI frame timing 4. Normal playout resumes when data arrives</p>"},{"location":"user-guide/inputs/network-inputs/#live-streaming-setup","title":"Live Streaming Setup","text":""},{"location":"user-guide/inputs/network-inputs/#complete-example","title":"Complete Example","text":"<p>Encoder machine (192.168.1.50):</p> <pre><code># Stream 1: Music (128 kbps MPEG)\nffmpeg -re -f alsa -i hw:0 \\\n  -c:a mp2 -ar 48000 -b:a 128k \\\n  -f mp2 udp://239.1.2.3:5001 &amp;\n\n# Stream 2: News (64 kbps AAC)\nffmpeg -re -f alsa -i hw:1 \\\n  -c:a aac -ar 48000 -b:a 64k -profile:a aac_he_v2 \\\n  -f adts udp://239.1.2.4:5002 &amp;\n\n# Stream 3: Talk (48 kbps AAC via TCP)\nffmpeg -re -f alsa -i hw:2 \\\n  -c:a aac -ar 48000 -b:a 48k -profile:a aac_he_v2 \\\n  -f adts tcp://192.168.1.100:5003 &amp;\n</code></pre> <p>Multiplexer machine (192.168.1.100):</p> <p><code>network_live.yaml</code>: <pre><code>ensemble:\n  id: '0xCE15'\n  label:\n    text: 'Live Network'\n\nsubchannels:\n  - uid: 'music'\n    id: 0\n    type: 'audio'\n    bitrate: 128\n    start_address: 0\n    protection:\n      level: 3  # Higher protection for network\n    input: 'udp://239.1.2.3:5001'\n\n  - uid: 'news'\n    id: 1\n    type: 'dabplus'\n    bitrate: 64\n    start_address: 100\n    protection:\n      level: 2\n    input: 'udp://239.1.2.4:5002'\n\n  - uid: 'talk'\n    id: 2\n    type: 'dabplus'\n    bitrate: 48\n    start_address: 200\n    protection:\n      level: 2\n    input: 'tcp://0.0.0.0:5003'\n\nservices:\n  - uid: 'music_svc'\n    id: '0x5001'\n    label:\n      text: 'Live Music'\n    pty: 10\n    language: 9\n\n  - uid: 'news_svc'\n    id: '0x5002'\n    label:\n      text: 'Live News'\n    pty: 1\n    language: 9\n\n  - uid: 'talk_svc'\n    id: '0x5003'\n    label:\n      text: 'Live Talk'\n    pty: 9\n    language: 9\n\ncomponents:\n  - uid: 'music_comp'\n    service_id: '0x5001'\n    subchannel_id: 0\n\n  - uid: 'news_comp'\n    service_id: '0x5002'\n    subchannel_id: 1\n\n  - uid: 'talk_comp'\n    service_id: '0x5003'\n    subchannel_id: 2\n</code></pre></p> <p>Run multiplexer: <pre><code>python -m dabmux.cli -c network_live.yaml -o live.eti --continuous\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"user-guide/inputs/network-inputs/#check-network-connectivity","title":"Check Network Connectivity","text":"<p>Test UDP reception: <pre><code># Listen for UDP packets (netcat)\nnc -u -l 5001 | hexdump -C\n\n# Or tcpdump\nsudo tcpdump -i eth0 udp port 5001 -X\n</code></pre></p> <p>Test TCP connection: <pre><code># Listen for TCP connection\nnc -l 5002\n\n# Connect to test\ntelnet 192.168.1.100 5002\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#monitor-multicast-traffic","title":"Monitor Multicast Traffic","text":"<pre><code># View multicast group memberships\nnetstat -g\n\n# Capture multicast traffic\nsudo tcpdump -i eth0 'dst net 239.0.0.0/8' -vv\n\n# Test multicast join\nsudo ip maddr add 239.1.2.3 dev eth0\n</code></pre>"},{"location":"user-guide/inputs/network-inputs/#network-statistics","title":"Network Statistics","text":"<p>Enable verbose logging: <pre><code>python -m dabmux.cli -c config.yaml -o output.eti -v\n</code></pre></p> <p>Statistics shown: - Packets received - Bytes received - Buffer fill level - Underrun count - Network errors</p> <p>Example output: <pre><code>INFO: Input 'music': 48523 packets, 62283776 bytes received\nINFO: Input 'music': Buffer fill: 75%\nINFO: Input 'news': 0 underruns detected\n</code></pre></p>"},{"location":"user-guide/inputs/network-inputs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/inputs/network-inputs/#no-data-received","title":"No Data Received","text":"<p>Problem: <pre><code>WARNING: Input timeout, inserting silence\nERROR: No data received from udp://239.1.2.3:5001\n</code></pre></p> <p>Diagnosis: <pre><code># Test if packets arriving\nsudo tcpdump -i eth0 udp port 5001\n\n# Check firewall\nsudo iptables -L -n | grep 5001\n\n# Test connectivity\nnc -u 192.168.1.100 5001 &lt; test.mp2\n</code></pre></p> <p>Solutions: 1. Check encoder is running and sending 2. Verify firewall allows UDP/TCP 3. Confirm network connectivity 4. Test with simpler setup first</p>"},{"location":"user-guide/inputs/network-inputs/#packet-loss-audio-glitches","title":"Packet Loss / Audio Glitches","text":"<p>Problem: <pre><code>WARNING: Input underrun detected\n</code></pre></p> <p>Diagnosis: <pre><code># Check packet loss\nping 192.168.1.50\n# Look for packet loss %\n\n# Monitor network errors\nnetstat -s | grep error\n\n# Check interface errors\nifconfig eth0 | grep error\n</code></pre></p> <p>Solutions: 1. Use TCP instead of UDP (guaranteed delivery) 2. Increase protection level (compensates for bit errors) 3. Reduce network load (eliminate competing traffic) 4. Use dedicated network (separate from general traffic) 5. Check physical layer (cables, switches, NICs)</p>"},{"location":"user-guide/inputs/network-inputs/#multicast-not-working","title":"Multicast Not Working","text":"<p>Problem: Multicast UDP not received</p> <p>Diagnosis: <pre><code># Check IGMP support\ncat /proc/net/igmp\n\n# Test multicast join\nsudo ip maddr add 239.1.2.3 dev eth0\nsudo tcpdump -i eth0 'dst 239.1.2.3'\n</code></pre></p> <p>Solutions: 1. Enable IGMP on router: <pre><code># Linux router\nsudo sysctl -w net.ipv4.conf.all.mc_forwarding=1\n</code></pre></p> <ol> <li> <p>Add multicast route: <pre><code>sudo route add -net 239.0.0.0 netmask 255.0.0.0 dev eth0\n</code></pre></p> </li> <li> <p>Join multicast group explicitly: <pre><code>sudo ip maddr add 239.1.2.3 dev eth0\n</code></pre></p> </li> </ol>"},{"location":"user-guide/inputs/network-inputs/#high-latency","title":"High Latency","text":"<p>Problem: Noticeable delay in audio</p> <p>TCP typical: 10-50ms UDP typical: 1-10ms</p> <p>If higher:</p> <p>Solutions: 1. Use UDP instead of TCP (lower latency) 2. Reduce network hops (use direct connection) 3. Check network congestion (use QoS) 4. Disable Nagle algorithm (TCP optimization)</p>"},{"location":"user-guide/inputs/network-inputs/#connection-drops-tcp","title":"Connection Drops (TCP)","text":"<p>Problem: TCP connection lost</p> <p>Solutions: 1. Use TCP keepalive: <pre><code># Linux: Enable TCP keepalive\nsysctl -w net.ipv4.tcp_keepalive_time=60\n</code></pre></p> <ol> <li> <p>Monitor connection: <pre><code>netstat -tn | grep 5002\n</code></pre></p> </li> <li> <p>Automatic reconnection: Run encoder in loop    <pre><code>while true; do\n    ffmpeg -re -i input.wav ... tcp://192.168.1.100:5002\n    echo \"Connection lost, reconnecting in 5s...\"\n    sleep 5\ndone\n</code></pre></p> </li> </ol>"},{"location":"user-guide/inputs/network-inputs/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/inputs/network-inputs/#protocol-selection","title":"Protocol Selection","text":"<p>Use UDP when: - \u2705 Low latency required (live broadcasting) - \u2705 Multicast needed (multiple receivers) - \u2705 Network is reliable (minimal packet loss) - \u2705 Can tolerate occasional glitches</p> <p>Use TCP when: - \u2705 Reliability critical (no audio gaps allowed) - \u2705 Network has packet loss - \u2705 Point-to-point only - \u2705 Latency not critical</p>"},{"location":"user-guide/inputs/network-inputs/#network-design","title":"Network Design","text":"<ol> <li>Dedicated network: Separate streaming traffic from general network</li> <li>Managed switches: Use VLANs for isolation</li> <li>Gigabit links: Ensure sufficient bandwidth</li> <li>Redundancy: Multiple network paths for failover</li> <li>QoS: Prioritize streaming traffic</li> </ol>"},{"location":"user-guide/inputs/network-inputs/#monitoring","title":"Monitoring","text":"<ol> <li>Log monitoring: Watch for underruns and errors</li> <li>Network monitoring: Use tools like Zabbix, Nagios</li> <li>Alerts: Set up notifications for issues</li> <li>Statistics: Track packet loss, latency, jitter</li> </ol>"},{"location":"user-guide/inputs/network-inputs/#security","title":"Security","text":"<ol> <li>Firewall: Only open necessary ports</li> <li>VPN: Use VPN for remote encoders</li> <li>Authentication: Implement stream authentication (external)</li> <li>Encryption: Use VPN or SSH tunnels for sensitive streams</li> </ol>"},{"location":"user-guide/inputs/network-inputs/#see-also","title":"See Also","text":"<ul> <li>Input Sources Overview: All input types</li> <li>File Inputs: File-based inputs</li> <li>Audio Formats: Audio encoding guide</li> <li>Network Streaming Tutorial: Step-by-step guide</li> <li>Troubleshooting: Network problem solving</li> </ul>"},{"location":"user-guide/outputs/","title":"Output Formats","text":"<p>Overview of output formats for distributing DAB multiplex data.</p>"},{"location":"user-guide/outputs/#what-are-outputs","title":"What Are Outputs?","text":"<p>Outputs deliver the generated ETI (Ensemble Transport Interface) frames to transmitters or recording. python-dabmux supports two output types:</p> <ul> <li>ETI files: Write frames to disk</li> <li>EDI network: Stream frames over IP with optional error correction</li> </ul>"},{"location":"user-guide/outputs/#output-types","title":"Output Types","text":"Type Format Use Case Reliability ETI File Binary file Recording, archiving, local processing 100% EDI (UDP) Network stream Real-time transmission, low latency Best-effort EDI (TCP) Network stream Real-time transmission, guaranteed delivery Reliable EDI + PFT Network stream with FEC Lossy networks, long-distance Very reliable"},{"location":"user-guide/outputs/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/outputs/#eti-file-output","title":"ETI File Output","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti\n</code></pre> <p>Generates <code>output.eti</code> file containing ETI frames.</p>"},{"location":"user-guide/outputs/#edi-network-output-udp","title":"EDI Network Output (UDP)","text":"<pre><code>python -m dabmux.cli -c config.yaml --edi udp://192.168.1.100:12000\n</code></pre> <p>Streams ETI as EDI packets over UDP to modulator.</p>"},{"location":"user-guide/outputs/#edi-with-pft-forward-error-correction","title":"EDI with PFT (Forward Error Correction)","text":"<pre><code>python -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 2 \\\n  --pft-fec-m 3\n</code></pre> <p>Streams with PFT fragmentation and Reed-Solomon FEC.</p>"},{"location":"user-guide/outputs/#combined-file-and-network","title":"Combined File and Network","text":"<pre><code>python -m dabmux.cli -c config.yaml \\\n  -o archive.eti \\\n  --edi udp://192.168.1.100:12000\n</code></pre> <p>Writes file AND streams over network simultaneously.</p>"},{"location":"user-guide/outputs/#output-selection","title":"Output Selection","text":""},{"location":"user-guide/outputs/#eti-files","title":"ETI Files","text":"<p>Use when: - Recording for archival - Post-processing required - Testing and development - Offline playout - Guaranteed data integrity</p> <p>Advantages: - \u2705 Perfect reliability (no data loss) - \u2705 Repeatable playout - \u2705 Easy backup and archival - \u2705 Simple file management - \u2705 No network dependencies</p> <p>Limitations: - \u274c Not real-time (must generate first) - \u274c Requires disk space - \u274c No live streaming</p> <p>See ETI Files for details.</p>"},{"location":"user-guide/outputs/#edi-network-udp","title":"EDI Network (UDP)","text":"<p>Use when: - Real-time live broadcasting - Low-latency distribution required - Transmitter on local network - Reliable network available</p> <p>Advantages: - \u2705 Real-time streaming - \u2705 Low latency (1-10ms) - \u2705 Multicast support (one-to-many) - \u2705 Standard protocol</p> <p>Limitations: - \u274c No delivery guarantee (UDP) - \u274c Packet loss possible - \u274c Requires network configuration</p> <p>See EDI Network for details.</p>"},{"location":"user-guide/outputs/#edi-with-pft","title":"EDI with PFT","text":"<p>Use when: - Network has packet loss - Long-distance links - Unreliable networks - Critical broadcasting (no tolerance for loss)</p> <p>Advantages: - \u2705 Forward error correction - \u2705 Can recover lost packets - \u2705 Automatic fragment reassembly - \u2705 Sequence numbering</p> <p>Limitations: - \u274c Higher bandwidth (FEC overhead) - \u274c Slightly higher latency - \u274c More complex configuration</p> <p>See PFT Fragmentation for details.</p>"},{"location":"user-guide/outputs/#output-formats-comparison","title":"Output Formats Comparison","text":""},{"location":"user-guide/outputs/#eti-vs-edi","title":"ETI vs EDI","text":"<p>ETI (Ensemble Transport Interface): - Binary frame format - 6144 bytes per frame (Mode I) - Contains complete multiplex data - File-based or can be streamed - Defined in ETSI EN 300 799</p> <p>EDI (Ensemble Data Interface): - Network protocol for ETI - TAG-based packet structure - Can include timestamps, metadata - UDP or TCP transport - Defined in ETSI TS 102 693</p> <p>Relationship: <pre><code>ETI Frames \u2192 EDI Encoder \u2192 TAG Packets \u2192 AF Packets \u2192 [Optional: PFT] \u2192 UDP/TCP\n</code></pre></p>"},{"location":"user-guide/outputs/#frame-rates","title":"Frame Rates","text":"<p>Mode I (standard): - Frame duration: 96 ms - Frame rate: ~10.42 frames/second - Data rate: 6144 bytes \u00d7 10.42 \u2248 64 KB/s</p> <p>Other modes: - Mode II: 24 ms frames - Mode III: 24 ms frames - Mode IV: 48 ms frames</p>"},{"location":"user-guide/outputs/#bandwidth-requirements","title":"Bandwidth Requirements","text":""},{"location":"user-guide/outputs/#eti-file","title":"ETI File","text":"<p>Disk space: - Mode I: ~64 KB/s = 3.75 MB/min = 225 MB/hour</p> <p>Example: - 1-hour broadcast: ~225 MB - 24-hour broadcast: ~5.4 GB</p>"},{"location":"user-guide/outputs/#edi-network","title":"EDI Network","text":"<p>Without PFT: - Mode I: ~700 kbps (ETI + protocol overhead)</p> <p>With PFT (FEC depth 2, M=3): - Mode I: ~900-1000 kbps (additional ~30% overhead)</p> <p>Multicast efficiency: - 1 encoder \u2192 N receivers uses same bandwidth as 1\u21921</p>"},{"location":"user-guide/outputs/#output-configuration","title":"Output Configuration","text":""},{"location":"user-guide/outputs/#cli-options","title":"CLI Options","text":"<p>ETI file: <pre><code>-o FILE, --output FILE\n</code></pre></p> <p>EDI network: <pre><code>--edi DESTINATION\n</code></pre></p> <p>PFT options: <pre><code>--pft                      # Enable PFT\n--pft-fec DEPTH            # FEC depth (0-20, default: 0)\n--pft-fec-m M              # Max correctable fragments (0-20, default: 0)\n--pft-fragment-size SIZE   # Fragment size in bytes (default: 512)\n</code></pre></p>"},{"location":"user-guide/outputs/#examples","title":"Examples","text":"<p>File only: <pre><code>python -m dabmux.cli -c config.yaml -o output.eti\n</code></pre></p> <p>Network only: <pre><code>python -m dabmux.cli -c config.yaml --edi udp://192.168.1.100:12000\n</code></pre></p> <p>File + Network: <pre><code>python -m dabmux.cli -c config.yaml \\\n  -o archive.eti \\\n  --edi udp://192.168.1.100:12000\n</code></pre></p> <p>Network with PFT: <pre><code>python -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 5\n</code></pre></p>"},{"location":"user-guide/outputs/#output-pipeline","title":"Output Pipeline","text":"<pre><code>graph LR\n    A[Multiplexer Core] --&gt; B{Output Type}\n    B --&gt;|File| C[ETI File Writer]\n    B --&gt;|Network| D[EDI Encoder]\n\n    C --&gt; E[output.eti]\n\n    D --&gt; F{PFT Enabled?}\n    F --&gt;|No| G[AF Packets]\n    F --&gt;|Yes| H[PFT Fragmenter]\n\n    H --&gt; I[Reed-Solomon FEC]\n    I --&gt; J[PFT Packets]\n\n    G --&gt; K[UDP/TCP Socket]\n    J --&gt; K\n\n    K --&gt; L[Network]\n</code></pre> <p>Flow: 1. Multiplexer generates ETI frames 2. File output: Write directly to disk 3. EDI output: Encode as EDI TAG packets 4. PFT (optional): Fragment and add FEC 5. Network: Send via UDP or TCP</p>"},{"location":"user-guide/outputs/#timestamping","title":"Timestamping","text":""},{"location":"user-guide/outputs/#tist-time-stamp-in-sti-d-frame","title":"TIST (Time-stamp in STI-D frame)","text":"<p>Enable timestamping: <pre><code>python -m dabmux.cli -c config.yaml -o output.eti --tist\n</code></pre></p> <p>Purpose: - Synchronize multiple transmitters - Single Frequency Networks (SFN) - Precise timing reference</p> <p>Timestamp format: - 32-bit value in ETI frame - Resolution: 1/16,384,000 second (~61 ns) - Epoch: 1970-01-01 00:00:00 UTC</p> <p>See Timestamps for details.</p>"},{"location":"user-guide/outputs/#multiple-outputs","title":"Multiple Outputs","text":"<p>You can write to file and stream over network simultaneously:</p> <pre><code># Archive to file AND stream to transmitter\npython -m dabmux.cli -c config.yaml \\\n  -o /archive/$(date +%Y%m%d_%H%M%S).eti \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --continuous\n</code></pre> <p>Use cases: - Live broadcasting with archival - Redundant distribution - Monitoring and analysis - Backup and disaster recovery</p>"},{"location":"user-guide/outputs/#performance","title":"Performance","text":""},{"location":"user-guide/outputs/#throughput","title":"Throughput","text":"<p>Single output (file or network): - Negligible CPU overhead - Limited by disk I/O or network bandwidth</p> <p>Multiple outputs: - Linear scaling - Example: File + EDI \u2248 2\u00d7 single output overhead</p>"},{"location":"user-guide/outputs/#latency","title":"Latency","text":"Output Type Typical Latency ETI File N/A (batch) EDI (UDP) 1-5 ms EDI (TCP) 5-20 ms EDI + PFT 10-30 ms <p>PFT adds latency due to fragment buffering and FEC calculation.</p>"},{"location":"user-guide/outputs/#monitoring","title":"Monitoring","text":""},{"location":"user-guide/outputs/#enable-verbose-output","title":"Enable Verbose Output","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti -v\n</code></pre> <p>Statistics shown: - Frames generated - Bytes written/sent - Output buffer status - Network packet statistics (if EDI) - Underrun/overrun counts</p>"},{"location":"user-guide/outputs/#example-output","title":"Example Output","text":"<pre><code>INFO: Generated frame 1000\nINFO: File output: 6144000 bytes written\nINFO: EDI output: 1000 packets sent, 0 errors\nINFO: PFT: 0 fragments lost, 0 FEC corrections\n</code></pre>"},{"location":"user-guide/outputs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/outputs/#file-output-issues","title":"File Output Issues","text":"<p>Disk full: <pre><code>ERROR: Cannot write to output.eti: No space left on device\n</code></pre> Solution: Free disk space or use different location</p> <p>Permission denied: <pre><code>ERROR: Cannot create output.eti: Permission denied\n</code></pre> Solution: Check file permissions and directory access</p> <p>See Output Issues for more.</p>"},{"location":"user-guide/outputs/#network-output-issues","title":"Network Output Issues","text":"<p>Connection refused: <pre><code>ERROR: Cannot connect to udp://192.168.1.100:12000\n</code></pre> Solution: Check modulator is listening, firewall allows traffic</p> <p>Packet loss: <pre><code>WARNING: EDI output: high packet loss detected\n</code></pre> Solution: Enable PFT with FEC, or use TCP instead of UDP</p> <p>See Network Issues for more.</p>"},{"location":"user-guide/outputs/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/outputs/#file-outputs","title":"File Outputs","text":"<ol> <li>Use absolute paths: Avoid relative paths in production</li> <li>Monitor disk space: Set up alerts for low disk space</li> <li>Rotate files: Use date-based naming for archival</li> <li>Compression: Consider compressing archived ETI files</li> <li>Backup: Regularly back up important recordings</li> </ol>"},{"location":"user-guide/outputs/#network-outputs","title":"Network Outputs","text":"<ol> <li>Use PFT for unreliable networks: Enable FEC if packet loss &gt; 1%</li> <li>Dedicated network: Separate broadcasting from general traffic</li> <li>QoS: Configure network QoS for streaming traffic</li> <li>Monitoring: Monitor packet loss and latency</li> <li>Redundancy: Use multiple paths for critical links</li> </ol>"},{"location":"user-guide/outputs/#general","title":"General","text":"<ol> <li>Test first: Verify outputs before production use</li> <li>Monitor logs: Watch for warnings and errors</li> <li>Validate ETI: Use ETI validation tools</li> <li>Document setup: Keep configuration documented</li> <li>Disaster recovery: Have backup outputs configured</li> </ol>"},{"location":"user-guide/outputs/#output-decision-matrix","title":"Output Decision Matrix","text":"Scenario Recommended Output Reasoning Testing / Development ETI File Easy, reliable, repeatable Local transmitter (same machine) ETI File No network needed Remote transmitter (reliable network) EDI UDP Low latency, simple Remote transmitter (unreliable network) EDI UDP + PFT FEC recovers packet loss Multiple transmitters EDI UDP Multicast Efficient one-to-many Critical broadcast (zero tolerance) EDI TCP or PFT Guaranteed delivery Archive + Live File + EDI Best of both worlds SFN (Single Frequency Network) EDI + TIST + PFT Precise synchronization"},{"location":"user-guide/outputs/#see-also","title":"See Also","text":"<ul> <li>ETI Files: Detailed ETI file documentation</li> <li>EDI Network: EDI streaming guide</li> <li>PFT Fragmentation: Forward error correction</li> <li>CLI Reference: Complete command-line options</li> <li>Architecture: EDI Protocol: Protocol details</li> </ul>"},{"location":"user-guide/outputs/edi-network/","title":"EDI Network Output","text":"<p>Complete guide to streaming DAB multiplex data via EDI (Ensemble Data Interface) over IP networks.</p>"},{"location":"user-guide/outputs/edi-network/#overview","title":"Overview","text":"<p>EDI is the network protocol for distributing ETI frames to remote transmitters. It encapsulates ETI data in TAG-based packets suitable for UDP or TCP transmission.</p> <p>Key features: - Real-time streaming - Low latency - Optional fragmentation and FEC (PFT) - Timestamp support - Sequence numbering</p> <p>Standard: ETSI TS 102 693</p>"},{"location":"user-guide/outputs/edi-network/#edi-protocol-stack","title":"EDI Protocol Stack","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   ETI Frame Data    \u2502  Application Layer\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   TAG Items         \u2502  EDI Layer\n\u2502   (*ptr, deti, etc) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   TAG Packet        \u2502  TAG Layer\n\u2502   (8-byte aligned)  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   AF Packet         \u2502  AF Layer\n\u2502   (SYNC + CRC)      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   [Optional: PFT]   \u2502  PFT Layer\n\u2502   (Fragments + FEC) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   UDP / TCP         \u2502  Transport Layer\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>See Architecture: EDI Protocol for detailed diagrams.</p>"},{"location":"user-guide/outputs/edi-network/#basic-edi-streaming","title":"Basic EDI Streaming","text":""},{"location":"user-guide/outputs/edi-network/#udp-output","title":"UDP Output","text":"<pre><code>python -m dabmux.cli -c config.yaml --edi udp://192.168.1.100:12000\n</code></pre> <p>Sends EDI packets to: - Host: 192.168.1.100 - Port: 12000 - Protocol: UDP</p>"},{"location":"user-guide/outputs/edi-network/#tcp-output","title":"TCP Output","text":"<pre><code>python -m dabmux.cli -c config.yaml --edi tcp://192.168.1.100:12000\n</code></pre> <p>Opens TCP connection to modulator: - Guaranteed delivery - Higher latency than UDP - No packet loss</p>"},{"location":"user-guide/outputs/edi-network/#multicast-output","title":"Multicast Output","text":"<pre><code>python -m dabmux.cli -c config.yaml --edi udp://239.1.2.3:12000\n</code></pre> <p>Multicast distribution: - One encoder \u2192 multiple receivers - Efficient bandwidth usage - Requires multicast-capable network</p>"},{"location":"user-guide/outputs/edi-network/#edi-packet-structure","title":"EDI Packet Structure","text":""},{"location":"user-guide/outputs/edi-network/#af-assembly-format-packet","title":"AF (Assembly Format) Packet","text":"<p>Structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SYNC     \u2502 LEN         \u2502 SEQ     \u2502 PAYLOAD    \u2502 CRC  \u2502\n\u2502 (2 bytes)\u2502 (4 bytes)   \u2502 (2 bytes\u2502 (variable) \u2502 (2 B)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Fields: - SYNC: 0x4146 (\"AF\" in ASCII) - LEN: Payload length - SEQ: Sequence number (wraps at 65535) - PAYLOAD: TAG items - CRC: 16-bit CRC</p>"},{"location":"user-guide/outputs/edi-network/#tag-items","title":"TAG Items","text":"<p>Common TAG types:</p> TAG Name Purpose <code>*ptr</code> Protocol Type Indicates protocol version <code>deti</code> DAB ETI Data Contains ETI frame <code>est</code> ETI Stream Stream characteristics <code>*dmy</code> Dummy Padding/alignment <p>TAG structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Name     \u2502 Length  \u2502 Value    \u2502\n\u2502 (4 bytes)\u2502 (4 bytes\u2502 (N bytes)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#bandwidth-requirements","title":"Bandwidth Requirements","text":""},{"location":"user-guide/outputs/edi-network/#without-pft","title":"Without PFT","text":"<p>Formula: <pre><code>Bandwidth \u2248 ETI bitrate \u00d7 1.15\n</code></pre></p> <p>Mode I example: - ETI: 6144 bytes per 96ms frame - Rate: 6144 \u00d7 (1000/96) = 64,000 bytes/s = 512 kbps - With overhead: 512 \u00d7 1.15 \u2248 590 kbps</p>"},{"location":"user-guide/outputs/edi-network/#with-pft","title":"With PFT","text":"<p>Formula: <pre><code>Bandwidth \u2248 ETI bitrate \u00d7 (1.15 + FEC_overhead)\n</code></pre></p> <p>FEC overhead depends on settings: - FEC depth 2, M=3: +30% overhead - FEC depth 3, M=5: +40% overhead - FEC depth 5, M=7: +50% overhead</p> <p>Mode I with PFT example: - Base: 512 kbps - PFT overhead (30%): 154 kbps - Total: ~665 kbps</p>"},{"location":"user-guide/outputs/edi-network/#network-configuration","title":"Network Configuration","text":""},{"location":"user-guide/outputs/edi-network/#firewall-rules","title":"Firewall Rules","text":""},{"location":"user-guide/outputs/edi-network/#linux-iptables","title":"Linux (iptables)","text":"<p>Allow UDP: <pre><code># Outbound (multiplexer)\nsudo iptables -A OUTPUT -p udp --dport 12000 -j ACCEPT\n\n# Inbound (modulator)\nsudo iptables -A INPUT -p udp --dport 12000 -j ACCEPT\n</code></pre></p> <p>Allow TCP: <pre><code># Outbound (multiplexer)\nsudo iptables -A OUTPUT -p tcp --dport 12000 -j ACCEPT\n\n# Inbound (modulator)\nsudo iptables -A INPUT -p tcp --dport 12000 -j ACCEPT\n</code></pre></p> <p>Allow multicast: <pre><code># Enable IGMP\nsudo iptables -A INPUT -p igmp -j ACCEPT\n\n# Allow multicast traffic\nsudo iptables -A INPUT -d 239.0.0.0/8 -j ACCEPT\nsudo iptables -A OUTPUT -d 239.0.0.0/8 -j ACCEPT\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#linux-firewalld","title":"Linux (firewalld)","text":"<pre><code># Add UDP port\nsudo firewall-cmd --add-port=12000/udp --permanent\n\n# Add TCP port\nsudo firewall-cmd --add-port=12000/tcp --permanent\n\n# Reload\nsudo firewall-cmd --reload\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#router-configuration","title":"Router Configuration","text":"<p>Port forwarding: 1. Access router configuration 2. Forward external port 12000 \u2192 internal IP:12000 3. Select UDP or TCP based on usage</p> <p>Multicast routing: <pre><code># Enable multicast forwarding (Linux router)\nsudo sysctl -w net.ipv4.conf.all.mc_forwarding=1\n\n# Add multicast route\nsudo route add -net 239.0.0.0 netmask 255.0.0.0 dev eth0\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#quality-of-service-qos","title":"Quality of Service (QoS)","text":""},{"location":"user-guide/outputs/edi-network/#traffic-prioritization","title":"Traffic Prioritization","text":"<p>Linux traffic control: <pre><code># Prioritize EDI traffic on eth0\nsudo tc qdisc add dev eth0 root handle 1: htb default 12\n\n# Create priority class\nsudo tc class add dev eth0 parent 1: classid 1:1 htb rate 1gbit\n\n# High priority for EDI\nsudo tc class add dev eth0 parent 1:1 classid 1:10 htb rate 10mbit prio 0\n\n# Filter EDI traffic (port 12000)\nsudo tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 \\\n  match ip dport 12000 0xffff flowid 1:10\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#router-qos","title":"Router QoS","text":"<p>Typical settings: - Protocol: UDP - Port: 12000 - Priority: High or Critical - Bandwidth reservation: 1-2 Mbps (safe margin)</p>"},{"location":"user-guide/outputs/edi-network/#monitoring-and-statistics","title":"Monitoring and Statistics","text":""},{"location":"user-guide/outputs/edi-network/#enable-verbose-output","title":"Enable Verbose Output","text":"<pre><code>python -m dabmux.cli -c config.yaml --edi udp://192.168.1.100:12000 -v\n</code></pre> <p>Statistics displayed: - Packets sent - Bytes transmitted - Sequence numbers - Errors detected - Buffer status</p>"},{"location":"user-guide/outputs/edi-network/#example-output","title":"Example Output","text":"<pre><code>INFO: Generated frame 1000\nINFO: EDI: Sent 1000 packets, 6,200,000 bytes\nINFO: EDI: Sequence 1000, 0 errors\nINFO: EDI: Send buffer: 15% full\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#network-monitoring","title":"Network Monitoring","text":"<p>Check UDP traffic: <pre><code># Monitor outgoing EDI packets\nsudo tcpdump -i eth0 udp port 12000 -v\n\n# Count packets\nsudo tcpdump -i eth0 udp port 12000 -c 100\n</code></pre></p> <p>Check TCP connection: <pre><code># Monitor TCP connection\nnetstat -tn | grep 12000\n\n# Example output:\n# tcp    0    0 192.168.1.50:45678    192.168.1.100:12000    ESTABLISHED\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#udp-vs-tcp","title":"UDP vs TCP","text":""},{"location":"user-guide/outputs/edi-network/#udp-streaming","title":"UDP Streaming","text":"<p>Advantages: - \u2705 Low latency (1-10ms) - \u2705 Multicast support - \u2705 Simple protocol - \u2705 Lower overhead</p> <p>Disadvantages: - \u274c No delivery guarantee - \u274c Packet loss possible - \u274c No congestion control - \u274c Sequence gaps on loss</p> <p>Use when: - Low latency critical - Reliable network (&lt; 1% loss) - Multicast needed - Using PFT for error recovery</p>"},{"location":"user-guide/outputs/edi-network/#tcp-streaming","title":"TCP Streaming","text":"<p>Advantages: - \u2705 Guaranteed delivery - \u2705 No packet loss - \u2705 Automatic retransmission - \u2705 Congestion control</p> <p>Disadvantages: - \u274c Higher latency (10-50ms) - \u274c No multicast - \u274c Head-of-line blocking - \u274c Connection overhead</p> <p>Use when: - Reliability critical - Network has packet loss - Point-to-point only - Latency tolerance &gt; 20ms</p>"},{"location":"user-guide/outputs/edi-network/#real-time-streaming-setup","title":"Real-time Streaming Setup","text":""},{"location":"user-guide/outputs/edi-network/#complete-production-setup","title":"Complete Production Setup","text":"<p>Multiplexer (192.168.1.50):</p> <pre><code>#!/bin/bash\n# Start multiplexer with EDI streaming\n\nLOG_DIR=\"/var/log/dabmux\"\nmkdir -p \"$LOG_DIR\"\n\nwhile true; do\n    python -m dabmux.cli \\\n      -c /etc/dabmux/production.yaml \\\n      --edi udp://192.168.1.100:12000 \\\n      --pft \\\n      --pft-fec 3 \\\n      --pft-fec-m 5 \\\n      --tist \\\n      --continuous \\\n      -v 2&gt;&amp;1 | tee -a \"$LOG_DIR/dabmux_$(date +%Y%m%d).log\"\n\n    echo \"Multiplexer stopped, restarting in 5 seconds...\"\n    sleep 5\ndone\n</code></pre> <p>Modulator (192.168.1.100):</p> <p>Must be configured to: - Listen on UDP port 12000 - Accept EDI with PFT - Handle TIST timestamps</p>"},{"location":"user-guide/outputs/edi-network/#systemd-service","title":"Systemd Service","text":"<p>Create <code>/etc/systemd/system/dabmux-edi.service</code>:</p> <pre><code>[Unit]\nDescription=DAB Multiplexer with EDI Streaming\nAfter=network.target\n\n[Service]\nType=simple\nUser=dabmux\nGroup=dabmux\nWorkingDirectory=/opt/dabmux\nExecStart=/opt/dabmux/bin/start_edi_stream.sh\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Enable and start: <pre><code>sudo systemctl daemon-reload\nsudo systemctl enable dabmux-edi\nsudo systemctl start dabmux-edi\nsudo systemctl status dabmux-edi\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"user-guide/outputs/edi-network/#multiple-edi-outputs","title":"Multiple EDI Outputs","text":"<pre><code># Send to multiple destinations (requires script)\n# Not supported directly - use multicast or PFT broadcast\n</code></pre> <p>Multicast solution: <pre><code># Send to multicast group\npython -m dabmux.cli -c config.yaml --edi udp://239.1.2.3:12000\n\n# Multiple receivers join multicast group\n# Each modulator independently receives stream\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#redundancy","title":"Redundancy","text":"<p>Primary + Backup: <pre><code>#!/bin/bash\n# Primary multiplexer\n\npython -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --continuous &amp;\n\n# Backup multiplexer (same config, same multicast)\npython -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --continuous &amp;\n\n# Modulator receives from both, uses first/best\n</code></pre></p>"},{"location":"user-guide/outputs/edi-network/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/outputs/edi-network/#no-connection-cannot-send","title":"No Connection / Cannot Send","text":"<p>Problem: <pre><code>ERROR: Cannot send to udp://192.168.1.100:12000\n</code></pre></p> <p>Diagnosis: <pre><code># Test connectivity\nping 192.168.1.100\n\n# Test UDP port (send test packet)\necho \"test\" | nc -u 192.168.1.100 12000\n\n# Check firewall\nsudo iptables -L -n | grep 12000\n</code></pre></p> <p>Solutions: 1. Check network connectivity 2. Verify firewall allows UDP/TCP port 12000 3. Ensure modulator is listening 4. Check IP address and port</p>"},{"location":"user-guide/outputs/edi-network/#packet-loss","title":"Packet Loss","text":"<p>Problem: <pre><code>WARNING: EDI: High packet loss detected\n</code></pre></p> <p>Diagnosis: <pre><code># Monitor packet loss\nsudo tcpdump -i eth0 udp port 12000 -c 1000\n\n# Check network statistics\nnetstat -s | grep -i \"packet loss\"\n\n# Test with iperf\niperf3 -c 192.168.1.100 -u -b 1M\n</code></pre></p> <p>Solutions: 1. Enable PFT with FEC: Recovers lost packets 2. Use TCP instead of UDP: Guaranteed delivery 3. Improve network: Better switches, dedicated VLAN 4. Reduce other traffic: QoS prioritization 5. Check cables and interfaces: Physical layer issues</p>"},{"location":"user-guide/outputs/edi-network/#multicast-not-working","title":"Multicast Not Working","text":"<p>Problem: Multicast packets not received</p> <p>Diagnosis: <pre><code># Check IGMP support\ncat /proc/net/igmp\n\n# Test multicast join\nsudo ip maddr add 239.1.2.3 dev eth0\nsudo tcpdump -i eth0 'dst 239.1.2.3'\n\n# Check routing\nroute -n | grep 239\n</code></pre></p> <p>Solutions: 1. Enable IGMP on router and switches 2. Add multicast route: <pre><code>sudo route add -net 239.0.0.0 netmask 255.0.0.0 dev eth0\n</code></pre> 3. Join multicast group manually 4. Check TTL value: Increase if packets don't reach destination</p>"},{"location":"user-guide/outputs/edi-network/#high-latency","title":"High Latency","text":"<p>Problem: Unacceptable delay</p> <p>Typical latency: - UDP without PFT: 1-10ms - UDP with PFT: 10-30ms - TCP: 10-50ms</p> <p>If higher:</p> <p>Solutions: 1. Use UDP instead of TCP 2. Disable PFT if network reliable 3. Reduce network hops: Direct connection 4. Check network congestion: QoS, traffic shaping 5. Upgrade network infrastructure</p>"},{"location":"user-guide/outputs/edi-network/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/outputs/edi-network/#network-design","title":"Network Design","text":"<ol> <li>Dedicated network: Separate VLAN for streaming</li> <li>Gigabit links: Minimum 100 Mbps, prefer 1 Gbps</li> <li>Managed switches: Enable multicast filtering, QoS</li> <li>Redundant paths: Multiple network routes</li> <li>Low latency: Minimize hops between encoder and modulator</li> </ol>"},{"location":"user-guide/outputs/edi-network/#protocol-selection","title":"Protocol Selection","text":"<ol> <li>Use UDP + PFT for most deployments</li> <li>Use TCP only if packet loss &gt; 2% and can tolerate latency</li> <li>Use multicast for one-to-many distribution</li> <li>Enable TIST for SFN or multi-transmitter setups</li> </ol>"},{"location":"user-guide/outputs/edi-network/#monitoring","title":"Monitoring","text":"<ol> <li>Log all output: Keep verbose logs</li> <li>Monitor packet loss: Alert on &gt; 0.5%</li> <li>Track sequence gaps: Indicates lost packets</li> <li>Bandwidth monitoring: Ensure sufficient headroom</li> <li>Automated alerts: Email/SMS on failures</li> </ol>"},{"location":"user-guide/outputs/edi-network/#security","title":"Security","text":"<ol> <li>Firewall: Only allow necessary ports</li> <li>VPN: Use VPN for remote streaming</li> <li>Private networks: Keep streaming on internal networks</li> <li>Authentication: Modulator-side authentication if supported</li> <li>Monitoring: Watch for unusual traffic</li> </ol>"},{"location":"user-guide/outputs/edi-network/#examples","title":"Examples","text":""},{"location":"user-guide/outputs/edi-network/#basic-udp-streaming","title":"Basic UDP Streaming","text":"<pre><code># Simple UDP streaming to local modulator\npython -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://127.0.0.1:12000 \\\n  --continuous\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#production-udp-pft","title":"Production UDP + PFT","text":"<pre><code># Production setup with error correction\npython -m dabmux.cli \\\n  -c production.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 5 \\\n  --tist \\\n  --continuous \\\n  -v\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#multicast-distribution","title":"Multicast Distribution","text":"<pre><code># Send to multicast for multiple receivers\npython -m dabmux.cli \\\n  -c config.yaml \\\n  --edi udp://239.1.2.3:12000 \\\n  --pft \\\n  --pft-fec 2 \\\n  --pft-fec-m 3 \\\n  --continuous\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#archival-streaming","title":"Archival + Streaming","text":"<pre><code># Archive to file AND stream to network\npython -m dabmux.cli \\\n  -c config.yaml \\\n  -o \"/archive/dab_$(date +%Y%m%d_%H%M%S).eti\" \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --continuous\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#tcp-for-reliable-delivery","title":"TCP for Reliable Delivery","text":"<pre><code># Use TCP for guaranteed delivery\npython -m dabmux.cli \\\n  -c config.yaml \\\n  --edi tcp://192.168.1.100:12000 \\\n  --continuous\n</code></pre>"},{"location":"user-guide/outputs/edi-network/#see-also","title":"See Also","text":"<ul> <li>Output Formats Overview: All output types</li> <li>PFT Fragmentation: Forward error correction details</li> <li>ETI Files: File-based output</li> <li>Architecture: EDI Protocol: Protocol stack diagrams</li> <li>PFT Tutorial: Step-by-step PFT setup</li> </ul>"},{"location":"user-guide/outputs/eti-files/","title":"ETI Files","text":"<p>Complete guide to ETI (Ensemble Transport Interface) file output.</p>"},{"location":"user-guide/outputs/eti-files/#overview","title":"Overview","text":"<p>ETI files contain DAB multiplex data in binary format. Each file consists of sequential ETI frames that can be played out to a transmitter or archived.</p> <p>Key properties: - Binary format - Fixed frame size (depends on transmission mode) - Self-contained (includes all multiplex data) - Standard format (ETSI EN 300 799)</p>"},{"location":"user-guide/outputs/eti-files/#eti-frame-structure","title":"ETI Frame Structure","text":""},{"location":"user-guide/outputs/eti-files/#mode-i-frame-most-common","title":"Mode I Frame (Most Common)","text":"<p>Total size: 6144 bytes per frame</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Section             \u2502 Bytes \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ERR                 \u2502     1 \u2502\n\u2502 FSYNC               \u2502     3 \u2502\n\u2502 FC (Frame Char.)    \u2502     4 \u2502\n\u2502 STC (Stream Char.)  \u2502   4\u00d7N \u2502  N = number of subchannels\n\u2502 EOH (End of Header) \u2502     4 \u2502\n\u2502 FIC (Fast Info)     \u2502    96 \u2502\n\u2502 MST (Main Service)  \u2502  5760 \u2502\n\u2502 EOF (End of Frame)  \u2502     4 \u2502\n\u2502 TIST (Timestamp)    \u2502     4 \u2502  Optional\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#frame-components","title":"Frame Components","text":""},{"location":"user-guide/outputs/eti-files/#err-error-status","title":"ERR (Error Status)","text":"<ul> <li>1 byte</li> <li>Indicates frame errors (normally 0x00)</li> </ul>"},{"location":"user-guide/outputs/eti-files/#fsync-frame-synchronization","title":"FSYNC (Frame Synchronization)","text":"<ul> <li>3 bytes: <code>0x073AB6</code></li> <li>Used to locate frame boundaries</li> </ul>"},{"location":"user-guide/outputs/eti-files/#fc-frame-characterization","title":"FC (Frame Characterization)","text":"<ul> <li>4 bytes</li> <li>Contains mode, frame count, subfunctions</li> </ul>"},{"location":"user-guide/outputs/eti-files/#stc-stream-characterization","title":"STC (Stream Characterization)","text":"<ul> <li>4 bytes per subchannel</li> <li>Subchannel ID, start address, length</li> </ul>"},{"location":"user-guide/outputs/eti-files/#eoh-end-of-header","title":"EOH (End of Header)","text":"<ul> <li>4 bytes</li> <li>CRC of header (FC + STC)</li> </ul>"},{"location":"user-guide/outputs/eti-files/#fic-fast-information-channel","title":"FIC (Fast Information Channel)","text":"<ul> <li>96 bytes (Mode I)</li> <li>Contains FIGs (metadata)</li> </ul>"},{"location":"user-guide/outputs/eti-files/#mst-main-service-transport","title":"MST (Main Service Transport)","text":"<ul> <li>5760 bytes (Mode I)</li> <li>Subchannel audio/data</li> </ul>"},{"location":"user-guide/outputs/eti-files/#eof-end-of-frame","title":"EOF (End of Frame)","text":"<ul> <li>4 bytes</li> <li>CRC of frame</li> </ul>"},{"location":"user-guide/outputs/eti-files/#tist-timestamp","title":"TIST (Timestamp)","text":"<ul> <li>4 bytes (optional)</li> <li>Frame timestamp for synchronization</li> </ul>"},{"location":"user-guide/outputs/eti-files/#basic-file-output","title":"Basic File Output","text":""},{"location":"user-guide/outputs/eti-files/#generate-eti-file","title":"Generate ETI File","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti\n</code></pre> <p>Default behavior: - Generates frames until interrupted (Ctrl+C) - Or until <code>-n</code> frame count reached</p>"},{"location":"user-guide/outputs/eti-files/#limited-frame-count","title":"Limited Frame Count","text":"<pre><code># Generate exactly 1000 frames\npython -m dabmux.cli -c config.yaml -o output.eti -n 1000\n</code></pre> <p>File size calculation: <pre><code>Mode I: 1000 frames \u00d7 6144 bytes = 6,144,000 bytes (~6 MB)\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#duration-calculation","title":"Duration Calculation","text":"<p>Mode I frame duration: 96 ms</p> <p>Examples: - 1 second: ~10.42 frames - 1 minute: ~625 frames (~3.75 MB) - 1 hour: ~37,500 frames (~225 MB) - 24 hours: ~900,000 frames (~5.4 GB)</p> <p>Calculate frames for duration: <pre><code># 5 minutes of content\nframes=$((5 * 60 * 1000 / 96))  # 3125 frames\npython -m dabmux.cli -c config.yaml -o output.eti -n $frames\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#continuous-generation","title":"Continuous Generation","text":""},{"location":"user-guide/outputs/eti-files/#loop-input-files","title":"Loop Input Files","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti --continuous\n</code></pre> <p>Behavior: - Input files loop automatically at end - Generates frames indefinitely - Stop with Ctrl+C</p> <p>Use cases: - Test signal generation - Looped content playout - Long-running tests</p>"},{"location":"user-guide/outputs/eti-files/#eti-with-timestamps","title":"ETI with Timestamps","text":""},{"location":"user-guide/outputs/eti-files/#enable-tist","title":"Enable TIST","text":"<pre><code>python -m dabmux.cli -c config.yaml -o output.eti --tist\n</code></pre> <p>Adds 4-byte timestamp to each frame: - Resolution: ~61 nanoseconds - Epoch: 1970-01-01 00:00:00 UTC - Used for transmitter synchronization</p> <p>Frame size with TIST: - Mode I: 6144 + 4 = 6148 bytes per frame</p> <p>Purpose: - Single Frequency Networks (SFN) - Multi-transmitter synchronization - Precise timing reference</p> <p>See Timestamps for details.</p>"},{"location":"user-guide/outputs/eti-files/#file-management","title":"File Management","text":""},{"location":"user-guide/outputs/eti-files/#file-naming","title":"File Naming","text":"<p>Date-based naming: <pre><code>python -m dabmux.cli -c config.yaml \\\n  -o \"/archive/$(date +%Y%m%d_%H%M%S).eti\"\n</code></pre></p> <p>Example output: <code>/archive/20260213_143022.eti</code></p> <p>Sequential naming: <pre><code>#!/bin/bash\ncounter=0\nwhile true; do\n    python -m dabmux.cli -c config.yaml \\\n      -o \"output_${counter}.eti\" \\\n      -n 37500  # 1 hour\n    counter=$((counter + 1))\ndone\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#file-rotation","title":"File Rotation","text":"<p>Hourly rotation: <pre><code>#!/bin/bash\n# Generate 1 hour ETI files continuously\n\nwhile true; do\n    filename=\"/archive/$(date +%Y%m%d_%H0000).eti\"\n    echo \"Starting $filename\"\n\n    # 1 hour = ~37500 frames for Mode I\n    python -m dabmux.cli -c config.yaml -o \"$filename\" -n 37500\n\n    echo \"Completed $filename\"\ndone\n</code></pre></p> <p>Using cron: <pre><code># crontab -e\n0 * * * * /usr/local/bin/generate_eti_hour.sh\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#verifying-eti-files","title":"Verifying ETI Files","text":""},{"location":"user-guide/outputs/eti-files/#check-file-size","title":"Check File Size","text":"<pre><code># Mode I without TIST\nls -lh output.eti\n\n# Should be multiple of 6144 bytes\nsize=$(stat -f%z output.eti)  # macOS\n# size=$(stat -c%s output.eti)  # Linux\n\nframes=$((size / 6144))\necho \"File contains $frames frames\"\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#verify-frame-sync","title":"Verify Frame Sync","text":"<pre><code># Check for valid FSYNC pattern (0x073AB6)\nhexdump -C output.eti | head -20 | grep \"07 3a b6\"\n</code></pre> <p>Expected output: <pre><code>00000000  00 07 3a b6 ...\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#extract-frame-info","title":"Extract Frame Info","text":"<pre><code>#!/usr/bin/env python3\nimport struct\n\ndef read_eti_header(filename):\n    with open(filename, 'rb') as f:\n        err = struct.unpack('B', f.read(1))[0]\n        fsync = f.read(3)\n        fc = f.read(4)\n\n        print(f\"ERR: 0x{err:02X}\")\n        print(f\"FSYNC: {fsync.hex()}\")\n        print(f\"Frame valid: {fsync.hex() == '073ab6'}\")\n\nread_eti_header('output.eti')\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#playout-to-transmitter","title":"Playout to Transmitter","text":""},{"location":"user-guide/outputs/eti-files/#real-time-playout","title":"Real-time Playout","text":"<p>Using external tools:</p> <p>Most DAB modulators accept ETI files via stdin:</p> <pre><code># Play ETI file at correct frame rate\npython3 &lt;&lt; 'EOF'\nimport time\nimport sys\n\nFRAME_SIZE = 6144\nFRAME_DURATION = 0.096  # 96 ms for Mode I\n\nwith open('output.eti', 'rb') as f:\n    start_time = time.time()\n    frame_num = 0\n\n    while True:\n        frame = f.read(FRAME_SIZE)\n        if not frame:\n            break\n\n        sys.stdout.buffer.write(frame)\n        sys.stdout.buffer.flush()\n\n        # Wait for frame timing\n        frame_num += 1\n        expected_time = start_time + (frame_num * FRAME_DURATION)\n        sleep_time = expected_time - time.time()\n        if sleep_time &gt; 0:\n            time.sleep(sleep_time)\nEOF\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#looped-playout","title":"Looped Playout","text":"<pre><code>#!/bin/bash\n# Loop ETI file to modulator\n\nwhile true; do\n    # Read and send ETI frames with timing\n    python3 playout_eti.py output.eti | nc modulator_ip modulator_port\ndone\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#converting-eti-files","title":"Converting ETI Files","text":""},{"location":"user-guide/outputs/eti-files/#extract-audio-stream","title":"Extract Audio Stream","text":"<p>Using ODR-DabMux tools (if available):</p> <pre><code># Extract subchannel 0\nodr-eti2mpa output.eti -s 0 -o extracted.mp2\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#analyze-eti-content","title":"Analyze ETI Content","text":"<p>Frame count: <pre><code>size=$(stat -c%s output.eti)\nframes=$((size / 6144))\nduration=$(echo \"scale=2; $frames * 0.096\" | bc)\necho \"$frames frames = $duration seconds\"\n</code></pre></p> <p>Example: <pre><code>37500 frames = 3600.00 seconds = 1 hour\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#storage-and-archival","title":"Storage and Archival","text":""},{"location":"user-guide/outputs/eti-files/#compression","title":"Compression","text":"<p>ETI files compress well:</p> <pre><code># gzip compression (~30-40% reduction)\ngzip output.eti\n# Creates output.eti.gz\n\n# Decompress\ngunzip output.eti.gz\n\n# xz compression (~40-50% reduction)\nxz -9 output.eti\n# Creates output.eti.xz\n\n# Decompress\nunxz output.eti.xz\n</code></pre> <p>Compression ratios (approximate): - gzip: 60-70% of original size - xz: 50-60% of original size - bzip2: 55-65% of original size</p> <p>1-hour file: - Original: ~225 MB - gzipped: ~135-160 MB - xz: ~110-135 MB</p>"},{"location":"user-guide/outputs/eti-files/#archive-script","title":"Archive Script","text":"<pre><code>#!/bin/bash\n# Archive and compress ETI files\n\nARCHIVE_DIR=\"/archive\"\nSOURCE_DIR=\"/output\"\n\n# Move and compress files older than 1 day\nfind \"$SOURCE_DIR\" -name \"*.eti\" -mtime +1 | while read file; do\n    echo \"Archiving $file\"\n    xz -9 \"$file\"\n    mv \"${file}.xz\" \"$ARCHIVE_DIR/\"\ndone\n\n# Delete archives older than 30 days\nfind \"$ARCHIVE_DIR\" -name \"*.eti.xz\" -mtime +30 -delete\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#disk-space-management","title":"Disk Space Management","text":"<p>Monitor disk usage: <pre><code>#!/bin/bash\n# Alert if disk usage &gt; 80%\n\nusage=$(df /archive | tail -1 | awk '{print $5}' | sed 's/%//')\n\nif [ \"$usage\" -gt 80 ]; then\n    echo \"WARNING: Disk usage at ${usage}%\"\n    # Send alert (email, SMS, etc.)\n    # Delete oldest files\n    find /archive -name \"*.eti.xz\" -mtime +7 -delete\nfi\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/outputs/eti-files/#multiple-output-files","title":"Multiple Output Files","text":"<p>Parallel generation: <pre><code># Generate multiple configurations simultaneously\n\npython -m dabmux.cli -c config1.yaml -o output1.eti -n 1000 &amp;\npython -m dabmux.cli -c config2.yaml -o output2.eti -n 1000 &amp;\npython -m dabmux.cli -c config3.yaml -o output3.eti -n 1000 &amp;\n\nwait\necho \"All files generated\"\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#combining-with-network-output","title":"Combining with Network Output","text":"<pre><code># Write file AND stream to network\npython -m dabmux.cli -c config.yaml \\\n  -o archive.eti \\\n  --edi udp://192.168.1.100:12000 \\\n  --continuous\n</code></pre> <p>Use cases: - Live broadcast with archival - Redundancy and backup - Monitoring and analysis</p>"},{"location":"user-guide/outputs/eti-files/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/outputs/eti-files/#file-too-small","title":"File Too Small","text":"<p>Problem: File smaller than expected</p> <p>Check: <pre><code># Mode I should be multiple of 6144\nsize=$(stat -c%s output.eti)\nremainder=$((size % 6144))\n\nif [ $remainder -ne 0 ]; then\n    echo \"ERROR: File size not multiple of frame size\"\n    echo \"Size: $size, Remainder: $remainder\"\nfi\n</code></pre></p> <p>Causes: - Process terminated early - Disk full - Permission denied</p>"},{"location":"user-guide/outputs/eti-files/#invalid-fsync","title":"Invalid FSYNC","text":"<p>Problem: File doesn't contain valid FSYNC</p> <p>Diagnosis: <pre><code># Check first few bytes\nhexdump -C output.eti | head -5\n</code></pre></p> <p>Should see: <code>00 07 3a b6</code> at start of each frame</p> <p>If not: - File corrupted - Wrong file format - Partial write</p>"},{"location":"user-guide/outputs/eti-files/#permission-denied","title":"Permission Denied","text":"<p>Problem: <pre><code>ERROR: Cannot create output.eti: Permission denied\n</code></pre></p> <p>Solutions: <pre><code># Check directory permissions\nls -ld $(dirname output.eti)\n\n# Create directory if needed\nmkdir -p /output\nchmod 755 /output\n\n# Check user permissions\ntouch /output/test &amp;&amp; rm /output/test\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#disk-full","title":"Disk Full","text":"<p>Problem: <pre><code>ERROR: Cannot write to output.eti: No space left on device\n</code></pre></p> <p>Solutions: <pre><code># Check disk space\ndf -h /output\n\n# Free space\nrm old_files*.eti\n# Or compress\ngzip old_files*.eti\n\n# Set up monitoring\ndu -sh /output\n</code></pre></p>"},{"location":"user-guide/outputs/eti-files/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/outputs/eti-files/#file-generation","title":"File Generation","text":"<ol> <li>Use absolute paths: <code>/archive/output.eti</code> not <code>output.eti</code></li> <li>Pre-check disk space: Before long generation runs</li> <li>Use timestamped names: Easy identification and organization</li> <li>Monitor generation: Use <code>-v</code> for verbose output</li> <li>Test first: Generate small files before production runs</li> </ol>"},{"location":"user-guide/outputs/eti-files/#storage","title":"Storage","text":"<ol> <li>Compress old files: Save 40-50% disk space</li> <li>Regular rotation: Move old files to archive</li> <li>Backup important files: Off-site or cloud storage</li> <li>Monitor disk usage: Alert before full</li> <li>Document naming scheme: Consistent file naming</li> </ol>"},{"location":"user-guide/outputs/eti-files/#production","title":"Production","text":"<ol> <li>Redundancy: Generate to multiple disks</li> <li>Validation: Check files after generation</li> <li>Monitoring: Log file sizes and timing</li> <li>Automation: Use scripts for rotation/archival</li> <li>Disaster recovery: Have backup generation ready</li> </ol>"},{"location":"user-guide/outputs/eti-files/#examples","title":"Examples","text":""},{"location":"user-guide/outputs/eti-files/#test-file-generation","title":"Test File Generation","text":"<pre><code># Generate 10-second test file\nframes=$((10 * 1000 / 96))  # ~104 frames\npython -m dabmux.cli -c config.yaml -o test.eti -n $frames\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#hourly-archive","title":"Hourly Archive","text":"<pre><code>#!/bin/bash\n# Generate 1-hour ETI file\n\nDATE=$(date +%Y%m%d_%H0000)\nOUTPUT=\"/archive/dab_${DATE}.eti\"\n\necho \"Generating $OUTPUT\"\npython -m dabmux.cli -c config.yaml -o \"$OUTPUT\" -n 37500\n\n# Compress\necho \"Compressing $OUTPUT\"\nxz -9 \"$OUTPUT\"\n\necho \"Completed ${OUTPUT}.xz\"\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#continuous-with-daily-rotation","title":"Continuous with Daily Rotation","text":"<pre><code>#!/bin/bash\n# Generate ETI with daily file rotation\n\nwhile true; do\n    DATE=$(date +%Y%m%d)\n    OUTPUT=\"/archive/dab_${DATE}.eti\"\n\n    echo \"Starting $OUTPUT\"\n\n    # Generate until end of day\n    end_of_day=$(date -d \"tomorrow 00:00:00\" +%s)\n    now=$(date +%s)\n    seconds=$((end_of_day - now))\n    frames=$((seconds * 1000 / 96))\n\n    python -m dabmux.cli -c config.yaml -o \"$OUTPUT\" -n $frames\n\n    echo \"Completed $OUTPUT\"\n\n    # Compress yesterday's file\n    yesterday=$(date -d \"yesterday\" +%Y%m%d)\n    if [ -f \"/archive/dab_${yesterday}.eti\" ]; then\n        xz -9 \"/archive/dab_${yesterday}.eti\" &amp;\n    fi\ndone\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#eti-file-structure-details","title":"ETI File Structure Details","text":""},{"location":"user-guide/outputs/eti-files/#frame-header-fields","title":"Frame Header Fields","text":"<p>FC (Frame Characterization) breakdown:</p> <pre><code>Byte 0: FCT (Frame Count in ETI)\n        - Incrementing counter (0-249)\n        - Wraps around\n\nByte 1: NST (Number of Streams)\n        - Number of subchannels\n        - 0-63\n\nByte 2-3: Flags and subfunctions\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#complete-frame-dump","title":"Complete Frame Dump","text":"<pre><code>#!/usr/bin/env python3\nimport struct\n\ndef dump_eti_frame(filename, frame_num=0):\n    FRAME_SIZE = 6144\n    with open(filename, 'rb') as f:\n        f.seek(frame_num * FRAME_SIZE)\n\n        # ERR\n        err = struct.unpack('B', f.read(1))[0]\n        print(f\"ERR: 0x{err:02X}\")\n\n        # FSYNC\n        fsync = f.read(3)\n        print(f\"FSYNC: {fsync.hex()}\")\n\n        # FC\n        fc = f.read(4)\n        fct = fc[0]\n        nst = fc[1]\n        print(f\"Frame Count: {fct}\")\n        print(f\"Num Subchannels: {nst}\")\n\n        # STC (4 bytes \u00d7 NST)\n        for i in range(nst):\n            stc = f.read(4)\n            scid = (stc[0] &gt;&gt; 2) &amp; 0x3F\n            sad = ((stc[0] &amp; 0x03) &lt;&lt; 8) | stc[1]\n            stl = (stc[2] &lt;&lt; 2) | (stc[3] &gt;&gt; 6)\n            print(f\"Subchannel {i}: ID={scid}, Start={sad}, Length={stl}\")\n\ndump_eti_frame('output.eti')\n</code></pre>"},{"location":"user-guide/outputs/eti-files/#see-also","title":"See Also","text":"<ul> <li>Output Formats Overview: All output types</li> <li>EDI Network: Network streaming</li> <li>PFT Fragmentation: Forward error correction</li> <li>Architecture: ETI Frames: Frame structure diagrams</li> <li>CLI Reference: Complete command options</li> </ul>"},{"location":"user-guide/outputs/pft-fragmentation/","title":"PFT Fragmentation and FEC","text":"<p>Complete guide to PFT (Protection, Fragmentation and Transport) with Reed-Solomon forward error correction.</p>"},{"location":"user-guide/outputs/pft-fragmentation/#overview","title":"Overview","text":"<p>PFT adds fragmentation and forward error correction (FEC) to EDI streaming, enabling reliable transmission over lossy networks.</p> <p>Key features: - Fragmentation: Splits large packets into smaller fragments - FEC: Reed-Solomon error correction codes - Sequence numbering: Detects missing fragments - Reassembly: Receiver reconstructs original packets</p> <p>Standard: ETSI TS 102 821</p>"},{"location":"user-guide/outputs/pft-fragmentation/#why-use-pft","title":"Why Use PFT?","text":""},{"location":"user-guide/outputs/pft-fragmentation/#problem-packet-loss","title":"Problem: Packet Loss","text":"<p>UDP has no delivery guarantee: - Network congestion \u2192 dropped packets - Router buffers \u2192 packet loss - Wireless links \u2192 interference - Long-distance links \u2192 higher loss probability</p> <p>Impact on DAB: - Lost ETI data = audio dropouts - Missing FIG data = service info gaps - Single lost packet = corrupt frame</p>"},{"location":"user-guide/outputs/pft-fragmentation/#solution-pft-with-fec","title":"Solution: PFT with FEC","text":"<p>Reed-Solomon FEC: - Adds redundant data - Can recover lost fragments - No retransmission needed - Bounded latency</p> <p>Example: - Send 10 fragments - Add 3 FEC fragments - Total: 13 fragments - Can lose any 3 and still recover original data</p>"},{"location":"user-guide/outputs/pft-fragmentation/#basic-pft-configuration","title":"Basic PFT Configuration","text":""},{"location":"user-guide/outputs/pft-fragmentation/#enable-pft","title":"Enable PFT","text":"<pre><code>python -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft\n</code></pre> <p>Default PFT settings: - Fragmentation: Enabled - FEC: Disabled (must enable explicitly) - Fragment size: 512 bytes</p>"},{"location":"user-guide/outputs/pft-fragmentation/#enable-fec","title":"Enable FEC","text":"<pre><code>python -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 2 \\\n  --pft-fec-m 3\n</code></pre> <p>Parameters: - <code>--pft-fec 2</code>: FEC depth (RS overhead) - <code>--pft-fec-m 3</code>: Maximum correctable fragments</p>"},{"location":"user-guide/outputs/pft-fragmentation/#fec-parameters","title":"FEC Parameters","text":""},{"location":"user-guide/outputs/pft-fragmentation/#fec-depth-pft-fec","title":"FEC Depth (<code>--pft-fec</code>)","text":"<p>Range: 0-20 Default: 0 (disabled)</p> <p>Meaning: Number of additional FEC fragments per group</p> <p>Example: <pre><code>--pft-fec 3\n</code></pre></p> <p>If original data requires 10 fragments: - Original: 10 fragments - FEC: 3 fragments - Total sent: 13 fragments - Overhead: 30%</p>"},{"location":"user-guide/outputs/pft-fragmentation/#maximum-correctable-pft-fec-m","title":"Maximum Correctable (<code>--pft-fec-m</code>)","text":"<p>Range: 0-20 (must be \u2264 FEC depth) Default: 0</p> <p>Meaning: Maximum number of fragment losses that can be corrected</p> <p>Example: <pre><code>--pft-fec 5 --pft-fec-m 5\n</code></pre></p> <ul> <li>Can correct up to 5 lost fragments</li> <li>Requires 5 FEC fragments overhead</li> <li>100% overhead if original = 5 fragments</li> </ul>"},{"location":"user-guide/outputs/pft-fragmentation/#relationship","title":"Relationship","text":"<p>Rule: <code>FEC-M \u2264 FEC depth</code></p> <pre><code>Can correct: min(FEC-M, number of FEC fragments)\n</code></pre> <p>Examples:</p> Original FEC Depth FEC-M Total Sent Can Lose 10 2 2 12 Up to 2 10 3 3 13 Up to 3 10 5 3 15 Up to 3* 10 3 5 13 Up to 3* <p>* Limited by smaller value</p>"},{"location":"user-guide/outputs/pft-fragmentation/#reed-solomon-fec","title":"Reed-Solomon FEC","text":""},{"location":"user-guide/outputs/pft-fragmentation/#how-it-works","title":"How It Works","text":"<p>Reed-Solomon codes: 1. Takes N data symbols 2. Generates K parity symbols 3. Total: N + K symbols 4. Can recover original from any N symbols 5. Tolerates up to K losses</p> <p>In PFT context: - N = Original fragments - K = FEC depth - M = Maximum corrections (\u2264 K)</p>"},{"location":"user-guide/outputs/pft-fragmentation/#mathematics","title":"Mathematics","text":"<p>Galois Field GF(256): - Operations on 8-bit symbols - Polynomial arithmetic - Generator polynomial creates parity</p> <p>Encoding: <pre><code>For message M with n fragments:\n1. Compute k FEC fragments\n2. Send all n + k fragments\n3. Any n fragments sufficient to decode\n</code></pre></p> <p>Decoding: <pre><code>Receiver needs n fragments:\n1. Collect fragments (any n of n+k)\n2. Identify which are missing\n3. Use FEC to reconstruct\n4. Recover original message M\n</code></pre></p> <p>See Advanced: Reed-Solomon for mathematical details.</p>"},{"location":"user-guide/outputs/pft-fragmentation/#fragment-size","title":"Fragment Size","text":""},{"location":"user-guide/outputs/pft-fragmentation/#configure-fragment-size","title":"Configure Fragment Size","text":"<pre><code>python -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fragment-size 1024\n</code></pre> <p>Default: 512 bytes Range: 64 - 1400 bytes</p>"},{"location":"user-guide/outputs/pft-fragmentation/#choosing-fragment-size","title":"Choosing Fragment Size","text":"<p>Smaller fragments (256-512): - \u2705 Less data lost per packet - \u2705 Fits in most networks (MTU) - \u2705 Better for high-loss networks - \u274c More fragments = more overhead - \u274c Higher packet rate</p> <p>Larger fragments (1024-1400): - \u2705 Fewer fragments needed - \u2705 Lower overhead - \u2705 Lower packet rate - \u274c More data lost per packet - \u274c May exceed MTU</p> <p>Recommended: 512-1024 bytes</p> <p>MTU consideration: <pre><code>Fragment size + UDP header + IP header \u2264 MTU\n\nTypical MTU: 1500 bytes\nUDP header: 8 bytes\nIP header: 20 bytes\nSafe maximum: 1472 bytes\n\nRecommended: 1024 bytes (safe margin)\n</code></pre></p>"},{"location":"user-guide/outputs/pft-fragmentation/#bandwidth-and-overhead","title":"Bandwidth and Overhead","text":""},{"location":"user-guide/outputs/pft-fragmentation/#calculate-overhead","title":"Calculate Overhead","text":"<p>Formula: <pre><code>Overhead = (FEC_depth / Original_fragments) \u00d7 100%\n</code></pre></p> <p>Examples:</p> Original FEC Overhead 10 2 20% 10 3 30% 10 5 50% 12 3 25%"},{"location":"user-guide/outputs/pft-fragmentation/#total-bandwidth","title":"Total Bandwidth","text":"<p>Formula: <pre><code>Total bandwidth = ETI bandwidth \u00d7 (1 + Overhead)\n</code></pre></p> <p>Mode I example: - ETI: ~590 kbps (including EDI overhead) - FEC depth 3 (30% overhead) - Total: 590 \u00d7 1.30 = 767 kbps</p>"},{"location":"user-guide/outputs/pft-fragmentation/#bandwidth-table","title":"Bandwidth Table","text":"Mode Base FEC 2 (20%) FEC 3 (30%) FEC 5 (50%) I 590 kbps 708 kbps 767 kbps 885 kbps II 148 kbps 178 kbps 192 kbps 222 kbps IV 295 kbps 354 kbps 384 kbps 443 kbps"},{"location":"user-guide/outputs/pft-fragmentation/#latency","title":"Latency","text":""},{"location":"user-guide/outputs/pft-fragmentation/#fragmentation-latency","title":"Fragmentation Latency","text":"<p>Sender: 1. Wait for complete AF packet 2. Fragment into pieces 3. Calculate FEC 4. Send fragments</p> <p>Additional delay: ~1-2 frame durations</p>"},{"location":"user-guide/outputs/pft-fragmentation/#receiver-reassembly","title":"Receiver Reassembly","text":"<p>Receiver: 1. Collect all fragments 2. Perform FEC decoding if needed 3. Reconstruct packet 4. Deliver to application</p> <p>Additional delay: ~1 frame duration</p>"},{"location":"user-guide/outputs/pft-fragmentation/#total-pft-latency","title":"Total PFT Latency","text":"<p>Without PFT: 1-10ms With PFT: 10-30ms additional</p> <p>Total UDP + PFT: ~20-40ms</p> <p>Acceptable for: - Live broadcasting (not critical) - Studio-to-transmitter links</p> <p>Not suitable for: - Interactive applications - Ultra-low-latency required</p>"},{"location":"user-guide/outputs/pft-fragmentation/#configuration-examples","title":"Configuration Examples","text":""},{"location":"user-guide/outputs/pft-fragmentation/#low-loss-network-05","title":"Low Loss Network (&lt; 0.5%)","text":"<pre><code># Minimal FEC for occasional losses\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 2 \\\n  --pft-fec-m 2 \\\n  --pft-fragment-size 1024\n</code></pre> <p>Settings: - FEC depth: 2 (20% overhead) - Max corrections: 2 - Fragment size: 1024 bytes</p> <p>Protection: Corrects up to 2 lost fragments per group</p>"},{"location":"user-guide/outputs/pft-fragmentation/#medium-loss-network-05-2","title":"Medium Loss Network (0.5-2%)","text":"<pre><code># Moderate FEC for typical networks\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 3 \\\n  --pft-fragment-size 512\n</code></pre> <p>Settings: - FEC depth: 3 (30% overhead) - Max corrections: 3 - Fragment size: 512 bytes</p> <p>Protection: Corrects up to 3 lost fragments per group</p>"},{"location":"user-guide/outputs/pft-fragmentation/#high-loss-network-2-5","title":"High Loss Network (2-5%)","text":"<pre><code># Strong FEC for challenging networks\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 5 \\\n  --pft-fec-m 5 \\\n  --pft-fragment-size 512\n</code></pre> <p>Settings: - FEC depth: 5 (50% overhead) - Max corrections: 5 - Fragment size: 512 bytes</p> <p>Protection: Corrects up to 5 lost fragments per group</p>"},{"location":"user-guide/outputs/pft-fragmentation/#maximum-protection","title":"Maximum Protection","text":"<pre><code># Highest FEC for extreme conditions\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 10 \\\n  --pft-fec-m 10 \\\n  --pft-fragment-size 512\n</code></pre> <p>Settings: - FEC depth: 10 (100%+ overhead) - Max corrections: 10 - Fragment size: 512 bytes</p> <p>Protection: Corrects up to 10 lost fragments per group</p> <p>Use only when: Network has 5-10% packet loss</p>"},{"location":"user-guide/outputs/pft-fragmentation/#testing-pft","title":"Testing PFT","text":""},{"location":"user-guide/outputs/pft-fragmentation/#simulate-packet-loss","title":"Simulate Packet Loss","text":"<p>Using netem (Linux): <pre><code># Add 2% packet loss\nsudo tc qdisc add dev eth0 root netem loss 2%\n\n# Test streaming with loss\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 3 \\\n  -v\n\n# Remove packet loss\nsudo tc qdisc del dev eth0 root\n</code></pre></p>"},{"location":"user-guide/outputs/pft-fragmentation/#monitor-fec-performance","title":"Monitor FEC Performance","text":"<p>Verbose output shows: <pre><code>INFO: PFT: 1000 packets sent\nINFO: PFT: 100 fragments total\nINFO: PFT: 30 FEC fragments (30% overhead)\nINFO: PFT: 0 reconstruction errors\n</code></pre></p>"},{"location":"user-guide/outputs/pft-fragmentation/#measure-effectiveness","title":"Measure Effectiveness","text":"<p>Without FEC: <pre><code># Test without FEC\nsudo tc qdisc add dev eth0 root netem loss 2%\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --continuous\n\n# Expect errors at receiver\n</code></pre></p> <p>With FEC: <pre><code># Test with FEC\nsudo tc qdisc add dev eth0 root netem loss 2%\npython -m dabmux.cli -c config.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 3 \\\n  --continuous\n\n# Should have zero errors (FEC recovers)\n</code></pre></p>"},{"location":"user-guide/outputs/pft-fragmentation/#production-recommendations","title":"Production Recommendations","text":""},{"location":"user-guide/outputs/pft-fragmentation/#fec-settings-by-network-quality","title":"FEC Settings by Network Quality","text":"Packet Loss FEC Depth FEC-M Fragment Size &lt; 0.1% 0 (off) 0 1024 0.1-0.5% 2 2 1024 0.5-1% 2 2 512 1-2% 3 3 512 2-5% 5 5 512 5-10% 10 10 512 &gt; 10% Fix network!"},{"location":"user-guide/outputs/pft-fragmentation/#tuning-process","title":"Tuning Process","text":"<ol> <li> <p>Measure packet loss: <pre><code># Use iperf3 to measure loss\niperf3 -c 192.168.1.100 -u -b 1M -l 1024 -t 60\n</code></pre></p> </li> <li> <p>Start conservative: <pre><code>--pft-fec 2 --pft-fec-m 2\n</code></pre></p> </li> <li> <p>Monitor receiver: Check for FEC corrections and errors</p> </li> <li> <p>Increase if needed: <pre><code>--pft-fec 3 --pft-fec-m 3\n</code></pre></p> </li> <li> <p>Verify bandwidth: Ensure total bandwidth &lt; link capacity</p> </li> </ol>"},{"location":"user-guide/outputs/pft-fragmentation/#dont-over-provision","title":"Don't Over-Provision","text":"<p>Too much FEC: - \u274c Wastes bandwidth - \u274c Increases latency - \u274c No additional benefit - \u274c May cause congestion</p> <p>Right-sizing: - \u2705 Just enough to handle typical losses - \u2705 Monitor and adjust based on real data - \u2705 Leave 20% bandwidth margin</p>"},{"location":"user-guide/outputs/pft-fragmentation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/outputs/pft-fragmentation/#fec-not-correcting-losses","title":"FEC Not Correcting Losses","text":"<p>Problem: Still seeing errors despite FEC</p> <p>Diagnosis: <pre><code># Check if loss exceeds FEC capability\n# Example: 5% loss with FEC depth 3\n\n# Test current loss rate\niperf3 -c 192.168.1.100 -u -b 1M -t 60\n</code></pre></p> <p>Solutions: 1. Increase FEC depth: <pre><code>--pft-fec 5 --pft-fec-m 5\n</code></pre></p> <ol> <li> <p>Reduce fragment size: More fragments = better loss distribution    <pre><code>--pft-fragment-size 512\n</code></pre></p> </li> <li> <p>Fix network: If loss &gt; 5%, improve network infrastructure</p> </li> </ol>"},{"location":"user-guide/outputs/pft-fragmentation/#high-overheadbandwidth","title":"High Overhead/Bandwidth","text":"<p>Problem: Excessive bandwidth usage</p> <p>Check: <pre><code># Monitor actual bandwidth\niftop -i eth0\n# or\nnload eth0\n</code></pre></p> <p>Solutions: 1. Reduce FEC if network improved: <pre><code>--pft-fec 2 --pft-fec-m 2  # from 5\n</code></pre></p> <ol> <li> <p>Increase fragment size: <pre><code>--pft-fragment-size 1024  # from 512\n</code></pre></p> </li> <li> <p>Disable FEC if network excellent: <pre><code>--pft  # No --pft-fec flags\n</code></pre></p> </li> </ol>"},{"location":"user-guide/outputs/pft-fragmentation/#increased-latency","title":"Increased Latency","text":"<p>Problem: Unacceptable delay with PFT</p> <p>Measure latency: <pre><code>ping 192.168.1.100\n</code></pre></p> <p>Solutions: 1. Reduce FEC depth: Less processing time 2. Optimize network: Reduce hops, congestion 3. Consider TCP: If latency already high, TCP may be better 4. Disable PFT: If network is reliable enough</p>"},{"location":"user-guide/outputs/pft-fragmentation/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/outputs/pft-fragmentation/#configuration","title":"Configuration","text":"<ol> <li>Match network conditions: Measure loss, set FEC accordingly</li> <li>Conservative start: Begin with FEC 2-3, increase if needed</li> <li>Monitor performance: Watch for corrections and errors</li> <li>Document settings: Keep record of what works</li> <li>Test before production: Simulate losses, verify recovery</li> </ol>"},{"location":"user-guide/outputs/pft-fragmentation/#monitoring","title":"Monitoring","text":"<ol> <li>Track packet loss: Use iperf3, network monitoring tools</li> <li>Log FEC statistics: Enable verbose logging</li> <li>Alert on errors: Set up notifications for unrecoverable errors</li> <li>Bandwidth monitoring: Ensure sufficient capacity</li> <li>Latency monitoring: Track end-to-end delay</li> </ol>"},{"location":"user-guide/outputs/pft-fragmentation/#optimization","title":"Optimization","text":"<ol> <li>Right-size FEC: Not too little, not too much</li> <li>Tune fragment size: Balance between loss and overhead</li> <li>QoS configuration: Prioritize PFT traffic</li> <li>Network improvements: Fix underlying issues</li> <li>Regular testing: Periodic validation of settings</li> </ol>"},{"location":"user-guide/outputs/pft-fragmentation/#complete-examples","title":"Complete Examples","text":""},{"location":"user-guide/outputs/pft-fragmentation/#production-setup-with-monitoring","title":"Production Setup with Monitoring","text":"<pre><code>#!/bin/bash\n# Production PFT streaming with logging\n\nLOG_DIR=\"/var/log/dabmux\"\nmkdir -p \"$LOG_DIR\"\nLOG_FILE=\"$LOG_DIR/pft_$(date +%Y%m%d_%H%M%S).log\"\n\n# Measure network loss first\necho \"Testing network...\" | tee -a \"$LOG_FILE\"\niperf3 -c 192.168.1.100 -u -b 1M -t 10 &gt;&gt; \"$LOG_FILE\" 2&gt;&amp;1\n\n# Start multiplexer with PFT\necho \"Starting multiplexer with PFT...\" | tee -a \"$LOG_FILE\"\npython -m dabmux.cli \\\n  -c /etc/dabmux/production.yaml \\\n  --edi udp://192.168.1.100:12000 \\\n  --pft \\\n  --pft-fec 3 \\\n  --pft-fec-m 3 \\\n  --pft-fragment-size 512 \\\n  --tist \\\n  --continuous \\\n  -v 2&gt;&amp;1 | tee -a \"$LOG_FILE\"\n</code></pre>"},{"location":"user-guide/outputs/pft-fragmentation/#adaptive-fec-script","title":"Adaptive FEC Script","text":"<pre><code>#!/bin/bash\n# Adapt FEC based on measured packet loss\n\nDEST=\"udp://192.168.1.100:12000\"\nCONFIG=\"/etc/dabmux/config.yaml\"\n\n# Measure loss\nloss=$(iperf3 -c 192.168.1.100 -u -b 1M -t 10 | grep loss | awk '{print $13}' | tr -d '(%)' )\n\necho \"Measured packet loss: ${loss}%\"\n\n# Choose FEC based on loss\nif (( $(echo \"$loss &lt; 0.5\" | bc -l) )); then\n    fec=2\nelif (( $(echo \"$loss &lt; 2\" | bc -l) )); then\n    fec=3\nelif (( $(echo \"$loss &lt; 5\" | bc -l) )); then\n    fec=5\nelse\n    fec=10\nfi\n\necho \"Using FEC depth: $fec\"\n\n# Start with chosen FEC\npython -m dabmux.cli \\\n  -c \"$CONFIG\" \\\n  --edi \"$DEST\" \\\n  --pft \\\n  --pft-fec $fec \\\n  --pft-fec-m $fec \\\n  --continuous \\\n  -v\n</code></pre>"},{"location":"user-guide/outputs/pft-fragmentation/#see-also","title":"See Also","text":"<ul> <li>Output Formats Overview: All output types</li> <li>EDI Network: EDI streaming basics</li> <li>ETI Files: File-based output</li> <li>Advanced: Reed-Solomon: FEC mathematics</li> <li>PFT Tutorial: Step-by-step guide</li> </ul>"}]}